<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>[系列]Redis Server 实现·有序集合篇 - Yusank`s Site</title><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7859878302610774" crossorigin=anonymous></script><meta name=Description content="这是我的个人博客，我会在这里分享学习和成长过程中的积累和经验."><meta property="og:title" content="[系列]Redis Server 实现·有序集合篇"><meta property="og:description" content="
本篇讲述 Redis 中的基础数据结构 ZSet(SortedSet) 的底层实现原理和如何通过 go 语言实现一个 ZSet 的过程以及需要注意的问题。
"><meta property="og:type" content="article"><meta property="og:url" content="https://yusank.github.io/posts/redis-server-zset/"><meta property="og:image" content="https://yusank.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-07T10:50:00+08:00"><meta property="article:modified_time" content="2022-01-07T21:19:06+08:00"><meta property="og:site_name" content="My cool site"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yusank.github.io/logo.png"><meta name=twitter:title content="[系列]Redis Server 实现·有序集合篇"><meta name=twitter:description content="
本篇讲述 Redis 中的基础数据结构 ZSet(SortedSet) 的底层实现原理和如何通过 go 语言实现一个 ZSet 的过程以及需要注意的问题。
"><meta name=application-name content="Yusank's Site"><meta name=apple-mobile-web-app-title content="Yusank's Site"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://yusank.github.io/posts/redis-server-zset/><link rel=prev href=https://yusank.github.io/posts/redeis-server-list/><link rel=next href=https://yusank.github.io/posts/shard-map/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"[系列]Redis Server 实现·有序集合篇","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/yusank.github.io\/posts\/redis-server-zset\/"},"genre":"posts","keywords":"redis, 系列篇, 数据结构","wordcount":6280,"url":"https:\/\/yusank.github.io\/posts\/redis-server-zset\/","datePublished":"2022-01-07T10:50:00+08:00","dateModified":"2022-01-07T21:19:06+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Yusank"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Yusank`s Site"><img class="lazyload logo" src=/svg/loading.min.svg data-src=https://yusank.github.io/images/logo.svg data-srcset="https://yusank.github.io/images/logo.svg, https://yusank.github.io/images/logo.svg 1.5x, https://yusank.github.io/images/logo.svg 2x" data-sizes=auto alt=https://yusank.github.io/images/logo.svg title=https://yusank.github.io/images/logo.svg><span id=id-1 class=typeit></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/about/>关于 </a><a class=menu-item href=/links/>友链 </a><a class=menu-item href=https://github.com/yusank title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw'></i> </a><a class=menu-item href=https://go-goim.github.io title=GoIM rel="noopener noreffer" target=_blank><i class='far fa-share-square'></i> GoIM </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Yusank`s Site"><img class="lazyload logo" src=/svg/loading.min.svg data-src=https://yusank.github.io/images/logo.svg data-srcset="https://yusank.github.io/images/logo.svg, https://yusank.github.io/images/logo.svg 1.5x, https://yusank.github.io/images/logo.svg 2x" data-sizes=auto alt=https://yusank.github.io/images/logo.svg title=https://yusank.github.io/images/logo.svg><span id=id-2 class=typeit></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/about/ title>关于</a><a class=menu-item href=/links/ title>友链</a><a class=menu-item href=https://github.com/yusank title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw'></i></a><a class=menu-item href=https://go-goim.github.io title=GoIM rel="noopener noreffer" target=_blank><i class='far fa-share-square'></i>GoIM</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">[系列]Redis Server 实现·有序集合篇</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/yusank title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Yusank</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/redis/><i class="far fa-folder fa-fw" aria-hidden=true></i>Redis</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2022-01-07>2022-01-07</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 6280 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 13 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-前言>1 前言</a></li><li><a href=#2-zset-支持的能力>2 zset 支持的能力</a></li><li><a href=#3-zset-底层原理>3 zset 底层原理</a><ul><li><a href=#31-压缩列表-ziplist>3.1 压缩列表-ziplist</a></li><li><a href=#32-跳跃表-skiplist>3.2 跳跃表-skiplist</a><ul><li><a href=#321-定义>3.2.1 定义</a></li><li><a href=#322-原理>3.2.2 原理</a></li><li><a href=#323-查询元素>3.2.3 查询元素</a></li><li><a href=#324-添加元素>3.2.4 添加元素</a></li><li><a href=#325-删除元素>3.2.5 删除元素</a></li><li><a href=#326-更新元素>3.2.6 更新元素</a></li></ul></li></ul></li><li><a href=#4-zset-实现>4 zset 实现</a><ul><li><a href=#41-数据结构定义>4.1 数据结构定义</a></li><li><a href=#42-初始化>4.2 初始化</a></li><li><a href=#43-其他功能>4.3 其他功能</a><ul><li><a href=#431-根据排名查找元素>4.3.1 根据排名查找元素</a></li><li><a href=#432-zrange-实现>4.3.2 zrange 实现</a></li></ul></li></ul></li><li><a href=#5-总结>5 总结</a></li><li><a href=#6-参考链接>6 参考链接🔗</a></li></ul></nav></div></div><div class=content id=content><blockquote><p>本篇讲述 <code>Redis</code> 中的基础数据结构 <code>ZSet</code>(<code>SortedSet</code>) 的底层实现原理和如何通过 go 语言实现一个 <code>ZSet</code> 的过程以及需要注意的问题。</p></blockquote><div class="details admonition quote open"><div class="details-summary admonition-title"><i class="icon fas fa-quote-right fa-fw" aria-hidden=true></i>说明<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>本文章为该系列的<code>有序集合</code>，如果需要阅读其他相关文章， 请点击<a href=https://yusank.github.io/posts/redeis-server-introduction/ target=_blank rel="noopener noreffer">这里</a>跳转查看</div></div></div><h2 id=1-前言>1 前言</h2><p>使用 Redis 过程中集合这个概念出现的比较频繁，常用的 <code>set</code>，<code>zset</code> 都是集合的概念。与普通的集合不同的是，<code>zset</code> 的元素之间是有顺序的，而且这个顺序不是插入的顺序而是使用者插入元素时指定的 score 而定的。</p><p><code>zset</code> 中的任何元素都是有score 值（浮点数）的，而且根据 score 的顺序进行读写甚至可以做到获取范围数据，这些特性给使用者带来了无数种可能性解决方案。</p><div class="details admonition tip open"><div class="details-summary admonition-title"><i class="icon fas fa-lightbulb fa-fw" aria-hidden=true></i>zset 的数据结构<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>从使用者的角度来说，zset 更像一个 kv 结构,元素不可以重复但是不同元素的 score 值是可以一样的，此时的排序是按元素字典排序。</p><p>通过 <code>ZRANGEBYSCORE</code> 命令可以列出指定score范围内的元素以及对应的 key，
其顺序为 score 的升序。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt; ZRANGEBYSCORE zset1 <span class=m>0</span> <span class=m>100</span> withscores
</span></span><span class=line><span class=cl>1<span class=o>)</span> <span class=s2>&#34;a&#34;</span>
</span></span><span class=line><span class=cl>2<span class=o>)</span> <span class=s2>&#34;5&#34;</span>
</span></span><span class=line><span class=cl>3<span class=o>)</span> <span class=s2>&#34;b&#34;</span>
</span></span><span class=line><span class=cl>4<span class=o>)</span> <span class=s2>&#34;5&#34;</span>
</span></span><span class=line><span class=cl>5<span class=o>)</span> <span class=s2>&#34;hello&#34;</span>
</span></span><span class=line><span class=cl>6<span class=o>)</span> <span class=s2>&#34;20&#34;</span>
</span></span></code></pre></td></tr></table></div></div></div></div></div><h2 id=2-zset-支持的能力>2 zset 支持的能力</h2><p><code>zset</code> 作为一个有序集合，即拥有普通集合的特性，同时又基于其有序特性衍生出更多别的特性。主要特性如下：</p><ul><li>元素不重复</li><li>集合之间交集并集差集的操作</li><li>批量读写元素</li><li>根据 score 操作（增删改查）元素</li><li>获取score最大最小的元素</li><li>根据集合内rank（或 index）操作（增删改查）元素</li></ul><h2 id=3-zset-底层原理>3 zset 底层原理</h2><div class="details admonition warning open"><div class="details-summary admonition-title"><i class="icon fas fa-exclamation-triangle fa-fw" aria-hidden=true></i>注意<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>本篇中所有引用的 Redis 源码均基于 <code>Redis6.2</code> 版本。</div></div></div><p>Redis 实现的 <code>zset</code> 底层是跳跃表和哈希表的组合。<code>跳跃表</code> 用于记录和操作所有基于 score 的操作，而<code>哈希表</code>存的是元素值和 score 的kv关系，用于快速定位元素存不存在的情况。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>zset</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>dict</span> <span class=o>*</span><span class=n>dict</span><span class=p>;</span> <span class=c1>// 哈希表，存储 元素-&gt;score
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>zskiplist</span> <span class=o>*</span><span class=n>zsl</span><span class=p>;</span> <span class=c1>// 跳跃表
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>zset</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>除了跳跃表和哈希表之外，其实还有一个不怎么出场的数据结构 &ndash; <code>ziplist</code>（压缩列表）。在满足以下两个条件的情况下，Redis 会使用 <code>ziplist</code>来替代跳跃表。</p><ol><li>保存的元素少于128个</li><li>保存的所有元素大小都小于64字节</li></ol><p>在了解跳跃表之前先了简单解一下 <code>ziplist</code> 这个数据结构的实现以及解答为什么要用 <code>ziplist</code> 来替代跳跃表。</p><h3 id=31-压缩列表-ziplist>3.1 压缩列表-ziplist</h3><p>ziplist 编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个节点保存元素的分值。并且压缩列表内的集合元素按分值从小到大的顺序进行排列。</p><p>从上述的两个条件可以看出，在数据量少且单个元素也比较小的情况下，使用 ziplist 是为了节省内存，因为在数据量少的情况下发挥不出来 skiplist 的优势且占的内存比 ziplist 大。</p><p>想更深入了解 ziplist 的实现细节，请<a href=https://redisbook.readthedocs.io/en/latest/compress-datastruct/ziplist.html target=_blank rel="noopener noreffer">点击</a>这里查看</p><div class="details admonition inf open"><div class="details-summary admonition-title"><i class="icon fas fa-pencil-alt fa-fw" aria-hidden=true></i>结构分布<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><ul><li>ziplist 结构分布</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl>area        |<span class=p>&lt;</span><span class=nt>----</span> <span class=na>ziplist</span> <span class=na>header</span> <span class=na>----</span><span class=p>&gt;</span>|<span class=p>&lt;</span><span class=nt>-----------</span> <span class=na>entries</span> <span class=na>-------------</span><span class=p>&gt;</span>|<span class=p>&lt;</span><span class=nt>-end-</span><span class=p>&gt;</span>|
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>size          4 bytes  4 bytes  2 bytes    ?        ?        ?        ?     1 byte
</span></span><span class=line><span class=cl>            +---------+--------+-------+--------+--------+--------+--------+-------+
</span></span><span class=line><span class=cl>component   | zlbytes | zltail | zllen | entry1 | entry2 |  ...   | entryN | zlend |
</span></span><span class=line><span class=cl>            +---------+--------+-------+--------+--------+--------+--------+-------+
</span></span><span class=line><span class=cl>                                       ^                          ^        ^
</span></span><span class=line><span class=cl>address                                |                          |        |
</span></span><span class=line><span class=cl>                                ZIPLIST_ENTRY_HEAD                |   ZIPLIST_ENTRY_END
</span></span><span class=line><span class=cl>                                                                  |
</span></span><span class=line><span class=cl>                                                         ZIPLIST_ENTRY_TAIL
</span></span></code></pre></td></tr></table></div></div><ul><li>ziplist 节点结构分布</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl>area        |<span class=p>&lt;</span><span class=nt>-------------------</span> <span class=na>entry</span> <span class=na>--------------------</span><span class=p>&gt;</span>|
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            +------------------+----------+--------+---------+
</span></span><span class=line><span class=cl>component   | pre_entry_length | encoding | length | content |
</span></span><span class=line><span class=cl>            +------------------+----------+--------+---------+
</span></span></code></pre></td></tr></table></div></div></div></div></div><h3 id=32-跳跃表-skiplist>3.2 跳跃表-skiplist</h3><h4 id=321-定义>3.2.1 定义</h4><p>跳跃表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳跃表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳跃表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。</p><p>它采用随机技术决定链表中哪些节点应增加向前指针以及在该节点中应增加多少个指针。跳跃表结构的头节点需有足够的指针域，以满足可能构造最大级数的需要，而尾节点不需要指针域。</p><p>采用这种随机技术，跳跃表中的搜索、插入、删除操作的时间均为<code>O(logn)</code>，然而，最坏情况下时间复杂性却变成<code>O(n)</code>。相比之下，在一个有序数组或链表中进行插入/删除操作的时间为<code>O(n)</code>，最坏情况下为<code>O(n)</code>。</p><h4 id=322-原理>3.2.2 原理</h4><p>跳跃表原理非常简单，在链表的基础上每个元素加上一个层(level)的概念，层高则是随机的, 所以每个元素的高度不一样。每一层都会指向下一个同一层的元素，查询元素时由高层向后向下的方式二级检索从而达到更高的查询效率，下面用图解的方式解析如何读写跳跃表元素的。在看图之前可以先看一下源码，尝试理解一下。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 跳跃表结构
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=n>zskiplist</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>zskiplistNode</span> <span class=o>*</span><span class=n>header</span><span class=p>,</span> <span class=o>*</span><span class=n>tail</span><span class=p>;</span> <span class=c1>// 记录 head 和 tail 两个节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>length</span><span class=p>;</span> <span class=c1>// 记录长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>level</span><span class=p>;</span> <span class=c1>// 记录当前最高 level，如果有新元素插入且其 level 大于当前最高则更新该值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>zskiplist</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 跳跃表节点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=n>zskiplistNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sds</span> <span class=n>ele</span><span class=p>;</span> <span class=c1>// 元素值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>double</span> <span class=n>score</span><span class=p>;</span> <span class=c1>// score
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>zskiplistNode</span> <span class=o>*</span><span class=n>backward</span><span class=p>;</span> <span class=c1>// 向前指向指针，用于往回跳
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>zskiplistLevel</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>zskiplistNode</span> <span class=o>*</span><span class=n>forward</span><span class=p>;</span> <span class=c1>// 每一层都指向下一个同高度元素
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>span</span><span class=p>;</span> <span class=c1>// 到下一个同高度元素的跨度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=n>level</span><span class=p>[];</span> <span class=c1>// 该元素的 level 数组，index 从 0 到 N 表示从最低到最高，默认最高支持 32 层
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>zskiplistNode</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>如果看完源码还是没有看到 ，请看下图：</p><figure><a class=lightgallery href=https://redisbook.readthedocs.io/en/latest/_images/skiplist.png title=https://redisbook.readthedocs.io/en/latest/_images/skiplist.png data-thumbnail=https://redisbook.readthedocs.io/en/latest/_images/skiplist.png data-sub-html="<h2>跳跃表结构</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=https://redisbook.readthedocs.io/en/latest/_images/skiplist.png data-srcset="https://redisbook.readthedocs.io/en/latest/_images/skiplist.png, https://redisbook.readthedocs.io/en/latest/_images/skiplist.png 1.5x, https://redisbook.readthedocs.io/en/latest/_images/skiplist.png 2x" data-sizes=auto alt=https://redisbook.readthedocs.io/en/latest/_images/skiplist.png width=800></a><figcaption class=image-caption>跳跃表结构</figcaption></figure><p>从图中可以看到， 跳跃表主要由以下部分构成：</p><ul><li>表头（head）：负责维护跳跃表的节点指针。</li><li>跳跃表节点：保存着元素值，以及多个层。</li><li>层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。</li><li>表尾：全部由 NULL 组成，表示跳跃表的末尾。</li></ul><div class="details admonition warning open"><div class="details-summary admonition-title"><i class="icon fas fa-exclamation-triangle fa-fw" aria-hidden=true></i>注意<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>图中没有表示出来 <code>zskiplistNode.backward</code> 指针的指向，实际上图中每个元素都会指向前一个元素</div></div></div><h4 id=323-查询元素>3.2.3 查询元素</h4><p>在跳跃表查询元素，总是从 head 的顶层 level 向后向下的方式取查询，以上面的示例图为例，下面讲解如何查询 score 值为 <code>7</code> 的元素:</p><p>初始条件：</p><ul><li>p 为初始指针，指向 head 的顶层 level</li></ul><p>查询步骤：</p><ol><li><p>判断指针 p 的 forward 元素的值 当满足条件：forward.score <code>&lt;</code> score <code>或</code> forward.score == score <code>&&</code> forward.ele <code>&lt;</code> targetEle 时，p 向前移动，level 不变</p></li><li><p>当 p 的 forward 为 null 或者forward 元素的值大于 score 时，level 减一，但是 p 不往前移动</p></li><li><p>步骤 1，2 一直循环，指到 p 移动到 null 或者移动到目标元素为止。</p></li></ol><figure><a class=lightgallery href=/posts/redis-server-zset/skiplist_find.png title=/posts/redis-server-zset/skiplist_find.png data-thumbnail=/posts/redis-server-zset/skiplist_find.png data-sub-html="<h2>跳跃表查询元素过程</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/posts/redis-server-zset/skiplist_find.png data-srcset="/posts/redis-server-zset/skiplist_find.png, /posts/redis-server-zset/skiplist_find.png 1.5x, /posts/redis-server-zset/skiplist_find.png 2x" data-sizes=auto alt=/posts/redis-server-zset/skiplist_find.png width=800 height=234></a><figcaption class=image-caption>跳跃表查询元素过程</figcaption></figure><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=cm>/* 下面就是非常常规的一个遍历查找过程 */</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=n>zsl</span><span class=o>-&gt;</span><span class=n>header</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 从head 顶层level开始向下遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=n>zsl</span><span class=o>-&gt;</span><span class=n>level</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 每一层判断forward元素不为空的时候是否与目标score和ele
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>while</span> <span class=p>(</span><span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span><span class=o>-&gt;</span><span class=n>score</span> <span class=o>&lt;</span> <span class=n>curscore</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span><span class=o>-&gt;</span><span class=n>score</span> <span class=o>==</span> <span class=n>curscore</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// 这里的 sdccmp 是Redis内实现的对其 String 结构的字符串进行对比(即字典排序的对比)
</span></span></span><span class=line><span class=cl><span class=c1></span>                     <span class=n>sdscmp</span><span class=p>(</span><span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span><span class=o>-&gt;</span><span class=n>ele</span><span class=p>,</span><span class=n>ele</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>x</span> <span class=o>=</span> <span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>然后再真正实现 <code>zset</code> 的时候，不会根据 value 值去遍历查询跳跃表, 而是直接从哈希表查是否存在</p></blockquote><h4 id=324-添加元素>3.2.4 添加元素</h4><p>添加元素核心有以下几点：</p><ul><li>找到需要插入的位置，这块用上上一个小节的查询元素相关知识</li><li>在查找位置的过程中需要记录牵连到需要更新的元素</li><li>如何得到新元素的层高，真的是 <code>[0,32)</code> 之间随机一个数嘛？</li><li>如果新元素的层高大于当前 skiplist 的高度，需要做哪些调整工作？</li></ul><p>对以上几点有了明确的认知和回答后，了解插入元素的过程就变得很简单。</p><p>添加元素过程：</p><ol start=0><li><p>定义一个 <code>zskiplistNode *update[ZSKIPLIST_MAXLEVEL]</code> 数组记录每次变更 level 时的节点（后期更新受影响的节点用）</p></li><li><p>定义 <code>unsigned int rank[ZSKIPLIST_MAXLEVEL]</code> 数组记录两次向下遍历的节点直接的跨度</p></li><li><p>与查询元素一样，从 head 的顶层开始向下向前遍历，找到插入的位置，这个位置满足 score 值介于前后的元素</p></li><li><p>在遍历的过程中，每往下移动一次(level - 1 )的时候记录当前元素update[cur_level] = cur_node</p></li><li><p>在遍历的过程中，每往前移动一次(注：每次移动只会单向 不会同时向前向下)的前记录同一个 level 内的跨度
rank[cur_level] += cur_node.level[cur_level].span (这里之所以累加是因为，同一个 level 上可能会向前移动 n 次，如上面示例图中的从 1 到 6 的过程都是在同一个 level 上进行的)</p></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=c1>// 定义变量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>zskiplistNode</span> <span class=o>*</span><span class=n>update</span><span class=p>[</span><span class=n>ZSKIPLIST_MAXLEVEL</span><span class=p>],</span> <span class=o>*</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>rank</span><span class=p>[</span><span class=n>ZSKIPLIST_MAXLEVEL</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>level</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 从 header 开始遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>x</span> <span class=o>=</span> <span class=n>zsl</span><span class=o>-&gt;</span><span class=n>header</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 初始位置 header 的顶层 level
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=n>zsl</span><span class=o>-&gt;</span><span class=n>level</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* store rank that is crossed to reach the insert position */</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 如果当前level 为最高一层的 level 则 rank 记录 0
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>rank</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span> <span class=o>==</span> <span class=p>(</span><span class=n>zsl</span><span class=o>-&gt;</span><span class=n>level</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=n>rank</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span><span class=o>-&gt;</span><span class=n>score</span> <span class=o>&lt;</span> <span class=n>score</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span><span class=o>-&gt;</span><span class=n>score</span> <span class=o>==</span> <span class=n>score</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                    <span class=n>sdscmp</span><span class=p>(</span><span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span><span class=o>-&gt;</span><span class=n>ele</span><span class=p>,</span><span class=n>ele</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 向前移动时记录当前 level 移动的跨度
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>rank</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+=</span> <span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>span</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>x</span> <span class=o>=</span> <span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// level - 1  时 记录当前元素
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>update</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ol start=5><li><p>随机一个 level， Redis 是有一套简单的算法去生成随机的 level <a href=#3241-%e9%9a%8f%e6%9c%ba-level-%e7%ae%97%e6%b3%95 rel>跳转查看</a>。</p></li><li><p>如果随机的 level 大于 skiplist 当前最高 level，则在 update 数组记录从当前最高到新的最高之间的level 对应的节点为 head 节点</p></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=cm>/* we assume the element is not already inside, since we allow duplicated
</span></span></span><span class=line><span class=cl><span class=cm>     * scores, reinserting the same element should never happen since the
</span></span></span><span class=line><span class=cl><span class=cm>     * caller of zslInsert() should test in the hash table if the element is
</span></span></span><span class=line><span class=cl><span class=cm>     * already inside or not. */</span>
</span></span><span class=line><span class=cl>    <span class=n>level</span> <span class=o>=</span> <span class=n>zslRandomLevel</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>level</span> <span class=o>&gt;</span> <span class=n>zsl</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 在 zsl-&gt;level 到 level 之间区域补缺原来的空缺
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 原来高于 zsl-&gt;level 的 level 均指向 null，现在需要指向到新的元素对应的 level 了
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=n>zsl</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>level</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>rank</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// 因为最高的 level 了所以在该层不会指向下一个元素 所以对应的 rank == 0
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>update</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>zsl</span><span class=o>-&gt;</span><span class=n>header</span><span class=p>;</span> <span class=c1>// header 需要更新
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>update</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>span</span> <span class=o>=</span> <span class=n>zsl</span><span class=o>-&gt;</span><span class=n>length</span><span class=p>;</span>  <span class=c1>// 不再指向 null 所以 span 也需要更新，这里先赋值为最远距离 下面会统一处理
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 更新新的 level
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>zsl</span><span class=o>-&gt;</span><span class=n>level</span> <span class=o>=</span> <span class=n>level</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ol start=7><li>插入新的元素，更新原则的前后指向指针</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=c1>// 初始化新的节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>x</span> <span class=o>=</span> <span class=n>zslCreateNode</span><span class=p>(</span><span class=n>level</span><span class=p>,</span><span class=n>score</span><span class=p>,</span><span class=n>ele</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 从下到上 一层层更新完善前后节点以及相关节点的关系
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>level</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// update 数组一个元素记录的是 每一层最靠近（从header 到 x）x 的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 所以每一层最靠近 x 的元素的 forward 由原来的指向改为 x
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 同样的 x 每一层的 forward 都指向原来每一层的指向的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 好比一个单向链表 a -&gt; c, 插入一个 b 在中间，从 `a.next = c` 变为 `a.next, b.next = b, a.next`
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span> <span class=o>=</span> <span class=n>update</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>update</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* update span covered by update[i] as x is inserted here */</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 这里可能比较绕
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// span 为当前位置到下一个元素之间的距离，因为不同 level 的存在，每一层的 span 都不一定相同
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// rank[0] 为从 header 到当前新元素置位的总的距离
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// x 某一层的 span 为前一个同一层的元素的 span 减去  x 与前一个同一层的距离
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>span</span> <span class=o>=</span> <span class=n>update</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>span</span> <span class=o>-</span> <span class=p>(</span><span class=n>rank</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=n>rank</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 前一个同一层的元素的新的 span = 从header 到新元素的距离减去从 header 到该元素的距离 + 1 （加一是因为新增元素了）
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>update</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>span</span> <span class=o>=</span> <span class=p>(</span><span class=n>rank</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=n>rank</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ol start=8><li>如果新元素的高度没有比 skiplist 最高 level 高，则在新元素之前的比它更高元素的 level 的跨度加一</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* increment span for untouched levels */</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=n>level</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>zsl</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>update</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>span</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ol start=9><li><p>修改新元素的下一个元素（如果存在下一个元素）的 backward 指针，指向新元素</p></li><li><p>跳跃表长度+1 完成新增元素</p></li></ol><p>配合动图看源码：</p><figure><a class=lightgallery href=/posts/redis-server-zset/skiplist_insert.gif title=/posts/redis-server-zset/skiplist_insert.gif data-thumbnail=/posts/redis-server-zset/skiplist_insert.gif data-sub-html="<h2>跳跃表插入元素过程</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/posts/redis-server-zset/skiplist_insert.gif data-srcset="/posts/redis-server-zset/skiplist_insert.gif, /posts/redis-server-zset/skiplist_insert.gif 1.5x, /posts/redis-server-zset/skiplist_insert.gif 2x" data-sizes=auto alt=/posts/redis-server-zset/skiplist_insert.gif width=800 height=332></a><figcaption class=image-caption>跳跃表插入元素过程</figcaption></figure><h5 id=3241-随机-level-算法>3.2.4.1 随机 level 算法</h5><p>跳跃表作为一个随机化的数据结构，每一个元素都是有不一样高的 level，查询时通过跳跃 N 个元素的方式提高性能。只要确保不同元素直接的 level 是有一定的差别才能体现出跳跃表的性能，否则很容易退化成链表结构了。</p><p>每个 level 的元素数从上到下呈现第 L 层的元素数为 L-1的1/p（其中Redis 中这个 p = 4）。那么SkipList可以看成是一棵平衡的P叉树，从最顶层开始查找某个节点需要的时间是O(logpN)。每个跳跃表节点中的指针数组中的每一层，都指向随后一个指针数组大小大于等于该节点指针数据大小的节点。</p><p>那么问题来了，如何确保每次随机时，越高层出现概率越低 越底层出现的概率越高呢？</p><p>先给出 Redis 源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Returns a random level for the new skiplist node we are going to create.
</span></span></span><span class=line><span class=cl><span class=cm> * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL
</span></span></span><span class=line><span class=cl><span class=cm> * (both inclusive), with a powerlaw-alike distribution where higher
</span></span></span><span class=line><span class=cl><span class=cm> * levels are less likely to be returned. */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>zslRandomLevel</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>level</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>((</span><span class=n>random</span><span class=p>()</span><span class=o>&amp;</span><span class=mh>0xFFFF</span><span class=p>)</span> <span class=o>&lt;</span> <span class=p>(</span><span class=mf>0.25</span> <span class=o>*</span> <span class=mh>0xFFFF</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>level</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>level</span><span class=o>&lt;</span><span class=mi>32</span><span class=p>)</span> <span class=o>?</span> <span class=nl>level</span> <span class=p>:</span> <span class=mi>32</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class="details admonition abstract open"><div class="details-summary admonition-title"><i class="icon fas fa-list-ul fa-fw" aria-hidden=true></i>解释一下这里的算法<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p><code>任意一个数</code> & <code>0xFFFF</code> 得到的结果在 [0~0xFFFF] 范围内, 结果小于 <code>0.25 * 0xFFFF</code> 的概率就是 1/4 .</p><p>根据概率论可以得出越高的 level 出现（即连续多次出现小于 0.25 * 0xFFFF 才能累加到高 level）的概率越低.
数据如下：</p><table><thead><tr><th style=text-align:center>level</th><th style=text-align:center>概率</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>3/4</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>3/4 * 1/4</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>3/4 * 1/4 * 1/4</td></tr><tr><td style=text-align:center>4</td><td style=text-align:center>3/4 * 1/4 * 1/4 * 1/4</td></tr><tr><td style=text-align:center>&mldr;</td><td style=text-align:center>&mldr;</td></tr><tr><td style=text-align:center>n</td><td style=text-align:center>$3/4 * (1/4)^{n-1}$</td></tr></tbody></table></div></div></div><h4 id=325-删除元素>3.2.5 删除元素</h4><p>删除元素相对新增元素来说简单一些，但是整体思路还是一样的。遍历找到删除的元素，在遍历过程中记录删除后需要更新属性的元素以及 level。</p><ol><li>遍历并找到需要删除的位置</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>zsl</span><span class=o>-&gt;</span><span class=n>header</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=n>zsl</span><span class=o>-&gt;</span><span class=n>level</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span><span class=o>-&gt;</span><span class=n>score</span> <span class=o>&lt;</span> <span class=n>score</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span><span class=o>-&gt;</span><span class=n>score</span> <span class=o>==</span> <span class=n>score</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                    <span class=n>sdscmp</span><span class=p>(</span><span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span><span class=o>-&gt;</span><span class=n>ele</span><span class=p>,</span><span class=n>ele</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span> <span class=o>=</span> <span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 记录每一层需要更新的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>update</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/* We may have multiple elements with the same score, what we need
</span></span></span><span class=line><span class=cl><span class=cm>* is to find the element with both the right score and object. */</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>forward</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 确定元素 删除
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>&amp;&amp;</span> <span class=n>score</span> <span class=o>==</span> <span class=n>x</span><span class=o>-&gt;</span><span class=n>score</span> <span class=o>&amp;&amp;</span> <span class=n>sdscmp</span><span class=p>(</span><span class=n>x</span><span class=o>-&gt;</span><span class=n>ele</span><span class=p>,</span><span class=n>ele</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 删除方法，需要传入 update 数组 方便 删除完更新涉及到的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>zslDeleteNode</span><span class=p>(</span><span class=n>zsl</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>update</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ol start=2><li>更新被删元素前的每一层的 span</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>zsl</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果当前 level 指向 x，则新的 span 是自己当前 span 加上 x 的 span -1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>update</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span> <span class=o>==</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>update</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>span</span> <span class=o>+=</span> <span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>span</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 同时修改 forward 指针的指向
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>update</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span> <span class=o>=</span> <span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>forward</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 如果不指向 x 则 span -1 即可
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>update</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>span</span> <span class=o>-=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ol start=3><li>修改被删除元素的前的元素的向后指针</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>forward</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>forward</span><span class=o>-&gt;</span><span class=n>backward</span> <span class=o>=</span> <span class=n>x</span><span class=o>-&gt;</span><span class=n>backward</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>zsl</span><span class=o>-&gt;</span><span class=n>tail</span> <span class=o>=</span> <span class=n>x</span><span class=o>-&gt;</span><span class=n>backward</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ol start=4><li><p>判断被删除元素是不是最高 level，如果是 level 减到第二高元素高度为止</p></li><li><p>skiplist 长度减一，删除完成。</p></li></ol><h4 id=326-更新元素>3.2.6 更新元素</h4><p>之所以更新元素放到最后，是因为更新元素没有单独的逻辑，完全依赖上面的知识点。</p><ol><li><p>找到元素</p></li><li><p>删除元素</p></li><li><p>插入元素</p></li></ol><p>这就是 Redis 内实现的逻辑，简单易懂。虽然感觉哪里不对，但是好像又没什么毛病。</p><h2 id=4-zset-实现>4 zset 实现</h2><p>上面关于<code>zset</code>的原理和实现都理解的比较透彻了，如果还有不明白的建议看源码，结合源码上下文更好理解。现在我用 go 语言实现跳跃表。关于压缩表我在这里不会涉及到只实现跳跃表相关代码。</p><h3 id=41-数据结构定义>4.1 数据结构定义</h3><p>数据结构定义基本与 Redis 一致，跳跃表 + map 的组合。其中 map 部分为了提高读写性能，自己实现了一个 map 结构。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// zSet is object contain skip list and map which store key-value pair
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>zSet</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// smap.Map 为自己实现的原生 map 的封装，之后单独讲一下，之所以自己实现是为了提高性能
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>m</span> <span class=nx>smap</span><span class=p>.</span><span class=nx>Map</span> <span class=c1>// store key and value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 在元素少于 100 &amp; 每个元素大小小于 64 的时候,Redis 实际上用的是 zipList 这里作为知识点提了一下
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 除非遇到性能问题,否则不准备同时支持 zipList 和 skipList
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>zsl</span> <span class=o>*</span><span class=nx>zSkipList</span> <span class=c1>// skip list
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>zSkipList</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>head</span><span class=p>,</span> <span class=nx>tail</span> <span class=o>*</span><span class=nx>zSkipListNode</span>
</span></span><span class=line><span class=cl>    <span class=nx>length</span>     <span class=kt>int</span> <span class=c1>// 总长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>level</span>      <span class=kt>int</span> <span class=c1>// 最大高度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>zSkipListNode</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>value</span>    <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>score</span>    <span class=kt>float64</span>
</span></span><span class=line><span class=cl>    <span class=nx>backward</span> <span class=o>*</span><span class=nx>zSkipListNode</span>
</span></span><span class=line><span class=cl>    <span class=nx>levels</span>   <span class=p>[]</span><span class=o>*</span><span class=nx>zSkipListLeve</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>zSkipListLeve</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>forward</span> <span class=o>*</span><span class=nx>zSkipListNode</span>
</span></span><span class=line><span class=cl>    <span class=nx>span</span>    <span class=kt>uint</span> <span class=c1>// 当前 level 到下一个节点的跨度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=42-初始化>4.2 初始化</h3><p>因为存在一个 header 的虚拟节点，所以初始化的时候需要把跳跃表的 header 以及其每一层都初始化。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// new skiplist
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>newZSkipList</span><span class=p>()</span> <span class=o>*</span><span class=nx>zSkipList</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>zsl</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>zSkipList</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>level</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 每一层为空的 ZSkipListMaxLevel 层的 head
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>head</span><span class=p>:</span>  <span class=nf>newZslNode</span><span class=p>(</span><span class=nx>ZSkipListMaxLevel</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>zsl</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// new node
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>newZslNode</span><span class=p>(</span><span class=nx>level</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>score</span> <span class=kt>float64</span><span class=p>,</span> <span class=nx>value</span> <span class=kt>string</span><span class=p>)</span> <span class=o>*</span><span class=nx>zSkipListNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>node</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>zSkipListNode</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>value</span><span class=p>:</span>  <span class=nx>value</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>score</span><span class=p>:</span>  <span class=nx>score</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>levels</span><span class=p>:</span> <span class=nb>make</span><span class=p>([]</span><span class=o>*</span><span class=nx>zSkipListLeve</span><span class=p>,</span> <span class=nx>level</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 初始化每一层
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>level</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>node</span><span class=p>.</span><span class=nx>levels</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>zSkipListLeve</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>node</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=43-其他功能>4.3 其他功能</h3><p>增删改查的代码与上面源码解析的逻辑大致相同，我在这里给出go 语言实现的源码，可以<a href=https://github.com/yusank/godis/blob/master/datastruct/sorted_set.go target=_blank rel="noopener noreffer">点击查看</a>。在这里不再讲述这些基础功能的实现，
而是给出一些特殊的方法的实现。</p><h4 id=431-根据排名查找元素>4.3.1 根据排名查找元素</h4><p>在上面的实现里会看到到处飞的 span 这个属性，但是好像一直没有实际用上，其实在遍历过程中尤其是跟排名相关的操作里这个 span 属性是非常的有用，下面看一下实际用处：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>zsl</span> <span class=o>*</span><span class=nx>zSkipList</span><span class=p>)</span> <span class=nf>findElementByRank</span><span class=p>(</span><span class=nx>rank</span> <span class=kt>uint</span><span class=p>)</span> <span class=o>*</span><span class=nx>zSkipListNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=nx>x</span>         <span class=p>=</span> <span class=nx>zsl</span><span class=p>.</span><span class=nx>head</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 已遍历的距离
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>traversed</span> <span class=kt>uint</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 从 head 的顶层开始遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>zsl</span><span class=p>.</span><span class=nx>level</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=o>--</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 如果当前level 的下一个元素的距离 + 已经走过的距离 小于 目标排名 -&gt; 向前移动
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 否则 level - 1
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=nx>x</span><span class=p>.</span><span class=nx>levels</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>forward</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>traversed</span><span class=o>+</span><span class=nx>x</span><span class=p>.</span><span class=nx>levels</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>span</span> <span class=o>&lt;=</span> <span class=nx>rank</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>traversed</span> <span class=o>+=</span> <span class=nx>x</span><span class=p>.</span><span class=nx>levels</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>span</span>
</span></span><span class=line><span class=cl>            <span class=nx>x</span> <span class=p>=</span> <span class=nx>x</span><span class=p>.</span><span class=nx>levels</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>forward</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// level -1 前判断是否达到目标 rank
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>traversed</span> <span class=o>==</span> <span class=nx>rank</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>因为记录了与下一个元素的距离，根据排名找元素变得很简单高效，只要跳跃对应的距离即可（距离代表的就是跨越多少个元素也就是多少个排名位置）</p><h4 id=432-zrange-实现>4.3.2 zrange 实现</h4><p><code>zrange</code> 这个命令是使用 <code>zset</code> 时最常用的命令之一, 那底层是怎么实现的呢？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// start stop 支持负数 负数时表示倒数第几个
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>zsl</span> <span class=o>*</span><span class=nx>zSkipList</span><span class=p>)</span> <span class=nf>zRange</span><span class=p>(</span><span class=nx>start</span><span class=p>,</span> <span class=nx>stop</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>withScores</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>[]</span><span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>start</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>start</span> <span class=p>=</span> <span class=nx>start</span> <span class=o>+</span> <span class=nx>zsl</span><span class=p>.</span><span class=nx>length</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>start</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>start</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>stop</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>stop</span> <span class=p>=</span> <span class=nx>stop</span> <span class=o>+</span> <span class=nx>zsl</span><span class=p>.</span><span class=nx>length</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>start</span> <span class=p>&gt;</span> <span class=nx>stop</span> <span class=o>||</span> <span class=nx>start</span> <span class=o>&gt;=</span> <span class=nx>zsl</span><span class=p>.</span><span class=nx>length</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>stop</span> <span class=o>&gt;=</span> <span class=nx>zsl</span><span class=p>.</span><span class=nx>length</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>stop</span> <span class=p>=</span> <span class=nx>zsl</span><span class=p>.</span><span class=nx>length</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 到目前为止是为了处理 start 和 stop 越界问题，并把负数换算成正数 方便下面处理
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 先用上面的方法找到遍历的第一个元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>node</span> <span class=o>:=</span> <span class=nx>zsl</span><span class=p>.</span><span class=nf>findElementByRank</span><span class=p>(</span><span class=nb>uint</span><span class=p>(</span><span class=nx>start</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=nx>rangeLen</span> <span class=p>=</span> <span class=nx>stop</span> <span class=o>-</span> <span class=nx>start</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=nx>result</span>   <span class=p>[]</span><span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 从 start 元素开始遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>rangeLen</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>node</span><span class=p>.</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>withScores</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>FormatFloat</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>score</span><span class=p>,</span> <span class=sc>&#39;g&#39;</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>64</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 跳跃表的第 0 层可以看做做是一个链表，这样遍历读取多个元素就很方便了
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>node</span> <span class=p>=</span> <span class=nx>node</span><span class=p>.</span><span class=nx>levels</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=nx>forward</span>
</span></span><span class=line><span class=cl>        <span class=nx>rangeLen</span><span class=o>--</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>result</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class="details admonition question open"><div class="details-summary admonition-title"><i class="icon fas fa-question-circle fa-fw" aria-hidden=true></i>如何逆向遍历<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>如果需要逆向遍历 直接把 <code>node = node.levels[0].forward</code> 改成 <code>node = node.levels[0].backward</code> 即可。</div></div></div><h2 id=5-总结>5 总结</h2><p>写到这里，Redis 如何实现 zset 的原理和源码以及如何用 go 语言自己写一遍都讲完了，下面做个简单的总结。</p><ul><li>zset 底层是两种数据结构组成（ziplist， skiplist + dict），根据存储的数据量不同从决定使用哪个</li><li>跳跃表是一个树状结构，读写时间复杂度 O(logN)</li><li>跳跃表的level 是随机算法算出来的，确保每一层是上一次的 P 倍，level 越低数据分布越密集</li><li>如果对 Redis 的源码或者跳跃表比较熟悉的话，go 语言的实现基本没有任何难度，是把理解转换成代码过程</li><li>实现过程需要注意的是一些特殊情况，包括边界问题，head 和 tail 的问题以及操作某个元素其牵连到的附近的元素</li></ul><h2 id=6-参考链接>6 参考链接🔗</h2><ul><li><a href=https://redisbook.readthedocs.io/en/latest/compress-datastruct/ziplist.html target=_blank rel="noopener noreffer">压缩列表-ziplist</a></li><li><a href=https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html target=_blank rel="noopener noreffer">跳跃表-skiplist</a></li><li><a href=https://github.com/yusank/godis target=_blank rel="noopener noreffer">go 语言实现 Redis</a></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-01-07</span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/posts/redis-server-zset/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://yusank.github.io/posts/redis-server-zset/ data-title="[系列]Redis Server 实现·有序集合篇" data-hashtags=redis,系列篇,数据结构><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://yusank.github.io/posts/redis-server-zset/ data-hashtag=redis><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://yusank.github.io/posts/redis-server-zset/><i class="fab fa-linkedin fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 WhatsApp" data-sharer=whatsapp data-url=https://yusank.github.io/posts/redis-server-zset/ data-title="[系列]Redis Server 实现·有序集合篇" data-web><i class="fab fa-whatsapp fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://yusank.github.io/posts/redis-server-zset/ data-title="[系列]Redis Server 实现·有序集合篇"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Reddit" data-sharer=reddit data-url=https://yusank.github.io/posts/redis-server-zset/><i class="fab fa-reddit fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://yusank.github.io/posts/redis-server-zset/ data-title="[系列]Redis Server 实现·有序集合篇"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.0.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://yusank.github.io/posts/redis-server-zset/ data-title="[系列]Redis Server 实现·有序集合篇" data-ralateuid=yusann><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Blogger" data-sharer=blogger data-url=https://yusank.github.io/posts/redis-server-zset/ data-title="[系列]Redis Server 实现·有序集合篇" data-description><i class="fab fa-blogger fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://yusank.github.io/posts/redis-server-zset/ data-title="[系列]Redis Server 实现·有序集合篇"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.0.0/icons/baidu.svg aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Evernote" data-sharer=evernote data-url=https://yusank.github.io/posts/redis-server-zset/ data-title="[系列]Redis Server 实现·有序集合篇"><i class="fab fa-evernote fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/redis/>redis</a>,&nbsp;<a href=/tags/%E7%B3%BB%E5%88%97%E7%AF%87/>系列篇</a>,&nbsp;<a href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/redeis-server-list/ class=prev rel=prev title="[系列]Redis Server 实现·链表篇"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>[系列]Redis Server 实现·链表篇</a>
<a href=/posts/shard-map/ class=next rel=next title="go 语言中的分片 map 的实现">go 语言中的分片 map 的实现<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=utterances class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Keep learning and stay with lights.<br>❤ yusank<br></div><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.101.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2017 - 2022</span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by/4.0/deed.zh target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/typeit@8.6.0/dist/index.umd.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{utterances:{darkTheme:"github-dark",issueTerm:"pathname",label:"Comment",lightTheme:"github-light",repo:"yusank/yusank.github.io"}},data:{"id-1":"usank`s Site","id-2":"usank`s Site"},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"},typeit:{cursorChar:"|",cursorSpeed:1e3,data:{"id-1":["id-1"],"id-2":["id-2"]},duration:-1,speed:70}}</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-24P8ZSJHCQ",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-24P8ZSJHCQ" async></script></body></html>