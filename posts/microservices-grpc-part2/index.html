<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>[系列]微服务·深入了解gRPC Part2 - Yusank`s Site</title><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7859878302610774" crossorigin=anonymous></script><meta name=Description content="这是我的个人博客，我会在这里分享学习和成长过程中的积累和经验."><meta property="og:title" content="[系列]微服务·深入了解gRPC Part2"><meta property="og:description" content="
本文为系列篇微服务的关于 深入 gRPC 的文章。本篇将会从 gRPC 的基本概念、gRPC 的使用、gRPC 的编程模型、gRPC 的编程模型的实现、gRPC 的编程模型的实现的细节等多个角度来了解。
本篇为 深入了解gRPC 的下篇，篇幅原因，将这篇文章拆分成上下篇，点击这里查看上篇
"><meta property="og:type" content="article"><meta property="og:url" content="https://yusank.github.io/posts/microservices-grpc-part2/"><meta property="og:image" content="https://yusank.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-07T10:10:00+08:00"><meta property="article:modified_time" content="2022-07-07T17:19:50+08:00"><meta property="og:site_name" content="My cool site"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yusank.github.io/logo.png"><meta name=twitter:title content="[系列]微服务·深入了解gRPC Part2"><meta name=twitter:description content="
本文为系列篇微服务的关于 深入 gRPC 的文章。本篇将会从 gRPC 的基本概念、gRPC 的使用、gRPC 的编程模型、gRPC 的编程模型的实现、gRPC 的编程模型的实现的细节等多个角度来了解。
本篇为 深入了解gRPC 的下篇，篇幅原因，将这篇文章拆分成上下篇，点击这里查看上篇
"><meta name=application-name content="Yusank's Site"><meta name=apple-mobile-web-app-title content="Yusank's Site"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://yusank.github.io/posts/microservices-grpc-part2/><link rel=prev href=https://yusank.github.io/posts/microservices-grpc-part1/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"[系列]微服务·深入了解gRPC Part2","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/yusank.github.io\/posts\/microservices-grpc-part2\/"},"genre":"posts","keywords":"微服务, 系列篇, grpc","wordcount":5577,"url":"https:\/\/yusank.github.io\/posts\/microservices-grpc-part2\/","datePublished":"2022-07-07T10:10:00+08:00","dateModified":"2022-07-07T17:19:50+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Yusank"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Yusank`s Site"><img class="lazyload logo" src=/svg/loading.min.svg data-src=https://yusank.github.io/images/logo.svg data-srcset="https://yusank.github.io/images/logo.svg, https://yusank.github.io/images/logo.svg 1.5x, https://yusank.github.io/images/logo.svg 2x" data-sizes=auto alt=https://yusank.github.io/images/logo.svg title=https://yusank.github.io/images/logo.svg><span id=id-1 class=typeit></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/about/>关于 </a><a class=menu-item href=/links/>友链 </a><a class=menu-item href=https://github.com/yusank title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw'></i> </a><a class=menu-item href=https://go-goim.github.io title=GoIM rel="noopener noreffer" target=_blank><i class='far fa-share-square'></i> GoIM </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Yusank`s Site"><img class="lazyload logo" src=/svg/loading.min.svg data-src=https://yusank.github.io/images/logo.svg data-srcset="https://yusank.github.io/images/logo.svg, https://yusank.github.io/images/logo.svg 1.5x, https://yusank.github.io/images/logo.svg 2x" data-sizes=auto alt=https://yusank.github.io/images/logo.svg title=https://yusank.github.io/images/logo.svg><span id=id-2 class=typeit></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/about/ title>关于</a><a class=menu-item href=/links/ title>友链</a><a class=menu-item href=https://github.com/yusank title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw'></i></a><a class=menu-item href=https://go-goim.github.io title=GoIM rel="noopener noreffer" target=_blank><i class='far fa-share-square'></i>GoIM</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">[系列]微服务·深入了解gRPC Part2</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/yusank title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Yusank</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/microservice/><i class="far fa-folder fa-fw" aria-hidden=true></i>microservice</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2022-07-07>2022-07-07</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 5577 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 12 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-前言>1. 前言</a></li><li><a href=#2-数据流流模式>2. 数据流流模式</a><ul><li><a href=#21-客户端单向数据流>2.1 客户端单向数据流</a></li><li><a href=#22-服务端单向数据流>2.2 服务端单向数据流</a></li><li><a href=#23-双向数据流>2.3 双向数据流</a></li><li><a href=#24-数据流的实现>2.4 数据流的实现</a><ul><li><a href=#241-客户端读写数据流>2.4.1 客户端读写数据流</a></li><li><a href=#242-服务端读写流数据>2.4.2 服务端读写流数据</a></li></ul></li></ul></li><li><a href=#4-性能调优>4. 性能调优</a></li><li><a href=#6-总结>6. 总结</a></li></ul></nav></div></div><div class=content id=content><blockquote><p>本文为系列篇<code>微服务</code>的关于 深入 gRPC 的文章。本篇将会从 gRPC 的基本概念、gRPC 的使用、gRPC 的编程模型、gRPC 的编程模型的实现、gRPC 的编程模型的实现的细节等多个角度来了解。</p><p>本篇为 <code>深入了解gRPC</code> 的下篇，篇幅原因，将这篇文章拆分成上下篇，点击这里<a href=../microservices-grpc-part1 rel>查看上篇</a></p></blockquote><h2 id=1-前言>1. 前言</h2><p>上一篇文章介绍了 grpc 的基本概念，基础用法和其基本编程模式 &ndash; <code>应答模式</code> 相关的内容，这篇将会继续讲解 grpc 下的编程模式。本篇将会介绍 <code>数据流编程模式</code> 的使用和实现，之后介绍 grpc 其他核心逻辑和使用经验。</p><h2 id=2-数据流流模式>2. 数据流流模式</h2><p>数据流模式是服务端或客户端以流的形式持续向对方读/写数据，直到任意一方结束这次通信。这种模式的使用场景也比较多，比如：</p><ol><li>客户端上传文件，文件被客户端切分成多个块，然后发送给服务端</li><li>服务端想客户端下发一个数据流（类似 tail -f 远端文件 or log）或者下载一个较大文件，由服务端分片下发给客户端。</li><li>客户端订阅服务端数据。</li><li>客户端与服务端进行交互式通信，像聊天一样。</li></ol><p>而数据流模式从细节上可以有三种情况，而这三种情况各有一些细节上的区别，下面我们来看看这三种情况。</p><h3 id=21-客户端单向数据流>2.1 客户端单向数据流</h3><p>首先定义 rpc 方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-proto data-lang=proto><span class=line><span class=cl><span class=c1>// 假如批量创建大量订单
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>rpc</span> <span class=n>CreateOrder</span><span class=p>(</span><span class=n>stream</span> <span class=n>Empty</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>Empty</span><span class=p>)</span> <span class=p>{}</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>生成的客户端侧代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>OrderServiceClient</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>CreateOrder</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>opts</span> <span class=o>...</span><span class=nx>grpc</span><span class=p>.</span><span class=nx>CallOption</span><span class=p>)</span> <span class=p>(</span><span class=nx>OrderService_CreateOrderClient</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>OrderService_CreateOrderClient</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Send</span><span class=p>(</span><span class=o>*</span><span class=nx>Empty</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>    <span class=nf>CloseAndRecv</span><span class=p>()</span> <span class=p>(</span><span class=o>*</span><span class=nx>Empty</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>grpc</span><span class=p>.</span><span class=nx>ClientStream</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>客户端请求服务端后，得到一个 <code>OrderService_CreateOrderClient</code> 对象，然后调用 <code>Send</code> 方法，向服务端持续写入 <code>Empty</code> 数据，直到最后一次的时候，调用 <code>CloseAndRecv</code> 方法，返回服务端的响应。服务端仅在最后一次进行响应。</p><p>而服务端侧生成的代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>OrderServiceServer</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>CreateOrder</span><span class=p>(</span><span class=nx>OrderService_CreateOrderServer</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>OrderService_CreateOrderServer</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>SendAndClose</span><span class=p>(</span><span class=o>*</span><span class=nx>Empty</span><span class=p>)</span> <span class=kt>error</span> <span class=c1>// 实际上并不会执行任何 close 操作，由客户端在 recv 时 close
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Recv</span><span class=p>()</span> <span class=p>(</span><span class=o>*</span><span class=nx>Empty</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>grpc</span><span class=p>.</span><span class=nx>ServerStream</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>那么对用使用者来说应该如何使用这些生成的代码来实现自己的需求呢？请看使用案例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// client
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>createOrder</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>,</span><span class=nx>err</span> <span class=o>:=</span> <span class=nx>orderpb</span><span class=p>.</span><span class=nf>NewOrderServiceClient</span><span class=p>(</span><span class=nx>grpcConn</span><span class=p>).</span><span class=nf>CreateOrder</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>someCondition</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Send</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>orderpb</span><span class=p>.</span><span class=nx>Empty</span><span class=p>{});</span><span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// finish send
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>empty</span><span class=p>,</span><span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>CloseAndRecv</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// finish recv
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// do something with empty
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// server
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>handleCreateOrder</span><span class=p>(</span><span class=nx>s</span> <span class=nx>orderpb</span><span class=p>.</span><span class=nx>OrderService_CreateOrderServer</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>someCondition</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>empty</span><span class=p>,</span><span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nf>Recv</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do something with empty
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// finish recv
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nf>SendAndClose</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>orderpb</span><span class=p>.</span><span class=nx>Empty</span><span class=p>{});</span><span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// finish send
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=22-服务端单向数据流>2.2 服务端单向数据流</h3><p>首先定义 rpc 方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-proto data-lang=proto><span class=line><span class=cl><span class=c1>// 假如返回的数据量很多 or 需要持续返回最新数据，更多的像一种 订阅模式
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>rpc</span> <span class=n>GetOrderList</span><span class=p>(</span><span class=n>Empty</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>stream</span> <span class=n>Empty</span><span class=p>)</span> <span class=p>{}</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>生成的客户端侧代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>OrderServiceClient</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>GetOrderList</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>in</span> <span class=o>*</span><span class=nx>Empty</span><span class=p>,</span> <span class=nx>opts</span> <span class=o>...</span><span class=nx>grpc</span><span class=p>.</span><span class=nx>CallOption</span><span class=p>)</span> <span class=p>(</span><span class=nx>OrderService_GetOrderListClient</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>OrderService_GetOrderListClient</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Recv</span><span class=p>()</span> <span class=p>(</span><span class=o>*</span><span class=nx>Empty</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>grpc</span><span class=p>.</span><span class=nx>ClientStream</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>客户端请求服务端后拿到一个 <code>OrderService_GetOrderListClient</code> 对象，然后调用 <code>Recv</code> 方法，接收服务端的数据流，一直到报错或自己逻辑中断。</p><p>服务端侧生成的代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>OrderServiceServer</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>GetOrderList</span><span class=p>(</span><span class=o>*</span><span class=nx>Empty</span><span class=p>,</span> <span class=nx>OrderService_GetOrderListServer</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>OrderService_GetOrderListServer</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Send</span><span class=p>(</span><span class=o>*</span><span class=nx>Empty</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>    <span class=nx>grpc</span><span class=p>.</span><span class=nx>ServerStream</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>服务端收到请求时，会传参 <code>Empty</code> 和 <code>OrderService_GetOrderListServer</code> 对象，第一个参数是由客户端传过来，第二个参数用来写入数据流。服务端向 <code>OrderService_GetOrderListServer</code> 持续写入数据，直到报错或自己逻辑中断。</p><p>那么对用使用者来说应该如何使用这些生成的代码来实现自己的需求呢？请看使用案例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// client
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>listOrder</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>,</span><span class=nx>err</span> <span class=o>:=</span> <span class=nx>orderpb</span><span class=p>.</span><span class=nf>NewOrderServiceClient</span><span class=p>(</span><span class=nx>grpcConn</span><span class=p>).</span><span class=nf>GetOrderList</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>someCondition</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>empty</span><span class=p>,</span><span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Recv</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do something with empty
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// finish recv
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// server
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>handleListOrder</span><span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>orderpb</span><span class=p>.</span><span class=nx>Empty</span><span class=p>,</span> <span class=nx>s</span> <span class=nx>orderpb</span><span class=p>.</span><span class=nx>OrderService_CreateOrderServer</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>someCondition</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nf>Send</span><span class=p>(</span><span class=nx>e</span><span class=p>);</span><span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// finish send
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=23-双向数据流>2.3 双向数据流</h3><p>双向数据流可以理解为上面两种数据流模型的组合，客户端和服务端均可以向 socket 写入流数据，同时可以从 socket 读取流数据。</p><p>首先定义 rpc 方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-proto data-lang=proto><span class=line><span class=cl><span class=kd>service</span> <span class=n>OrderService</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=k>rpc</span> <span class=n>BothWayStream</span><span class=p>(</span><span class=n>stream</span> <span class=n>Empty</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>stream</span> <span class=n>Empty</span><span class=p>)</span> <span class=p>{}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>生成的客户端侧代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>OrderServiceClient</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>BothWayStream</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>opts</span> <span class=o>...</span><span class=nx>grpc</span><span class=p>.</span><span class=nx>CallOption</span><span class=p>)</span> <span class=p>(</span><span class=nx>OrderService_BothWayStreamClient</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>OrderService_BothWayStreamClient</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Send</span><span class=p>(</span><span class=o>*</span><span class=nx>Empty</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>    <span class=nf>Recv</span><span class=p>()</span> <span class=p>(</span><span class=o>*</span><span class=nx>Empty</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>grpc</span><span class=p>.</span><span class=nx>ClientStream</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>客户端发起请求后，拿到一个 <code>OrderService_BothWayStreamClient</code> 对象，然后调用 <code>Send</code> 方法，向服务端写入数据，然后调用 <code>Recv</code> 方法，接收服务端的数据流，一直到报错或自己逻辑中断。</p><p>服务端侧生成的代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>OrderServiceServer</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>BothWayStream</span><span class=p>(</span><span class=nx>OrderService_BothWayStreamServer</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>OrderService_BothWayStreamServer</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Send</span><span class=p>(</span><span class=o>*</span><span class=nx>Empty</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>    <span class=nf>Recv</span><span class=p>()</span> <span class=p>(</span><span class=o>*</span><span class=nx>Empty</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>grpc</span><span class=p>.</span><span class=nx>ServerStream</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>而服务端的定义的方式接受的参数是 <code>OrderService_BothWayStreamServer</code> 对象，通过该对象的 <code>Send</code> 方法向客户端写入数据，通过 <code>Recv</code> 方法接收客户端的数据流。</p><p>以实现一个 ssh proxy 的例子来介绍双向数据流模式的使用：</p><p>客户端的实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>client</span><span class=p>(</span><span class=nx>stdin</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span><span class=p>,</span> <span class=nx>stdout</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 定义一个双向数据流
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>stream</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>orderpb</span><span class=p>.</span><span class=nf>NewOrderServiceClient</span><span class=p>(</span><span class=nx>grpcConn</span><span class=p>).</span><span class=nf>BothWayStream</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// read from stdin
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>buf</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>1024</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>stdin</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nx>err</span> <span class=p>=</span> <span class=nx>stream</span><span class=p>.</span><span class=nf>Send</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>orderpb</span><span class=p>.</span><span class=nx>Empty</span><span class=p>{</span><span class=nx>buf</span><span class=p>})</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// write to stdout
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>empty</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>stream</span><span class=p>.</span><span class=nf>Recv</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>stdout</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>empty</span><span class=p>.</span><span class=nx>Data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>服务端的实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>server</span><span class=p>(</span><span class=nx>stream</span> <span class=nx>orderpb</span><span class=p>.</span><span class=nx>OrderService_BothWayStreamServer</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>req</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>stream</span><span class=p>.</span><span class=nf>Recv</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do something with req
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>resp</span> <span class=o>:=</span> <span class=nf>doSomething</span><span class=p>(</span><span class=nx>req</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>err</span> <span class=p>=</span> <span class=nx>stream</span><span class=p>.</span><span class=nf>Send</span><span class=p>(</span><span class=nx>resp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>以上就是三种数据流模式的定义和使用示例，下面我们从源码层面去理解，客户端/服务端是如何实现的读写流数据的。</p><h3 id=24-数据流的实现>2.4 数据流的实现</h3><p>数据流的实现我们分成客户端和服务端来讲解。</p><h4 id=241-客户端读写数据流>2.4.1 客户端读写数据流</h4><p>客户端的数据流通过 <code>ClientStream</code> 接口实现，客户端对当前数据流的操作都是通过 <code>ClientStream</code> 接口来实现的，比如 <code>Send</code>、<code>Recv</code> 这些方法都是基于 <code>SendMsg</code>、<code>RecvMsg</code> 方法封装的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ClientStream defines the client-side behavior of a streaming RPC.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// All errors returned from ClientStream methods are compatible with the
</span></span></span><span class=line><span class=cl><span class=c1>// status package.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>ClientStream</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Header returns the header metadata received from the server if there
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// is any. It blocks if the metadata is not ready to read.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Header</span><span class=p>()</span> <span class=p>(</span><span class=nx>metadata</span><span class=p>.</span><span class=nx>MD</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Trailer returns the trailer metadata from the server, if there is any.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// It must only be called after stream.CloseAndRecv has returned, or
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// stream.Recv has returned a non-nil error (including io.EOF).
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Trailer</span><span class=p>()</span> <span class=nx>metadata</span><span class=p>.</span><span class=nx>MD</span>
</span></span><span class=line><span class=cl>    <span class=c1>// CloseSend closes the send direction of the stream. It closes the stream
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// when non-nil error is met. It is also not safe to call CloseSend
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// concurrently with SendMsg.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>CloseSend</span><span class=p>()</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Context returns the context for this stream.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// It should not be called until after Header or RecvMsg has returned. Once
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// called, subsequent client-side retries are disabled.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Context</span><span class=p>()</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span>
</span></span><span class=line><span class=cl>    <span class=c1>// SendMsg is generally called by generated code. On error, SendMsg aborts
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// the stream. If the error was generated by the client, the status is
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// returned directly; otherwise, io.EOF is returned and the status of
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// the stream may be discovered using RecvMsg.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// SendMsg blocks until:
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//   - There is sufficient flow control to schedule m with the transport, or
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//   - The stream is done, or
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//   - The stream breaks.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// SendMsg does not wait until the message is received by the server. An
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// untimely stream closure may result in lost messages. To ensure delivery,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// users should ensure the RPC completed successfully using RecvMsg.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// It is safe to have a goroutine calling SendMsg and another goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// calling RecvMsg on the same stream at the same time, but it is not safe
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// to call SendMsg on the same stream in different goroutines. It is also
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// not safe to call CloseSend concurrently with SendMsg.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>SendMsg</span><span class=p>(</span><span class=nx>m</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>    <span class=c1>// RecvMsg blocks until it receives a message into m or the stream is
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// done. It returns io.EOF when the stream completes successfully. On
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// any other error, the stream is aborted and the error contains the RPC
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// status.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// It is safe to have a goroutine calling SendMsg and another goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// calling RecvMsg on the same stream at the same time, but it is not
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// safe to call RecvMsg on the same stream in different goroutines.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>RecvMsg</span><span class=p>(</span><span class=nx>m</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>我们现在一起过一下一次 <code>SendMsg</code> 的流程：</p><ol><li>客户端调用 <code>OrderServiceClient.BothWayStream</code> 方法。</li><li><code>BothWayStream</code> 调用 <code>grpcConn.NewStream</code> 方法创建一个新的数据流。而 <code>grpcConn.NewStream</code> 方法主要做以下几件事：<ol><li>解析服务端的地址，并创建一个连接。</li><li>初始化 http2 transport，并创建一个新的 http2 stream。</li><li>将 http2 stream, http2 transport 和其他 dial 参数封装成一个 <code>clientStream</code> 对象。</li></ol></li><li>调用 <code>clientStream.SendMsg</code> 方法发送数据。而 <code>clientStream.SendMsg</code> 方法内主要做以下几件事：<ol><li>将消息 encode, compress 和处理 header</li><li>将消息写入到 http2 transport 中。从这里开始往下逻辑与上一篇讲到的应答模式实现时一样的，都是由 http2 client 来实现的。</li></ol></li></ol><figure><a class=lightgallery href=/posts/microservices-grpc-part2/grpc-stream-send.png title=/posts/microservices-grpc-part2/grpc-stream-send.png data-thumbnail=/posts/microservices-grpc-part2/grpc-stream-send.png data-sub-html="<h2>客户端写入数据流程(点击放大)</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/posts/microservices-grpc-part2/grpc-stream-send.png data-srcset="/posts/microservices-grpc-part2/grpc-stream-send.png, /posts/microservices-grpc-part2/grpc-stream-send.png 1.5x, /posts/microservices-grpc-part2/grpc-stream-send.png 2x" data-sizes=auto alt=/posts/microservices-grpc-part2/grpc-stream-send.png width=1200 height=1436></a><figcaption class=image-caption>客户端写入数据流程(点击放大)</figcaption></figure><p>下面我们看一下接受消息 <code>RecvMsg</code> 的流程：</p><ol><li>与上面一样，先初始化 <code>grpcConn.ClientStream</code> 对象。</li><li>调用 <code>clientStream.Recv.Msg</code> 方法读取数据。而 <code>clientStream.Recv.Msg</code> 方法内主要做以下几件事：<ol><li>从 http2 transport 中读取数据。</li><li>解析数据，并将数据解压和 decode。</li><li>将数据解析成消息。</li></ol></li></ol><p>读取消息的相关代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// parser reads complete gRPC messages from the underlying reader.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>parser</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// r is the underlying reader.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// See the comment on recvMsg for the permissible
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// error types.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>r</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// The header of a gRPC message. Find more detail at
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>header</span> <span class=p>[</span><span class=mi>5</span><span class=p>]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>parser</span><span class=p>)</span> <span class=nf>recvMsg</span><span class=p>(</span><span class=nx>maxReceiveMessageSize</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>pf</span> <span class=nx>payloadFormat</span><span class=p>,</span> <span class=nx>msg</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// p.r 是 http2 stream 的 reader。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>r</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>header</span><span class=p>[:]);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 第一位记录消息类型
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>pf</span> <span class=p>=</span> <span class=nf>payloadFormat</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>header</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 会四位记录消息长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>length</span> <span class=o>:=</span> <span class=nx>binary</span><span class=p>.</span><span class=nx>BigEndian</span><span class=p>.</span><span class=nf>Uint32</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>header</span><span class=p>[</span><span class=mi>1</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>length</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>pf</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>int64</span><span class=p>(</span><span class=nx>length</span><span class=p>)</span> <span class=p>&gt;</span> <span class=nb>int64</span><span class=p>(</span><span class=nx>maxInt</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>status</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=nx>codes</span><span class=p>.</span><span class=nx>ResourceExhausted</span><span class=p>,</span> <span class=s>&#34;grpc: received message larger than max length allowed on current machine (%d vs. %d)&#34;</span><span class=p>,</span> <span class=nx>length</span><span class=p>,</span> <span class=nx>maxInt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>int</span><span class=p>(</span><span class=nx>length</span><span class=p>)</span> <span class=p>&gt;</span> <span class=nx>maxReceiveMessageSize</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>status</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=nx>codes</span><span class=p>.</span><span class=nx>ResourceExhausted</span><span class=p>,</span> <span class=s>&#34;grpc: received message larger than max (%d vs. %d)&#34;</span><span class=p>,</span> <span class=nx>length</span><span class=p>,</span> <span class=nx>maxReceiveMessageSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// TODO(bradfitz,zhaoq): garbage. reuse buffer after proto decoding instead
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// of making it for each message:
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>msg</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=nx>length</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>r</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>msg</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=nx>io</span><span class=p>.</span><span class=nx>EOF</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>err</span> <span class=p>=</span> <span class=nx>io</span><span class=p>.</span><span class=nx>ErrUnexpectedEOF</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>pf</span><span class=p>,</span> <span class=nx>msg</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><figure><a class=lightgallery href=/posts/microservices-grpc-part2/grpc-stream-recv.png title=/posts/microservices-grpc-part2/grpc-stream-recv.png data-thumbnail=/posts/microservices-grpc-part2/grpc-stream-recv.png data-sub-html="<h2>客户端读取数据流程(点击放大)</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/posts/microservices-grpc-part2/grpc-stream-recv.png data-srcset="/posts/microservices-grpc-part2/grpc-stream-recv.png, /posts/microservices-grpc-part2/grpc-stream-recv.png 1.5x, /posts/microservices-grpc-part2/grpc-stream-recv.png 2x" data-sizes=auto alt=/posts/microservices-grpc-part2/grpc-stream-recv.png width=400 height=1399></a><figcaption class=image-caption>客户端读取数据流程(点击放大)</figcaption></figure><div class="details admonition warning open"><div class="details-summary admonition-title"><i class="icon fas fa-exclamation-triangle fa-fw" aria-hidden=true></i>注意<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>我们在前面的单向流过程中看到了类似 <code>CloseAndRecv</code> 的方法，而这种带有 close 的方法是由 <code>ClientStream</code> 的 <code>CloseSend</code> 方法来实现的。
而这个方法的实现也相对简单，是在向 http2 transport 写入消息的同时带上一个 option 值来实现的，源码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>cs</span> <span class=o>*</span><span class=nx>clientStream</span><span class=p>)</span> <span class=nf>CloseSend</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>cs</span><span class=p>.</span><span class=nx>sentLast</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// TODO: return an error and finish the stream instead, due to API misuse?
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>cs</span><span class=p>.</span><span class=nx>sentLast</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=nx>op</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>a</span> <span class=o>*</span><span class=nx>csAttempt</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 在这里带上一个 Last 标记，表示这是最后一个消息。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>a</span><span class=p>.</span><span class=nx>t</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>a</span><span class=p>.</span><span class=nx>s</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>transport</span><span class=p>.</span><span class=nx>Options</span><span class=p>{</span><span class=nx>Last</span><span class=p>:</span> <span class=kc>true</span><span class=p>})</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Always return nil; io.EOF is the only error that might make sense
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// instead, but there is no need to signal the client to call RecvMsg
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// as the only use left for the stream after CloseSend is to call
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// RecvMsg.  This also matches historical behavior.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>cs</span><span class=p>.</span><span class=nf>withRetry</span><span class=p>(</span><span class=nx>op</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>cs</span><span class=p>.</span><span class=nf>bufferForRetryLocked</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nx>op</span><span class=p>)</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=c1>// We never returned an error here for reasons.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>而 http2 transport 在写入消息时，如果这个标志位是 true，则将这个 stream（这个连接）标记为写入完成的标识，表示不再写新的消息。源码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Write formats the data into HTTP2 data frame(s) and sends it out. The caller
</span></span></span><span class=line><span class=cl><span class=c1>// should proceed only if Write returns nil.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>http2Client</span><span class=p>)</span> <span class=nf>Write</span><span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>Stream</span><span class=p>,</span> <span class=nx>hdr</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>data</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>opts</span> <span class=o>*</span><span class=nx>Options</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>opts</span><span class=p>.</span><span class=nx>Last</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// If it&#39;s the last message, update stream state.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 这里！！！
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 如果当前状态是 active 则，将其置位 streamWriteDone， 然后下面写操作继续执行。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>!</span><span class=nx>s</span><span class=p>.</span><span class=nf>compareAndSwapState</span><span class=p>(</span><span class=nx>streamActive</span><span class=p>,</span> <span class=nx>streamWriteDone</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>errStreamDone</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 下次有新消息要写时，会报错
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>s</span><span class=p>.</span><span class=nf>getState</span><span class=p>()</span> <span class=o>!=</span> <span class=nx>streamActive</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>errStreamDone</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>df</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>dataFrame</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>streamID</span><span class=p>:</span>  <span class=nx>s</span><span class=p>.</span><span class=nx>id</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>endStream</span><span class=p>:</span> <span class=nx>opts</span><span class=p>.</span><span class=nx>Last</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>h</span><span class=p>:</span>         <span class=nx>hdr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>d</span><span class=p>:</span>         <span class=nx>data</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>hdr</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>||</span> <span class=nx>data</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span> <span class=c1>// If it&#39;s not an empty data frame, check quota.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>wq</span><span class=p>.</span><span class=nf>get</span><span class=p>(</span><span class=nb>int32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>hdr</span><span class=p>)</span> <span class=o>+</span> <span class=nb>len</span><span class=p>(</span><span class=nx>data</span><span class=p>)));</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 这个就是上面流程提到的 buffer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nx>t</span><span class=p>.</span><span class=nx>controlBuf</span><span class=p>.</span><span class=nf>put</span><span class=p>(</span><span class=nx>df</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div></div></div><h4 id=242-服务端读写流数据>2.4.2 服务端读写流数据</h4><p>与客户端逻辑类似，服务端的数据流读写也是基于一个接口定义(<code>ServerStream</code>)调用的，这个接口定义如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ServerStream defines the server-side behavior of a streaming RPC.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Errors returned from ServerStream methods are compatible with the status
</span></span></span><span class=line><span class=cl><span class=c1>// package.  However, the status code will often not match the RPC status as
</span></span></span><span class=line><span class=cl><span class=c1>// seen by the client application, and therefore, should not be relied upon for
</span></span></span><span class=line><span class=cl><span class=c1>// this purpose.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>ServerStream</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// SetHeader sets the header metadata. It may be called multiple times.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// When call multiple times, all the provided metadata will be merged.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// All the metadata will be sent out when one of the following happens:
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//  - ServerStream.SendHeader() is called;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//  - The first response is sent out;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//  - An RPC status is sent out (error or success).
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>SetHeader</span><span class=p>(</span><span class=nx>metadata</span><span class=p>.</span><span class=nx>MD</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>    <span class=c1>// SendHeader sends the header metadata.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// The provided md and headers set by SetHeader() will be sent.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// It fails if called multiple times.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>SendHeader</span><span class=p>(</span><span class=nx>metadata</span><span class=p>.</span><span class=nx>MD</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>    <span class=c1>// SetTrailer sets the trailer metadata which will be sent with the RPC status.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// When called more than once, all the provided metadata will be merged.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>SetTrailer</span><span class=p>(</span><span class=nx>metadata</span><span class=p>.</span><span class=nx>MD</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Context returns the context for this stream.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Context</span><span class=p>()</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span>
</span></span><span class=line><span class=cl>    <span class=c1>// SendMsg sends a message. On error, SendMsg aborts the stream and the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// error is returned directly.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// SendMsg blocks until:
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//   - There is sufficient flow control to schedule m with the transport, or
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//   - The stream is done, or
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//   - The stream breaks.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// SendMsg does not wait until the message is received by the client. An
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// untimely stream closure may result in lost messages.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// It is safe to have a goroutine calling SendMsg and another goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// calling RecvMsg on the same stream at the same time, but it is not safe
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// to call SendMsg on the same stream in different goroutines.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>SendMsg</span><span class=p>(</span><span class=nx>m</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>    <span class=c1>// RecvMsg blocks until it receives a message into m or the stream is
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// done. It returns io.EOF when the client has performed a CloseSend. On
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// any non-EOF error, the stream is aborted and the error contains the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// RPC status.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// It is safe to have a goroutine calling SendMsg and another goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// calling RecvMsg on the same stream at the same time, but it is not
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// safe to call RecvMsg on the same stream in different goroutines.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>RecvMsg</span><span class=p>(</span><span class=nx>m</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>与 <code>ClientStream</code> 类似，但是少了一些方法，比如 <code>CloseSend</code> 。</p><p>我们先看一下，一次请求是如何进入到我们实现的方法，然后再看数据流的读写。由于 http2 中所有的请求都是 stream，所以这块接受请求的流程与上篇讲述的很类似而且前面几步都是公用的代码，而不同点从 <code>processStreamingRPC</code> 方法开始(前面的步骤不再重复讲解)。</p><ol><li>在 <code>processStreamingRPC</code> 方法内，先根据上下文创建 <code>serverStream</code>, 它包含了 transport, stream, encode 等需要的信息。</li><li>通过 header 读取 compress 方法。</li><li>调用注册的 handler 来处理请求。</li><li>handler 结束或者报错后，打日志然后向 stream 写入 status 并关闭 stream。</li></ol><figure><a class=lightgallery href=/posts/microservices-grpc-part2/grpc-handle.png title=/posts/microservices-grpc-part2/grpc-handle.png data-thumbnail=/posts/microservices-grpc-part2/grpc-handle.png data-sub-html="<h2>接受请求过程</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/posts/microservices-grpc-part2/grpc-handle.png data-srcset="/posts/microservices-grpc-part2/grpc-handle.png, /posts/microservices-grpc-part2/grpc-handle.png 1.5x, /posts/microservices-grpc-part2/grpc-handle.png 2x" data-sizes=auto alt=/posts/microservices-grpc-part2/grpc-handle.png width=2444 height=1365></a><figcaption class=image-caption>接受请求过程</figcaption></figure><figure><a class=lightgallery href=/posts/microservices-grpc-part2/grpc-stream-server-init.png title=/posts/microservices-grpc-part2/grpc-stream-server-init.png data-thumbnail=/posts/microservices-grpc-part2/grpc-stream-server-init.png data-sub-html="<h2>调用实现的方法过程</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/posts/microservices-grpc-part2/grpc-stream-server-init.png data-srcset="/posts/microservices-grpc-part2/grpc-stream-server-init.png, /posts/microservices-grpc-part2/grpc-stream-server-init.png 1.5x, /posts/microservices-grpc-part2/grpc-stream-server-init.png 2x" data-sizes=auto alt=/posts/microservices-grpc-part2/grpc-stream-server-init.png width=1447 height=1034></a><figcaption class=image-caption>调用实现的方法过程</figcaption></figure><p>下面我们看一下 <code>SendMsg</code> 的实现。server 端的写入消息的实现与 client 端基本一致，并且底层调用的方法是一样的，这里过一下流程，流程图就不再重复画了。</p><ol><li>调用 <code>SendMsg</code> 方法后，根据消息内容和 encode 方法，进行消息的 encode ，压缩和写入 header</li><li>然后调用 http2 transport 的write 方法，这个方法我们已经遇到好几次了，所有涉及到写操作的底层都是这个方法。</li><li>检查写入是否报错，如果有则将错误 status 写入 stream 并结束 stream。</li></ol><p>而 <code>RecvMsg</code> 方法的实现也是公用的，底层与 client 端基本一致，都使用 <code>recv()</code> 方法实现数据的接受和解码。请移步到 client 端接受数据的实现。</p><h2 id=4-性能调优>4. 性能调优</h2><p><code>MaxSendMsgSizeGRPC</code> 最大允许发送的字节数，默认4MiB，如果超过了GRPC会报错。如果有传输大数据的需求，请适当调高这个参数。</p><p><code>MaxRecvMsgSizeGRPC</code> 最大允许接收的字节数，默认4MiB，如果超过了GRPC会报错。同上。</p><p><code>InitialWindowSize</code> 基于Stream的滑动窗口，类似于TCP的滑动窗口，用来做流控，默认64KiB，吞吐量上不去，根据自己的流量往上调整。</p><p><code>InitialConnWindowSize</code> 基于Connection的滑动窗口，默认 64KiB，吞吐量上不去，同上。</p><p>至于 <code>MaxConcurrentStreams</code> 的配置（一个连接上的并发 stream 数量），很多文章指出默认是 100，会影响性能，其实不对的。从源码层面来看， http2 server 端支持配置这个参数，但是默认是 0，而该值为 0 的时候，server 端 transport 初始化时做了判断的，如果是 0，则会设置为 <code>math.MaxUint32</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>    <span class=c1>// TODO(zhaoq): Have a better way to signal &#34;no limit&#34; because 0 is
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// permitted in the HTTP2 spec.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>maxStreams</span> <span class=o>:=</span> <span class=nx>config</span><span class=p>.</span><span class=nx>MaxStreams</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>maxStreams</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 注意看这里！
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>maxStreams</span> <span class=p>=</span> <span class=nx>math</span><span class=p>.</span><span class=nx>MaxUint32</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>isettings</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>isettings</span><span class=p>,</span> <span class=nx>http2</span><span class=p>.</span><span class=nx>Setting</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 请记住这个 ID
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>ID</span><span class=p>:</span>  <span class=nx>http2</span><span class=p>.</span><span class=nx>SettingMaxConcurrentStreams</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nx>Val</span><span class=p>:</span> <span class=nx>maxStreams</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>而 client 端初始化一个新的 http2 client 时，也有一个 <code>maxConcurrentStreams</code> 参数且默认值的确是 <code>100</code>，这个参数是用来限制 client 端的并发 stream 数量的，如果超过了这个值，则会报错。但是这个 100 并非是最终的值，在 client 初始化方法中有个异步处理的流程：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>    <span class=c1>// http2_client.go:newHTTP2Client()
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Start the reader goroutine for incoming message. Each transport has
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// a dedicated goroutine which reads HTTP2 frame from network. Then it
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// dispatches the frame to the corresponding stream entity.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>go</span> <span class=nx>t</span><span class=p>.</span><span class=nf>reader</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// http2_client.go:http2Client.reader()
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>t</span><span class=p>.</span><span class=nf>handleSettings</span><span class=p>(</span><span class=nx>sf</span><span class=p>,</span> <span class=kc>true</span><span class=cm>/*isFirst*/</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>而这个 <code>t.handleSettings</code> 是关键方法，它给 client 的一些参数进行了重新赋值，让我们看一下源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// http2_client.go:http2Client.handleSettings()
</span></span></span><span class=line><span class=cl><span class=c1>// http2.SettingFrame 是从服务端读取的数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>http2Client</span><span class=p>)</span> <span class=nf>handleSettings</span><span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>http2</span><span class=p>.</span><span class=nx>SettingsFrame</span><span class=p>,</span> <span class=nx>isFirst</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>f</span><span class=p>.</span><span class=nf>IsAck</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>maxStreams</span> <span class=o>*</span><span class=kt>uint32</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>ss</span> <span class=p>[]</span><span class=nx>http2</span><span class=p>.</span><span class=nx>Setting</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>updateFuncs</span> <span class=p>[]</span><span class=kd>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>f</span><span class=p>.</span><span class=nf>ForeachSetting</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>s</span> <span class=nx>http2</span><span class=p>.</span><span class=nx>Setting</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>switch</span> <span class=nx>s</span><span class=p>.</span><span class=nx>ID</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 请注意这个 ID，这是服务端设置的
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>case</span> <span class=nx>http2</span><span class=p>.</span><span class=nx>SettingMaxConcurrentStreams</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nx>maxStreams</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=kt>uint32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=o>*</span><span class=nx>maxStreams</span> <span class=p>=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>Val</span> <span class=c1>// 也就是这个值现在是 math.MaxUint32
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 这也是从服务端设置的参数
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>case</span> <span class=nx>http2</span><span class=p>.</span><span class=nx>SettingMaxHeaderListSize</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nx>updateFuncs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>updateFuncs</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>t</span><span class=p>.</span><span class=nx>maxSendHeaderListSize</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=kt>uint32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=o>*</span><span class=nx>t</span><span class=p>.</span><span class=nx>maxSendHeaderListSize</span> <span class=p>=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>Val</span>
</span></span><span class=line><span class=cl>            <span class=p>})</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nx>ss</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>ss</span><span class=p>,</span> <span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 此时 maxStreams != nil
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>isFirst</span> <span class=o>&amp;&amp;</span> <span class=nx>maxStreams</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>maxStreams</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=kt>uint32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=nx>maxStreams</span> <span class=p>=</span> <span class=nx>math</span><span class=p>.</span><span class=nx>MaxUint32</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>sf</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>incomingSettings</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>ss</span><span class=p>:</span> <span class=nx>ss</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>maxStreams</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>updateStreamQuota</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>delta</span> <span class=o>:=</span> <span class=nb>int64</span><span class=p>(</span><span class=o>*</span><span class=nx>maxStreams</span><span class=p>)</span> <span class=o>-</span> <span class=nb>int64</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>maxConcurrentStreams</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>t</span><span class=p>.</span><span class=nx>maxConcurrentStreams</span> <span class=p>=</span> <span class=o>*</span><span class=nx>maxStreams</span> <span class=c1>// 这里重新赋值了 现在 t.maxConcurrentStreams == math.MaxUint32
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>t</span><span class=p>.</span><span class=nx>streamQuota</span> <span class=o>+=</span> <span class=nx>delta</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>delta</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>t</span><span class=p>.</span><span class=nx>waitingStreams</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nb>close</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>streamsQuotaAvailable</span><span class=p>)</span> <span class=c1>// wake all of them up.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nx>t</span><span class=p>.</span><span class=nx>streamsQuotaAvailable</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{},</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>updateFuncs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>updateFuncs</span><span class=p>,</span> <span class=nx>updateStreamQuota</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// executeAndPut 会直接执行这个方法
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>t</span><span class=p>.</span><span class=nx>controlBuf</span><span class=p>.</span><span class=nf>executeAndPut</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=kd>interface</span><span class=p>{})</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>f</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>updateFuncs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>f</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=nx>sf</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>也就是说虽然client 端的确默认值是 0，但是由于服务端默认不赋值从而设置的是 <code>math.MaxUint32</code>，所以 client 端的默认值也是 <code>math.MaxUint32</code>。</p><p>对于想更进一步优化性能的同学，建议最好看一下 <code>grpc/transport</code> 包下的实现 <code>http2</code> 客户端/服务端的代码，了解一下连接管理和数据传输过程，看一下哪些参数会对数据传输大小延迟有影响，从而针对性的优化。</p><h2 id=6-总结>6. 总结</h2><p>本篇主要讲述：</p><ol><li>了解 grpc 的流式编程模式的使用，包括单向流和双向流。</li><li>了解 grpc 的客户端和服务端如何实现流式数据的读写并了解客户端服务端的读写数据时的函数调用流程。</li><li>了解常见 grpc 的性能调优并澄清一个常见的关于 <code>maxConcurrentStreams</code> 的误解。</li></ol></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-07-07</span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/posts/microservices-grpc-part2/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://yusank.github.io/posts/microservices-grpc-part2/ data-title="[系列]微服务·深入了解gRPC Part2" data-hashtags=微服务,系列篇,grpc><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://yusank.github.io/posts/microservices-grpc-part2/ data-hashtag=微服务><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://yusank.github.io/posts/microservices-grpc-part2/><i class="fab fa-linkedin fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 WhatsApp" data-sharer=whatsapp data-url=https://yusank.github.io/posts/microservices-grpc-part2/ data-title="[系列]微服务·深入了解gRPC Part2" data-web><i class="fab fa-whatsapp fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://yusank.github.io/posts/microservices-grpc-part2/ data-title="[系列]微服务·深入了解gRPC Part2"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Reddit" data-sharer=reddit data-url=https://yusank.github.io/posts/microservices-grpc-part2/><i class="fab fa-reddit fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://yusank.github.io/posts/microservices-grpc-part2/ data-title="[系列]微服务·深入了解gRPC Part2"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.0.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://yusank.github.io/posts/microservices-grpc-part2/ data-title="[系列]微服务·深入了解gRPC Part2" data-ralateuid=yusann><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Blogger" data-sharer=blogger data-url=https://yusank.github.io/posts/microservices-grpc-part2/ data-title="[系列]微服务·深入了解gRPC Part2" data-description><i class="fab fa-blogger fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://yusank.github.io/posts/microservices-grpc-part2/ data-title="[系列]微服务·深入了解gRPC Part2"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.0.0/icons/baidu.svg aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Evernote" data-sharer=evernote data-url=https://yusank.github.io/posts/microservices-grpc-part2/ data-title="[系列]微服务·深入了解gRPC Part2"><i class="fab fa-evernote fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a>,&nbsp;<a href=/tags/%E7%B3%BB%E5%88%97%E7%AF%87/>系列篇</a>,&nbsp;<a href=/tags/grpc/>grpc</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/microservices-grpc-part1/ class=prev rel=prev title="[系列]微服务·深入了解gRPC Part1"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>[系列]微服务·深入了解gRPC Part1</a></div></div><div id=comments><div id=utterances class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Keep learning and stay with lights.<br>❤ yusank<br></div><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.101.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2017 - 2022</span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by/4.0/deed.zh target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lightgallery@2.4.0/css/lightgallery-bundle.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery@2.4.0/lightgallery.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery@2.4.0/plugins/thumbnail/lg-thumbnail.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery@2.4.0/plugins/zoom/lg-zoom.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/typeit@8.6.0/dist/index.umd.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{utterances:{darkTheme:"github-dark",issueTerm:"pathname",label:"Comment",lightTheme:"github-light",repo:"yusank/yusank.github.io"}},data:{"id-1":"usank`s Site","id-2":"usank`s Site"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"},typeit:{cursorChar:"|",cursorSpeed:1e3,data:{"id-1":["id-1"],"id-2":["id-2"]},duration:-1,speed:70}}</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-24P8ZSJHCQ",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-24P8ZSJHCQ" async></script></body></html>