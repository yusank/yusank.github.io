<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="noodp">
<meta http-equiv=x-ua-compatible content="IE=edge, chrome=1">
<title>Go TCP Socket - Yusank`s Site</title><meta name=Description content="这是我的个人博客，我会在这里分享学习和成长过程中的积累和经验."><meta property="og:title" content="Go TCP Socket">
<meta property="og:description" content="转载文章 Go语言TCP Socket编程 文章原始地址: http://tonybai.com/2015/11/17/tcp-programming-in-golang/ Golang的主要 设计目标">
<meta property="og:type" content="article">
<meta property="og:url" content="https://yusank.github.io/posts/go-tcp/"><meta property="og:image" content="https://yusank.github.io/logo.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2017-07-31T10:00:01+08:00">
<meta property="article:modified_time" content="2021-11-22T15:22:33+08:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://yusank.github.io/logo.png">
<meta name=twitter:title content="Go TCP Socket">
<meta name=twitter:description content="转载文章 Go语言TCP Socket编程 文章原始地址: http://tonybai.com/2015/11/17/tcp-programming-in-golang/ Golang的主要 设计目标">
<meta name=application-name content="LoveIt">
<meta name=apple-mobile-web-app-title content="LoveIt"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://yusank.github.io/posts/go-tcp/><link rel=prev href=https://yusank.github.io/posts/docker/><link rel=next href=https://yusank.github.io/posts/go-udp/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Go TCP Socket","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/yusank.github.io\/posts\/go-tcp\/"},"genre":"posts","keywords":"go, tcp","wordcount":9837,"url":"https:\/\/yusank.github.io\/posts\/go-tcp\/","datePublished":"2017-07-31T10:00:01+08:00","dateModified":"2021-11-22T15:22:33+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Yusank"},"description":""}</script></head>
<body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script>
<div id=mask></div><div class=wrapper><header class=desktop id=header-desktop>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="Yusank`s Site"><span id=id-1 class=typeit></span></a>
</div>
<div class=menu>
<div class=menu-inner><a class=menu-item href=/posts/> 文章 </a><a class=menu-item href=/categories/> 分类 </a><a class=menu-item href=/tags/> 标签 </a><a class=menu-item href=/about/> 关于 </a><a class=menu-item href=https://github.com/yusank title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i> </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
</a>
</div>
</div>
</div>
</header><header class=mobile id=header-mobile>
<div class=header-container>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="Yusank`s Site"><span id=id-2 class=typeit></span></a>
</div>
<div class=menu-toggle id=menu-toggle-mobile>
<span></span><span></span><span></span>
</div>
</div>
<div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/about/ title>关于</a><a class=menu-item href=https://github.com/yusank title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
</a></div>
</div>
</header>
<div class="search-dropdown desktop">
<div id=search-dropdown-desktop></div>
</div>
<div class="search-dropdown mobile">
<div id=search-dropdown-mobile></div>
</div>
<main class=main>
<div class=container><div class=toc id=toc-auto>
<h2 class=toc-title>目录</h2>
<div class=toc-content id=toc-content-auto></div>
</div><article class="page single"><h1 class="single-title animated flipInX">Go TCP Socket</h1><div class=post-meta>
<div class=post-meta-line><span class=post-author><a href=https://github.com/yusank title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>Yusank</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/><i class="far fa-folder fa-fw"></i>网络编程</a></span></div>
<div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2017-07-31>2017-07-31</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 9837 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 20 分钟&nbsp;</div>
</div><div class="details toc" id=toc-static kept>
<div class="details-summary toc-title">
<span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span>
</div>
<div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents>
<ul>
<li><a href=#一模型>一、模型</a></li>
<li><a href=#二tcp连接的建立>二、TCP连接的建立</a>
<ul>
<li><a href=#1网络不可达或对方服务未启动>1、网络不可达或对方服务未启动</a></li>
<li><a href=#2对方服务的listen-backlog满>2、对方服务的listen backlog满</a></li>
<li><a href=#3网络延迟较大dial阻塞并超时>3、网络延迟较大，Dial阻塞并超时</a></li>
</ul>
</li>
<li><a href=#三socket读写>三、Socket读写</a>
<ul>
<li><a href=#1socket中无数据>1、Socket中无数据</a></li>
<li><a href=#2socket中有部分数据>2、Socket中有部分数据</a></li>
<li><a href=#3socket中有足够数据>3、Socket中有足够数据</a></li>
<li><a href=#4socket关闭>4、Socket关闭</a></li>
<li><a href=#5读取操作超时>5、读取操作超时</a></li>
<li><a href=#1成功写>1、成功写</a></li>
<li><a href=#2写阻塞>2、写阻塞</a></li>
<li><a href=#3写入部分数据>3、写入部分数据</a></li>
<li><a href=#4写入超时>4、写入超时</a></li>
<li><a href=#goroutine-safe>Goroutine safe</a></li>
</ul>
</li>
<li><a href=#四socket属性>四、Socket属性</a></li>
<li><a href=#五关闭连接>五、关闭连接</a></li>
<li><a href=#六小结>六、小结</a></li>
</ul>
</nav></div>
</div><div class=content id=content><p><code>转载文章</code></p>
<h1 id=go语言tcp-socket编程>Go语言TCP Socket编程</h1>
<p><strong>文章原始地址:</strong> <a href=http://tonybai.com/2015/11/17/tcp-programming-in-golang/ target=_blank rel="noopener noreffer">http://tonybai.com/2015/11/17/tcp-programming-in-golang/</a></p>
<p><a href=http://tonybai.com/tag/go target=_blank rel="noopener noreffer">Golang</a>的主要 设计目标之一就是面向大规模后端服务程序，网络通信这块是服务端 程序必不可少也是至关重要的一部分。在日常应用中，我们也可以看到Go中的net以及其subdirectories下的包均是“高频+刚需”，而TCP socket则是网络编程的主流，即便您没有直接使用到net中有关TCP Socket方面的接口，但net/http总是用到了吧，http底层依旧是用tcp socket实现的。</p>
<p>网络编程方面，我们最常用的就是tcp socket编程了，在posix标准出来后，socket在各大主流OS平台上都得到了很好的支持。关于tcp programming，最好的资料莫过于<a href=http://en.wikipedia.org/wiki/W._Richard_Stevens target=_blank rel="noopener noreffer">W. Richard Stevens</a> 的网络编程圣经《<a href=http://book.douban.com/subject/4859464/ target=_blank rel="noopener noreffer">UNIX网络 编程 卷1：套接字联网API</a>》 了，书中关于tcp socket接口的各种使用、行为模式、异常处理讲解的十分细致。Go是自带runtime的跨平台编程语言，Go中暴露给语言使用者的tcp socket api是建立OS原生tcp socket接口之上的。由于Go runtime调度的需要，golang tcp socket接口在行为特点与异常处理方面与OS原生接口有着一些差别。这篇博文的目标就是整理出关于Go tcp socket在各个场景下的使用方法、行为特点以及注意事项。</p>
<h2 id=一模型>一、模型</h2>
<p>从tcp socket诞生后，网络编程架构模型也几经演化，大致是：“每进程一个连接” –> “每线程一个连接” –> “Non-Block + I/O多路复用(linux epoll/windows iocp/freebsd darwin kqueue/solaris Event Port)”。伴随着模型的演化，服务程序愈加强大，可以支持更多的连接，获得更好的处理性能。</p>
<p>目前主流web server一般均采用的都是”Non-Block + I/O多路复用”（有的也结合了多线程、多进程）。不过I/O多路复用也给使用者带来了不小的复杂度，以至于后续出现了许多高性能的I/O多路复用框架， 比如<a href=http://libevent.org/ target=_blank rel="noopener noreffer">libevent</a>、<a href=http://software.schmorp.de/pkg/libev.html target=_blank rel="noopener noreffer">libev</a>、<a href=https://github.com/joyent/libuv target=_blank rel="noopener noreffer">libuv</a>等，以帮助开发者简化开发复杂性，降低心智负担。不过Go的设计者似乎认为I/O多路复用的这种通过回调机制割裂控制流 的方式依旧复杂，且有悖于“一般逻辑”设计，为此Go语言将该“复杂性”隐藏在Runtime中了：Go开发者无需关注socket是否是 non-block的，也无需亲自注册文件描述符的回调，只需在每个连接对应的goroutine中以**“block I/O”**的方式对待socket处理即可，这可以说大大降低了开发人员的心智负担。一个典型的Go server端程序大致如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>//go-tcpsock/server.go
</span><span class=c1></span><span class=kd>func</span> <span class=nf>handleConn</span><span class=p>(</span><span class=nx>c</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
    <span class=k>for</span> <span class=p>{</span>
        <span class=c1>// read from the connection
</span><span class=c1></span>        <span class=c1>// ... ...
</span><span class=c1></span>        <span class=c1>// write to the connection
</span><span class=c1></span>        <span class=c1>//... ...
</span><span class=c1></span>    <span class=p>}</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>l</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Listen</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;:8888&#34;</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;listen error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>

    <span class=k>for</span> <span class=p>{</span>
        <span class=nx>c</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>l</span><span class=p>.</span><span class=nf>Accept</span><span class=p>()</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;accept error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
            <span class=k>break</span>
        <span class=p>}</span>
        <span class=c1>// start a new goroutine to handle
</span><span class=c1></span>        <span class=c1>// the new connection.
</span><span class=c1></span>        <span class=k>go</span> <span class=nf>handleConn</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>用户层眼中看到的goroutine中的“block socket”，实际上是通过Go runtime中的netpoller通过Non-block socket + I/O多路复用机制“模拟”出来的，真实的underlying socket实际上是non-block的，只是runtime拦截了底层socket系统调用的错误码，并通过netpoller和goroutine 调度让goroutine“阻塞”在用户层得到的Socket fd上。比如：当用户层针对某个socket fd发起read操作时，如果该socket fd中尚无数据，那么runtime会将该socket fd加入到netpoller中监听，同时对应的goroutine被挂起，直到runtime收到socket fd 数据ready的通知，runtime才会重新唤醒等待在该socket fd上准备read的那个Goroutine。而这个过程从Goroutine的视角来看，就像是read操作一直block在那个socket fd上似的。具体实现细节在后续场景中会有补充描述。</p>
<h2 id=二tcp连接的建立>二、TCP连接的建立</h2>
<p>众所周知，TCP Socket的连接的建立需要经历客户端和服务端的三次握手的过程。连接建立过程中，服务端是一个标准的Listen + Accept的结构(可参考上面的代码)，而在客户端Go语言使用net.Dial或DialTimeout进行连接建立：</p>
<p>阻塞Dial：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Dial</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;google.com:80&#34;</span><span class=p>)</span>
<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=c1>//handle error
</span><span class=c1></span><span class=p>}</span>
<span class=c1>// read or write on conn
</span></code></pre></td></tr></table>
</div>
</div><p>或是带上超时机制的Dial：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>DialTimeout</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;:8080&#34;</span><span class=p>,</span> <span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=c1>//handle error
</span><span class=c1></span><span class=p>}</span>
<span class=c1>// read or write on conn
</span><span class=c1></span>
</code></pre></td></tr></table>
</div>
</div><p>对于客户端而言，连接的建立会遇到如下几种情形：</p>
<h3 id=1网络不可达或对方服务未启动>1、网络不可达或对方服务未启动</h3>
<p>如果传给Dial的Addr是可以立即判断出网络不可达，或者Addr中端口对应的服务没有启动，端口未被监听，Dial会几乎立即返回错误，比如：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>//go-tcpsock/conn_establish/client1.go
</span><span class=c1></span><span class=o>...</span> <span class=o>...</span>
<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;begin dial...&#34;</span><span class=p>)</span>
    <span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Dial</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;:8888&#34;</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;dial error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>
    <span class=k>defer</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;dial ok&#34;</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果本机8888端口未有服务程序监听，那么执行上面程序，Dial会很快返回错误：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=nv>$go</span> run client1.go
2015/11/16 14:37:41 begin dial...
2015/11/16 14:37:41 dial error: dial tcp :8888: getsockopt: connection refused
</code></pre></td></tr></table>
</div>
</div><h3 id=2对方服务的listen-backlog满>2、对方服务的listen backlog满</h3>
<p>还有一种场景就是对方服务器很忙，瞬间有大量client端连接尝试向server建立，server端的listen backlog队列满，server accept不及时((即便不accept，那么在backlog数量范畴里面，connect都会是成功的，因为new conn已经加入到server side的listen queue中了，accept只是从queue中取出一个conn而已)，这将导致client端Dial阻塞。我们还是通过例子感受Dial的行为特点：</p>
<p>服务端代码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>//go-tcpsock/conn_establish/server2.go
</span><span class=c1></span><span class=o>...</span> <span class=o>...</span>
<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>l</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Listen</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;:8888&#34;</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;error listen:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>
    <span class=k>defer</span> <span class=nx>l</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;listen ok&#34;</span><span class=p>)</span>

    <span class=kd>var</span> <span class=nx>i</span> <span class=kt>int</span>
    <span class=k>for</span> <span class=p>{</span>
        <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>10</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>l</span><span class=p>.</span><span class=nf>Accept</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;accept error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
            <span class=k>break</span>
        <span class=p>}</span>
        <span class=nx>i</span><span class=o>++</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d: accept a new connection\n&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>客户端代码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>//go-tcpsock/conn_establish/client2.go
</span><span class=c1></span><span class=o>...</span> <span class=o>...</span>
<span class=kd>func</span> <span class=nf>establishConn</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span> <span class=p>{</span>
    <span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Dial</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;:8888&#34;</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d: dial error: %s&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span> <span class=kc>nil</span>
    <span class=p>}</span>
    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=s>&#34;:connect to server ok&#34;</span><span class=p>)</span>
    <span class=k>return</span> <span class=nx>conn</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=kd>var</span> <span class=nx>sl</span> <span class=p>[]</span><span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>1000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=nx>conn</span> <span class=o>:=</span> <span class=nf>establishConn</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>conn</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>sl</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>sl</span><span class=p>,</span> <span class=nx>conn</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>10000</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>从程序可以看出，服务端在listen成功后，每隔10s钟accept一次。客户端则是串行的尝试建立连接。这两个程序在Darwin下的执行 结果：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=nv>$go</span> run server2.go
2015/11/16 21:55:41 listen ok
2015/11/16 21:55:51 1: accept a new connection
2015/11/16 21:56:01 2: accept a new connection
... ...

<span class=nv>$go</span> run client2.go
2015/11/16 21:55:44 <span class=m>1</span> :connect to server ok
2015/11/16 21:55:44 <span class=m>2</span> :connect to server ok
2015/11/16 21:55:44 <span class=m>3</span> :connect to server ok
... ...

2015/11/16 21:55:44 <span class=m>126</span> :connect to server ok
2015/11/16 21:55:44 <span class=m>127</span> :connect to server ok
2015/11/16 21:55:44 <span class=m>128</span> :connect to server ok

2015/11/16 21:55:52 <span class=m>129</span> :connect to server ok
2015/11/16 21:56:03 <span class=m>130</span> :connect to server ok
2015/11/16 21:56:14 <span class=m>131</span> :connect to server ok
... ...
</code></pre></td></tr></table>
</div>
</div><p>可以看出Client初始时成功地一次性建立了128个连接，然后后续每阻塞近10s才能成功建立一条连接。也就是说在server端 backlog满时(未及时accept)，客户端将阻塞在Dial上，直到server端进行一次accept。至于为什么是128，这与darwin 下的默认设置有关：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=nv>$sysctl</span> -a<span class=p>|</span>grep kern.ipc.somaxconn
kern.ipc.somaxconn: <span class=m>128</span>
</code></pre></td></tr></table>
</div>
</div><p>如果我在ubuntu 14.04上运行上述server程序，我们的client端初始可以成功建立499条连接。</p>
<p>如果server一直不accept，client端会一直阻塞么？我们去掉accept后的结果是：在Darwin下，client端会阻塞大 约1分多钟才会返回timeout：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell>2015/11/16 22:03:31 <span class=m>128</span> :connect to server ok
2015/11/16 22:04:48 129: dial error: dial tcp :8888: getsockopt: operation timed out
</code></pre></td></tr></table>
</div>
</div><p>而如果server运行在ubuntu 14.04上，client似乎一直阻塞，我等了10多分钟依旧没有返回。 阻塞与否看来与server端的网络实现和设置有关。</p>
<h3 id=3网络延迟较大dial阻塞并超时>3、网络延迟较大，Dial阻塞并超时</h3>
<p>如果网络延迟较大，TCP握手过程将更加艰难坎坷（各种丢包），时间消耗的自然也会更长。Dial这时会阻塞，如果长时间依旧无法建立连接，则Dial也会返回“ getsockopt: operation timed out”错误。</p>
<p>在连接建立阶段，多数情况下，Dial是可以满足需求的，即便阻塞一小会儿。但对于某些程序而言，需要有严格的连接时间限定，如果一定时间内没能成功建立连接，程序可能会需要执行一段“异常”处理逻辑，为此我们就需要DialTimeout了。下面的例子将Dial的最长阻塞时间限制在2s内，超出这个时长，Dial将返回timeout error：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>//go-tcpsock/conn_establish/client3.go
</span><span class=c1></span><span class=o>...</span> <span class=o>...</span>
<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;begin dial...&#34;</span><span class=p>)</span>
    <span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>DialTimeout</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;104.236.176.96:80&#34;</span><span class=p>,</span> <span class=mi>2</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;dial error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>
    <span class=k>defer</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;dial ok&#34;</span><span class=p>)</span>
<span class=p>}</span>

</code></pre></td></tr></table>
</div>
</div><p>执行结果如下（需要模拟一个延迟较大的网络环境）：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=nv>$go</span> run client3.go
2015/11/17 09:28:34 begin dial...
2015/11/17 09:28:36 dial error: dial tcp 104.236.176.96:80: i/o timeout
</code></pre></td></tr></table>
</div>
</div><h2 id=三socket读写>三、Socket读写</h2>
<p>连接建立起来后，我们就要在conn上进行读写，以完成业务逻辑。前面说过Go runtime隐藏了I/O多路复用的复杂性。语言使用者只需采用goroutine+Block I/O的模式即可满足大部分场景需求。Dial成功后，方法返回一个net.Conn接口类型变量值，这个接口变量的动态类型为一个*TCPConn：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>//$GOROOT/src/net/tcpsock_posix.go
</span><span class=c1></span><span class=kd>type</span> <span class=nx>TCPConn</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>conn</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>TCPConn内嵌了一个unexported类型：conn，因此TCPConn”继承”了conn的Read和Write方法，后续通过Dial返回值调用的Write和Read方法均是net.conn的方法：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>//$GOROOT/src/net/net.go
</span><span class=c1></span><span class=kd>type</span> <span class=nx>conn</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>fd</span> <span class=o>*</span><span class=nx>netFD</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>conn</span><span class=p>)</span> <span class=nf>ok</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>c</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>c</span><span class=p>.</span><span class=nx>fd</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>}</span>

<span class=c1>// Implementation of the Conn interface.
</span><span class=c1></span>
<span class=c1>// Read implements the Conn Read method.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>conn</span><span class=p>)</span> <span class=nf>Read</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>!</span><span class=nx>c</span><span class=p>.</span><span class=nf>ok</span><span class=p>()</span> <span class=p>{</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>EINVAL</span>
    <span class=p>}</span>
    <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>fd</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>err</span> <span class=o>!=</span> <span class=nx>io</span><span class=p>.</span><span class=nx>EOF</span> <span class=p>{</span>
        <span class=nx>err</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>OpError</span><span class=p>{</span><span class=nx>Op</span><span class=p>:</span> <span class=s>&#34;read&#34;</span><span class=p>,</span> <span class=nx>Net</span><span class=p>:</span> <span class=nx>c</span><span class=p>.</span><span class=nx>fd</span><span class=p>.</span><span class=nx>net</span><span class=p>,</span> <span class=nx>Source</span><span class=p>:</span> <span class=nx>c</span><span class=p>.</span><span class=nx>fd</span><span class=p>.</span><span class=nx>laddr</span><span class=p>,</span> <span class=nx>Addr</span><span class=p>:</span> <span class=nx>c</span><span class=p>.</span><span class=nx>fd</span><span class=p>.</span><span class=nx>raddr</span><span class=p>,</span> <span class=nx>Err</span><span class=p>:</span> <span class=nx>err</span><span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span>
<span class=p>}</span>

<span class=c1>// Write implements the Conn Write method.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>conn</span><span class=p>)</span> <span class=nf>Write</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>!</span><span class=nx>c</span><span class=p>.</span><span class=nf>ok</span><span class=p>()</span> <span class=p>{</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>EINVAL</span>
    <span class=p>}</span>
    <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>fd</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>err</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>OpError</span><span class=p>{</span><span class=nx>Op</span><span class=p>:</span> <span class=s>&#34;write&#34;</span><span class=p>,</span> <span class=nx>Net</span><span class=p>:</span> <span class=nx>c</span><span class=p>.</span><span class=nx>fd</span><span class=p>.</span><span class=nx>net</span><span class=p>,</span> <span class=nx>Source</span><span class=p>:</span> <span class=nx>c</span><span class=p>.</span><span class=nx>fd</span><span class=p>.</span><span class=nx>laddr</span><span class=p>,</span> <span class=nx>Addr</span><span class=p>:</span> <span class=nx>c</span><span class=p>.</span><span class=nx>fd</span><span class=p>.</span><span class=nx>raddr</span><span class=p>,</span> <span class=nx>Err</span><span class=p>:</span> <span class=nx>err</span><span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>下面我们先来通过几个场景来总结一下conn.Read的行为特点。</p>
<h3 id=1socket中无数据>1、Socket中无数据</h3>
<p>连接建立后，如果对方未发送数据到socket，接收方(Server)会阻塞在Read操作上，这和前面提到的“模型”原理是一致的。执行该Read操作的goroutine也会被挂起。runtime会监视该socket，直到其有数据才会重新
调度该socket对应的Goroutine完成read。由于篇幅原因，这里就不列代码了，例子对应的代码文件：go-tcpsock/read_write下的client1.go和server1.go。</p>
<h3 id=2socket中有部分数据>2、Socket中有部分数据</h3>
<p>如果socket中有部分数据，且长度小于一次Read操作所期望读出的数据长度，那么Read将会成功读出这部分数据并返回，而不是等待所有期望数据全部读取后再返回。</p>
<p>Client端：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>//go-tcpsock/read_write/client2.go
</span><span class=c1></span><span class=o>...</span> <span class=o>...</span>
<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;usage: go run client2.go YOUR_CONTENT&#34;</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>
    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;begin dial...&#34;</span><span class=p>)</span>
    <span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Dial</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;:8888&#34;</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;dial error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>
    <span class=k>defer</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;dial ok&#34;</span><span class=p>)</span>

    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)</span>
    <span class=nx>data</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
    <span class=nx>conn</span><span class=p>.</span><span class=nf>Write</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>data</span><span class=p>))</span>

    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>10000</span><span class=p>)</span>
<span class=p>}</span>

</code></pre></td></tr></table>
</div>
</div><p>Server端：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>//go-tcpsock/read_write/server2.go
</span><span class=c1></span><span class=o>...</span> <span class=o>...</span>
<span class=kd>func</span> <span class=nf>handleConn</span><span class=p>(</span><span class=nx>c</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
    <span class=k>for</span> <span class=p>{</span>
        <span class=c1>// read from the connection
</span><span class=c1></span>        <span class=kd>var</span> <span class=nx>buf</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;start to read from conn&#34;</span><span class=p>)</span>
        <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>buf</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;conn read error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
            <span class=k>return</span>
        <span class=p>}</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;read %d bytes, content is %s\n&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=p>,</span> <span class=nb>string</span><span class=p>(</span><span class=nx>buf</span><span class=p>[:</span><span class=nx>n</span><span class=p>]))</span>
    <span class=p>}</span>
<span class=p>}</span>
<span class=o>...</span> <span class=o>...</span>

</code></pre></td></tr></table>
</div>
</div><p>我们通过<code>client2.go</code>发送”hi”到Server端：
运行结果:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=nv>$go</span> run client2.go hi
2015/11/17 13:30:53 begin dial...
2015/11/17 13:30:53 dial ok

<span class=nv>$go</span> run server2.go
2015/11/17 13:33:45 accept a new connection
2015/11/17 13:33:45 start to <span class=nb>read</span> from conn
2015/11/17 13:33:47 <span class=nb>read</span> <span class=m>2</span> bytes, content is hi
...
</code></pre></td></tr></table>
</div>
</div><p>Client向socket中写入两个字节数据(“hi”)，Server端创建一个len = 10的slice，等待Read将读取的数据放入slice；Server随后读取到那两个字节：”hi”。Read成功返回，n =2 ，err = nil。</p>
<h3 id=3socket中有足够数据>3、Socket中有足够数据</h3>
<p>如果socket中有数据，且长度大于等于一次Read操作所期望读出的数据长度，那么Read将会成功读出这部分数据并返回。这个情景是最符合我们对Read的期待的了：Read将用Socket中的数据将我们传入的slice填满后返回：n = 10, err = nil。</p>
<p>我们通过client2.go向Server2发送如下内容：abcdefghij12345，执行结果如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=nv>$go</span> run client2.go abcdefghij12345
2015/11/17 13:38:00 begin dial...
2015/11/17 13:38:00 dial ok

<span class=nv>$go</span> run server2.go
2015/11/17 13:38:00 accept a new connection
2015/11/17 13:38:00 start to <span class=nb>read</span> from conn
2015/11/17 13:38:02 <span class=nb>read</span> <span class=m>10</span> bytes, content is abcdefghij
2015/11/17 13:38:02 start to <span class=nb>read</span> from conn
2015/11/17 13:38:02 <span class=nb>read</span> <span class=m>5</span> bytes, content is <span class=m>12345</span>
</code></pre></td></tr></table>
</div>
</div><p>client端发送的内容长度为15个字节，Server端Read buffer的长度为10，因此Server Read第一次返回时只会读取10个字节；Socket中还剩余5个字节数据，Server再次Read时会把剩余数据读出（如：情形2）。</p>
<h3 id=4socket关闭>4、Socket关闭</h3>
<p>如果client端主动关闭了socket，那么Server的Read将会读到什么呢？这里分为“有数据关闭”和“无数据关闭”。</p>
<p>“有数据关闭”是指在client关闭时，socket中还有server端未读取的数据，我们在go-tcpsock/read_write/client3.go和server3.go中模拟这种情况：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=nv>$go</span> run client3.go hello
2015/11/17 13:50:57 begin dial...
2015/11/17 13:50:57 dial ok

<span class=nv>$go</span> run server3.go
2015/11/17 13:50:57 accept a new connection
2015/11/17 13:51:07 start to <span class=nb>read</span> from conn
2015/11/17 13:51:07 <span class=nb>read</span> <span class=m>5</span> bytes, content is hello
2015/11/17 13:51:17 start to <span class=nb>read</span> from conn
2015/11/17 13:51:17 conn <span class=nb>read</span> error: EOF
</code></pre></td></tr></table>
</div>
</div><p>从输出结果来看，当client端close socket退出后，server3依旧没有开始Read，10s后第一次Read成功读出了5个字节的数据，当第二次Read时，由于client端 socket关闭，Read返回EOF error。</p>
<p>通过上面这个例子，我们也可以猜测出“无数据关闭”情形下的结果，那就是Read直接返回EOF error。</p>
<h3 id=5读取操作超时>5、读取操作超时</h3>
<p>有些场合对Read的阻塞时间有严格限制，在这种情况下，Read的行为到底是什么样的呢？在返回超时错误时，是否也同时Read了一部分数据了呢？这个实验比较难于模拟，下面的测试结果也未必能反映出所有可能结果。我们编写了<code>client4.go</code>和<code>server4.go</code>来模拟这一情形。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>//go-tcpsock/read_write/client4.go
</span><span class=c1></span><span class=o>...</span> <span class=o>...</span>
<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;begin dial...&#34;</span><span class=p>)</span>
    <span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Dial</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;:8888&#34;</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;dial error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>
    <span class=k>defer</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;dial ok&#34;</span><span class=p>)</span>

    <span class=nx>data</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>65536</span><span class=p>)</span>
    <span class=nx>conn</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>

    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>10000</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1>//go-tcpsock/read_write/server4.go
</span><span class=c1></span><span class=o>...</span> <span class=o>...</span>
<span class=kd>func</span> <span class=nf>handleConn</span><span class=p>(</span><span class=nx>c</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
    <span class=k>for</span> <span class=p>{</span>
        <span class=c1>// read from the connection
</span><span class=c1></span>        <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
        <span class=kd>var</span> <span class=nx>buf</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>65536</span><span class=p>)</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;start to read from conn&#34;</span><span class=p>)</span>
        <span class=nx>c</span><span class=p>.</span><span class=nf>SetReadDeadline</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Microsecond</span> <span class=o>*</span> <span class=mi>10</span><span class=p>))</span>
        <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>buf</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;conn read %d bytes,  error: %s&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
            <span class=k>if</span> <span class=nx>nerr</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>err</span><span class=p>.(</span><span class=nx>net</span><span class=p>.</span><span class=nx>Error</span><span class=p>);</span> <span class=nx>ok</span> <span class=o>&amp;&amp;</span> <span class=nx>nerr</span><span class=p>.</span><span class=nf>Timeout</span><span class=p>()</span> <span class=p>{</span>
                <span class=k>continue</span>
            <span class=p>}</span>
            <span class=k>return</span>
        <span class=p>}</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;read %d bytes, content is %s\n&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=p>,</span> <span class=nb>string</span><span class=p>(</span><span class=nx>buf</span><span class=p>[:</span><span class=nx>n</span><span class=p>]))</span>
    <span class=p>}</span>
<span class=p>}</span>

</code></pre></td></tr></table>
</div>
</div><p>在Server端我们通过Conn的SetReadDeadline方法设置了10微秒的读超时时间，Server的执行结果如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=nv>$go</span> run server4.go

2015/11/17 14:21:17 accept a new connection
2015/11/17 14:21:27 start to <span class=nb>read</span> from conn
2015/11/17 14:21:27 conn <span class=nb>read</span> <span class=m>0</span> bytes,  error: <span class=nb>read</span> tcp 127.0.0.1:8888-&gt;127.0.0.1:60970: i/o timeout
2015/11/17 14:21:37 start to <span class=nb>read</span> from conn
2015/11/17 14:21:37 <span class=nb>read</span> <span class=m>65536</span> bytes, content is

</code></pre></td></tr></table>
</div>
</div><p>虽然每次都是10微秒超时，但结果不同，第一次Read超时，读出数据长度为0；第二次读取所有数据成功，没有超时。反复执行了多次，没能出现“读出部分数据且返回超时错误”的情况。</p>
<p>和读相比，Write遇到的情形一样不少，我们也逐一看一下。</p>
<h3 id=1成功写>1、成功写</h3>
<p>前面例子着重于Read，client端在Write时并未判断Write的返回值。所谓“成功写”指的就是Write调用返回的n与预期要写入的数据长度相等，且error = nil。这是我们在调用Write时遇到的最常见的情形，这里不再举例了。</p>
<h3 id=2写阻塞>2、写阻塞</h3>
<p>TCP连接通信两端的OS都会为该连接保留数据缓冲，一端调用Write后，实际上数据是写入到OS的协议栈的数据缓冲的。TCP是全双工通信，因此每个方向都有独立的数据缓冲。当发送方将对方的接收缓冲区以及自身的发送缓冲区写满后，Write就会阻塞。我们来看一个例子：client5.go和server.go。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>//go-tcpsock/read_write/client5.go
</span><span class=c1></span><span class=o>...</span> <span class=o>...</span>
<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;begin dial...&#34;</span><span class=p>)</span>
    <span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Dial</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;:8888&#34;</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;dial error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>
    <span class=k>defer</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;dial ok&#34;</span><span class=p>)</span>

    <span class=nx>data</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>65536</span><span class=p>)</span>
    <span class=kd>var</span> <span class=nx>total</span> <span class=kt>int</span>
    <span class=k>for</span> <span class=p>{</span>
        <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>total</span> <span class=o>+=</span> <span class=nx>n</span>
            <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;write %d bytes, error:%s\n&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
            <span class=k>break</span>
        <span class=p>}</span>
        <span class=nx>total</span> <span class=o>+=</span> <span class=nx>n</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;write %d bytes this time, %d bytes in total\n&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>total</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;write %d bytes in total\n&#34;</span><span class=p>,</span> <span class=nx>total</span><span class=p>)</span>
    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>10000</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1>//go-tcpsock/read_write/server5.go
</span><span class=c1></span><span class=o>...</span> <span class=o>...</span>
<span class=kd>func</span> <span class=nf>handleConn</span><span class=p>(</span><span class=nx>c</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>10</span><span class=p>)</span>
    <span class=k>for</span> <span class=p>{</span>
        <span class=c1>// read from the connection
</span><span class=c1></span>        <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>5</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
        <span class=kd>var</span> <span class=nx>buf</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>60000</span><span class=p>)</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;start to read from conn&#34;</span><span class=p>)</span>
        <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>buf</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;conn read %d bytes,  error: %s&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
            <span class=k>if</span> <span class=nx>nerr</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>err</span><span class=p>.(</span><span class=nx>net</span><span class=p>.</span><span class=nx>Error</span><span class=p>);</span> <span class=nx>ok</span> <span class=o>&amp;&amp;</span> <span class=nx>nerr</span><span class=p>.</span><span class=nf>Timeout</span><span class=p>()</span> <span class=p>{</span>
                <span class=k>continue</span>
            <span class=p>}</span>
        <span class=p>}</span>

        <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;read %d bytes, content is %s\n&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=p>,</span> <span class=nb>string</span><span class=p>(</span><span class=nx>buf</span><span class=p>[:</span><span class=nx>n</span><span class=p>]))</span>
    <span class=p>}</span>
<span class=p>}</span>
<span class=o>...</span> <span class=o>...</span>
</code></pre></td></tr></table>
</div>
</div><p>Server5在前10s中并不Read数据，因此当client5一直尝试写入时，写到一定量后就会发生阻塞：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=nv>$go</span> run client5.go

2015/11/17 14:57:33 begin dial...
2015/11/17 14:57:33 dial ok
2015/11/17 14:57:33 write <span class=m>65536</span> bytes this time, <span class=m>65536</span> bytes in total
2015/11/17 14:57:33 write <span class=m>65536</span> bytes this time, <span class=m>131072</span> bytes in total
2015/11/17 14:57:33 write <span class=m>65536</span> bytes this time, <span class=m>196608</span> bytes in total
2015/11/17 14:57:33 write <span class=m>65536</span> bytes this time, <span class=m>262144</span> bytes in total
2015/11/17 14:57:33 write <span class=m>65536</span> bytes this time, <span class=m>327680</span> bytes in total
2015/11/17 14:57:33 write <span class=m>65536</span> bytes this time, <span class=m>393216</span> bytes in total
2015/11/17 14:57:33 write <span class=m>65536</span> bytes this time, <span class=m>458752</span> bytes in total
2015/11/17 14:57:33 write <span class=m>65536</span> bytes this time, <span class=m>524288</span> bytes in total
2015/11/17 14:57:33 write <span class=m>65536</span> bytes this time, <span class=m>589824</span> bytes in total
2015/11/17 14:57:33 write <span class=m>65536</span> bytes this time, <span class=m>655360</span> bytes in total

</code></pre></td></tr></table>
</div>
</div><p>在Darwin上，这个size大约在679468bytes。后续当server5每隔5s进行Read时，OS socket缓冲区腾出了空间，client5就又可以写入了：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=nv>$go</span> run server5.go
2015/11/17 15:07:01 accept a new connection
2015/11/17 15:07:16 start to <span class=nb>read</span> from conn
2015/11/17 15:07:16 <span class=nb>read</span> <span class=m>60000</span> bytes, content is
2015/11/17 15:07:21 start to <span class=nb>read</span> from conn
2015/11/17 15:07:21 <span class=nb>read</span> <span class=m>60000</span> bytes, content is
2015/11/17 15:07:26 start to <span class=nb>read</span> from conn
2015/11/17 15:07:26 <span class=nb>read</span> <span class=m>60000</span> bytes, content is
....

client端：

2015/11/17 15:07:01 write <span class=m>65536</span> bytes this time, <span class=m>720896</span> bytes in total
2015/11/17 15:07:06 write <span class=m>65536</span> bytes this time, <span class=m>786432</span> bytes in total
2015/11/17 15:07:16 write <span class=m>65536</span> bytes this time, <span class=m>851968</span> bytes in total
2015/11/17 15:07:16 write <span class=m>65536</span> bytes this time, <span class=m>917504</span> bytes in total
2015/11/17 15:07:27 write <span class=m>65536</span> bytes this time, <span class=m>983040</span> bytes in total
2015/11/17 15:07:27 write <span class=m>65536</span> bytes this time, <span class=m>1048576</span> bytes in total
.... ...

</code></pre></td></tr></table>
</div>
</div><h3 id=3写入部分数据>3、写入部分数据</h3>
<p>Write操作存在写入部分数据的情况，比如上面例子中，当client端输出日志停留在“write 65536 bytes this time, 655360 bytes in total”时，我们杀掉server5，这时我们会看到client5输出以下日志：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell>...
2015/11/17 15:19:14 write <span class=m>65536</span> bytes this time, <span class=m>655360</span> bytes in total
2015/11/17 15:19:16 write <span class=m>24108</span> bytes, error:write tcp 127.0.0.1:62245-&gt;127.0.0.1:8888: write: broken pipe
2015/11/17 15:19:16 write <span class=m>679468</span> bytes in total
</code></pre></td></tr></table>
</div>
</div><p>显然Write并非在655360这个地方阻塞的，而是后续又写入24108后发生了阻塞，server端socket关闭后，我们看到Wrote返回er != nil且n = 24108，程序需要对这部分写入的24108字节做特定处理。</p>
<h3 id=4写入超时>4、写入超时</h3>
<p>如果非要给Write增加一个期限，那我们可以调用SetWriteDeadline方法。我们copy一份client5.go，形成client6.go，在client6.go的Write之前增加一行timeout设置代码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=nx>conn</span><span class=p>.</span><span class=nf>SetWriteDeadline</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Microsecond</span> <span class=o>*</span> <span class=mi>10</span><span class=p>))</span>
</code></pre></td></tr></table>
</div>
</div><p>启动server6.go，启动client6.go，我们可以看到写入超时的情况下，Write的返回结果：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=nv>$go</span> run client6.go
2015/11/17 15:26:34 begin dial...
2015/11/17 15:26:34 dial ok
2015/11/17 15:26:34 write <span class=m>65536</span> bytes this time, <span class=m>65536</span> bytes in total
... ...
2015/11/17 15:26:34 write <span class=m>65536</span> bytes this time, <span class=m>655360</span> bytes in total
2015/11/17 15:26:34 write <span class=m>24108</span> bytes, error:write tcp 127.0.0.1:62325-&gt;127.0.0.1:8888: i/o timeout
2015/11/17 15:26:34 write <span class=m>679468</span> bytes in total
</code></pre></td></tr></table>
</div>
</div><p>可以看到在写入超时时，依旧存在部分数据写入的情况。</p>
<p>综上例子，虽然Go给我们提供了阻塞I/O的便利，但在调用Read和Write时依旧要综合需要方法返回的n和err的结果，以做出正确处理。net.conn实现了io.Reader和io.Writer接口，因此可以试用一些wrapper包进行socket读写，比如bufio包下面的Writer和Reader、io/ioutil下的函数等。</p>
<h3 id=goroutine-safe>Goroutine safe</h3>
<p>基于goroutine的网络架构模型，存在在不同goroutine间共享conn的情况，那么conn的读写是否是goroutine safe的呢？在深入这个问题之前，我们先从应用意义上来看read操作和write操作的goroutine-safe必要性。</p>
<p>对于read操作而言，由于TCP是面向字节流，conn.Read无法正确区分数据的业务边界，因此多个goroutine对同一个conn进行read的意义不大，goroutine读到不完整的业务包反倒是增加了业务处理的难度。对与Write操作而言，倒是有多个goroutine并发写的情况。不过conn读写是否goroutine-safe的测试不是很好做，我们先深入一下runtime代码，先从理论上给这个问题定个性：</p>
<p>net.conn只是*netFD的wrapper结构，最终Write和Read都会落在其中的fd上：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>type conn struct {
    fd *netFD
}

</code></pre></td></tr></table>
</div>
</div><p>netFD在不同平台上有着不同的实现，我们以net/fd_unix.go中的netFD为例：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>// Network file descriptor.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>netFD</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=c1>// locking/lifetime of sysfd + serialize access to Read and Write methods
</span><span class=c1></span>    <span class=nx>fdmu</span> <span class=nx>fdMutex</span>

    <span class=c1>// immutable until Close
</span><span class=c1></span>    <span class=nx>sysfd</span>       <span class=kt>int</span>
    <span class=nx>family</span>      <span class=kt>int</span>
    <span class=nx>sotype</span>      <span class=kt>int</span>
    <span class=nx>isConnected</span> <span class=kt>bool</span>
    <span class=nx>net</span>         <span class=kt>string</span>
    <span class=nx>laddr</span>       <span class=nx>Addr</span>
    <span class=nx>raddr</span>       <span class=nx>Addr</span>

    <span class=c1>// wait server
</span><span class=c1></span>    <span class=nx>pd</span> <span class=nx>pollDesc</span>
<span class=p>}</span>

</code></pre></td></tr></table>
</div>
</div><p>我们看到netFD中包含了一个runtime实现的fdMutex类型字段，从注释上来看，该fdMutex用来串行化对该netFD对应的sysfd的Write和Read操作。从这个注释上来看，所有对conn的Read和Write操作都是有fdMutex互斥的，从netFD的Read和Write方法的实现也证实了这一点：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>fd</span> <span class=o>*</span><span class=nx>netFD</span><span class=p>)</span> <span class=nf>Read</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>fd</span><span class=p>.</span><span class=nf>readLock</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>err</span>
    <span class=p>}</span>
    <span class=k>defer</span> <span class=nx>fd</span><span class=p>.</span><span class=nf>readUnlock</span><span class=p>()</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>fd</span><span class=p>.</span><span class=nx>pd</span><span class=p>.</span><span class=nf>PrepareRead</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>err</span>
    <span class=p>}</span>
    <span class=k>for</span> <span class=p>{</span>
        <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>fd</span><span class=p>.</span><span class=nx>sysfd</span><span class=p>,</span> <span class=nx>p</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>n</span> <span class=p>=</span> <span class=mi>0</span>
            <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>EAGAIN</span> <span class=p>{</span>
                <span class=k>if</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>fd</span><span class=p>.</span><span class=nx>pd</span><span class=p>.</span><span class=nf>WaitRead</span><span class=p>();</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
                    <span class=k>continue</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>
        <span class=nx>err</span> <span class=p>=</span> <span class=nx>fd</span><span class=p>.</span><span class=nf>eofError</span><span class=p>(</span><span class=nx>n</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
        <span class=k>break</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>err</span><span class=p>.(</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>Errno</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
        <span class=nx>err</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>NewSyscallError</span><span class=p>(</span><span class=s>&#34;read&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>fd</span> <span class=o>*</span><span class=nx>netFD</span><span class=p>)</span> <span class=nf>Write</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>nn</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>fd</span><span class=p>.</span><span class=nf>writeLock</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>err</span>
    <span class=p>}</span>
    <span class=k>defer</span> <span class=nx>fd</span><span class=p>.</span><span class=nf>writeUnlock</span><span class=p>()</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>fd</span><span class=p>.</span><span class=nx>pd</span><span class=p>.</span><span class=nf>PrepareWrite</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>err</span>
    <span class=p>}</span>
    <span class=k>for</span> <span class=p>{</span>
        <span class=kd>var</span> <span class=nx>n</span> <span class=kt>int</span>
        <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>fd</span><span class=p>.</span><span class=nx>sysfd</span><span class=p>,</span> <span class=nx>p</span><span class=p>[</span><span class=nx>nn</span><span class=p>:])</span>
        <span class=k>if</span> <span class=nx>n</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
            <span class=nx>nn</span> <span class=o>+=</span> <span class=nx>n</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=nx>nn</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=nx>p</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>break</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>EAGAIN</span> <span class=p>{</span>
            <span class=k>if</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>fd</span><span class=p>.</span><span class=nx>pd</span><span class=p>.</span><span class=nf>WaitWrite</span><span class=p>();</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
                <span class=k>continue</span>
            <span class=p>}</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>break</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=nx>n</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
            <span class=nx>err</span> <span class=p>=</span> <span class=nx>io</span><span class=p>.</span><span class=nx>ErrUnexpectedEOF</span>
            <span class=k>break</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>err</span><span class=p>.(</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>Errno</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
        <span class=nx>err</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>NewSyscallError</span><span class=p>(</span><span class=s>&#34;write&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>nn</span><span class=p>,</span> <span class=nx>err</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>每次Write操作都是受lock保护，直到此次数据全部write完。因此在应用层面，要想保证多个goroutine在一个conn上write操作的Safe，需要一次write完整写入一个“业务包”；一旦将业务包的写入拆分为多次write，那就无法保证某个Goroutine的某“业务包”数据在conn发送的连续性。</p>
<p>同时也可以看出即便是Read操作，也是lock保护的。多个Goroutine对同一conn的并发读不会出现读出内容重叠的情况，但内容断点是依 runtime调度来随机确定的。存在一个业务包数据，1/3内容被goroutine-1读走，另外2/3被另外一个goroutine-2读 走的情况。比如一个完整包：world，当goroutine的read slice size &lt; 5时，存在可能：一个goroutine读到 “worl”,另外一个goroutine读出”d”。</p>
<h2 id=四socket属性>四、Socket属性</h2>
<p>原生Socket API提供了丰富的sockopt设置接口，但Golang有自己的网络架构模型，golang提供的socket options接口也是基于上述模型的必要的属性设置。包括</p>
<ul>
<li>SetKeepAlive</li>
<li>SetKeepAlivePeriod</li>
<li>SetLinger</li>
<li>SetNoDelay （默认no delay）</li>
<li>SetWriteBuffer</li>
<li>SetReadBuffer</li>
</ul>
<p>不过上面的Method是TCPConn的，而不是Conn的，要使用上面的Method的，需要type assertion：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=nx>tcpConn</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.(</span><span class=o>*</span><span class=nx>TCPConn</span><span class=p>)</span>
<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
    <span class=c1>//error handle
</span><span class=c1></span><span class=p>}</span>

<span class=nx>tcpConn</span><span class=p>.</span><span class=nf>SetNoDelay</span><span class=p>(</span><span class=kc>true</span><span class=p>)</span>
</code></pre></td></tr></table>
</div>
</div><p>对于listener socket, golang默认采用了 SO_REUSEADDR，这样当你重启 listener程序时，不会因为address in use的错误而启动失败。而listen backlog的默认值是通过获取系统的设置值得到的。不同系统不同：mac 128, linux 512等。</p>
<h2 id=五关闭连接>五、关闭连接</h2>
<p>和前面的方法相比，关闭连接算是最简单的操作了。由于socket是全双工的，client和server端在己方已关闭的socket和对方关闭的socket上操作的结果有不同。看下面例子：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>//go-tcpsock/conn_close/client1.go
</span><span class=c1></span><span class=o>...</span> <span class=o>...</span>
<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;begin dial...&#34;</span><span class=p>)</span>
    <span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Dial</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;:8888&#34;</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;dial error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>
    <span class=nx>conn</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;close ok&#34;</span><span class=p>)</span>

    <span class=kd>var</span> <span class=nx>buf</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>32</span><span class=p>)</span>
    <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>buf</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;read error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;read % bytes, content is %s\n&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=p>,</span> <span class=nb>string</span><span class=p>(</span><span class=nx>buf</span><span class=p>[:</span><span class=nx>n</span><span class=p>]))</span>
    <span class=p>}</span>

    <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>buf</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;write error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;write % bytes, content is %s\n&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=p>,</span> <span class=nb>string</span><span class=p>(</span><span class=nx>buf</span><span class=p>[:</span><span class=nx>n</span><span class=p>]))</span>
    <span class=p>}</span>

    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>1000</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1>//go-tcpsock/conn_close/server1.go
</span><span class=c1></span><span class=o>...</span> <span class=o>...</span>
<span class=kd>func</span> <span class=nf>handleConn</span><span class=p>(</span><span class=nx>c</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>

    <span class=c1>// read from the connection
</span><span class=c1></span>    <span class=kd>var</span> <span class=nx>buf</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;start to read from conn&#34;</span><span class=p>)</span>
    <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>buf</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;conn read error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;read %d bytes, content is %s\n&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=p>,</span> <span class=nb>string</span><span class=p>(</span><span class=nx>buf</span><span class=p>[:</span><span class=nx>n</span><span class=p>]))</span>
    <span class=p>}</span>

    <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>buf</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;conn write error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;write %d bytes, content is %s\n&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=p>,</span> <span class=nb>string</span><span class=p>(</span><span class=nx>buf</span><span class=p>[:</span><span class=nx>n</span><span class=p>]))</span>
    <span class=p>}</span>
<span class=p>}</span>
<span class=o>...</span> <span class=o>...</span>

</code></pre></td></tr></table>
</div>
</div><p>上述例子的执行结果如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=nv>$go</span> run server1.go
2015/11/17 17:00:51 accept a new connection
2015/11/17 17:00:51 start to <span class=nb>read</span> from conn
2015/11/17 17:00:51 conn <span class=nb>read</span> error: EOF
2015/11/17 17:00:51 write <span class=m>10</span> bytes, content is

<span class=nv>$go</span> run client1.go
2015/11/17 17:00:51 begin dial...
2015/11/17 17:00:51 close ok
2015/11/17 17:00:51 <span class=nb>read</span> error: <span class=nb>read</span> tcp 127.0.0.1:64195-&gt;127.0.0.1:8888: use of closed network connection
2015/11/17 17:00:51 write error: write tcp 127.0.0.1:64195-&gt;127.0.0.1:8888: use of closed network connection
</code></pre></td></tr></table>
</div>
</div><p>从client1的结果来看，在己方已经关闭的socket上再进行read和write操作，会得到”use of closed network connection” error；
从server1的执行结果来看，在对方关闭的socket上执行read操作会得到EOF error，但write操作会成功，因为数据会成功写入己方的内核socket缓冲区中，即便最终发不到对方socket缓冲区了，因为己方socket并未关闭。因此当发现对方socket关闭后，己方应该正确合理处理自己的socket，再继续write已经无任何意义了。</p>
<h2 id=六小结>六、小结</h2>
<p>本文比较基础，但却很重要，毕竟golang是面向大规模服务后端的，对通信环节的细节的深入理解会大有裨益。另外Go的goroutine+阻塞通信的网络通信模型降低了开发者心智负担，简化了通信的复杂性，这点尤为重要。</p>
<p>本文代码实验环境：go 1.5.1 on Darwin amd64以及部分在ubuntu 14.04 amd64。</p>
<p>本文demo代码在<a href=https://github.com/bigwhite/experiments/tree/master/go-tcpsock target=_blank rel="noopener noreffer">这里</a>可以找到。</p>
<p>© 2015, <a href=http://tonybai.com/ target=_blank rel="noopener noreffer">bigwhite</a>. 版权所有.</p>
</div><div class=post-footer id=post-footer>
<div class=post-info>
<div class=post-info-line>
<div class=post-info-mod>
<span>更新于 2021-11-22</span>
</div>
<div class=post-info-license></div>
</div>
<div class=post-info-line>
<div class=post-info-md><span>
<a class=link-to-markdown href=/posts/go-tcp/index.md target=_blank>阅读原始文档</a>
</span></div>
<div class=post-info-share>
<span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://yusank.github.io/posts/go-tcp/ data-title="Go TCP Socket" data-hashtags=go,tcp><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://yusank.github.io/posts/go-tcp/ data-hashtag=go><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://yusank.github.io/posts/go-tcp/><i class="fab fa-linkedin fa-fw"></i></a><a href=javascript:void(0); title="分享到 WhatsApp" data-sharer=whatsapp data-url=https://yusank.github.io/posts/go-tcp/ data-title="Go TCP Socket" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://yusank.github.io/posts/go-tcp/ data-title="Go TCP Socket"><i class="fab fa-hacker-news fa-fw"></i></a><a href=javascript:void(0); title="分享到 Reddit" data-sharer=reddit data-url=https://yusank.github.io/posts/go-tcp/><i class="fab fa-reddit fa-fw"></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://yusank.github.io/posts/go-tcp/ data-title="Go TCP Socket"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://yusank.github.io/posts/go-tcp/ data-title="Go TCP Socket" data-ralateuid=yusann><i class="fab fa-weibo fa-fw"></i></a><a href=javascript:void(0); title="分享到 Myspace" data-sharer=myspace data-url=https://yusank.github.io/posts/go-tcp/ data-title="Go TCP Socket" data-description><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/myspace.svg></i></a><a href=javascript:void(0); title="分享到 Blogger" data-sharer=blogger data-url=https://yusank.github.io/posts/go-tcp/ data-title="Go TCP Socket" data-description><i class="fab fa-blogger fa-fw"></i></a><a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://yusank.github.io/posts/go-tcp/ data-title="Go TCP Socket"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/baidu.svg></i></a><a href=javascript:void(0); title="分享到 Evernote" data-sharer=evernote data-url=https://yusank.github.io/posts/go-tcp/ data-title="Go TCP Socket"><i class="fab fa-evernote fa-fw"></i></a></span>
</div>
</div>
</div>
<div class=post-info-more>
<section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/go/>go</a>,&nbsp;<a href=/tags/tcp/>tcp</a></section>
<section>
<span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span>
</section>
</div>
<div class=post-nav><a href=/posts/docker/ class=prev rel=prev title="Docker 基础知识和基本操作"><i class="fas fa-angle-left fa-fw"></i>Docker 基础知识和基本操作</a>
<a href=/posts/go-udp/ class=next rel=next title="Go UDP Socket">Go UDP Socket<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id=comments><div id=disqus_thread class=comment></div><noscript>
Please enable JavaScript to view the comments powered by <a href=https://disqus.com/?ref_noscript>Disqus</a>.
</noscript></div></article></div>
</main><footer class=footer>
<div class=footer-container><div class=footer-line>Keep learning and stay with lights.<br>❤ yusank<br></div><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.90.1">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
</div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2017 - 2021</span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div>
</div>
</footer></div>
<div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部>
<i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论>
<i class="fas fa-comment fa-fw"></i>
</a>
</div><script type=text/javascript src=https://yusank.disqus.com/embed.js defer></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/typeit@7.0.4/dist/typeit.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:100},comment:{},data:{"id-1":"Yusank`s Site","id-2":"Yusank`s Site"},typeit:{cursorChar:"|",cursorSpeed:1e3,data:{"id-1":["id-1"],"id-2":["id-2"]},duration:-1,speed:70}}</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-24P8ZSJHCQ',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-24P8ZSJHCQ" async></script></body>
</html>