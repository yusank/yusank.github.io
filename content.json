{"meta":{"title":"Yusank's blog","subtitle":null,"description":"live with light`s die with darkness","author":"Yusank","url":"http://yusank.github.io"},"pages":[{"title":"","date":"2017-02-18T06:09:54.000Z","updated":"2016-12-16T10:15:30.000Z","comments":true,"path":"多说.css","permalink":"http://yusank.github.io/多说.css","excerpt":"","text":"/* 浏览器识别效果 */ span.ua { display: inline-block !important; margin: auto 1px .3em !important; color: #fff !important; } .os_other { background-color: #bdb2a7!important; color: #fff; border: 1px solid #BBB!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .ua_other { background-color: #bdb2a7!important; color: #fff; border: 1px solid #BBB!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .ua_other { opacity: 1; } .os_other:hover { opacity: .4; } .ua_ie { background-color: #428bca!important; border-color: #357ebd!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .ua_ie:hover { opacity: .4; } .ua_firefox { background-color: #f0ad4e!important; border-color: #eea236!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .ua_firefox:hover { opacity: .4; } .ua_maxthon { background-color: #7373B9!important; border-color: #7373B9!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .ua_maxthon:hover { opacity: .4; } .ua_ucweb { background-color: #FF740F!important; border-color: #d43f3a!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .ua_ucweb:hover { opacity: .4; } .ua_sogou { background-color: #78ACE9!important; border-color: #4cae4c!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .ua_sogou:hover { opacity: .4; } .ua_2345explorer { background-color: #2478B8!important; border-color: #4cae4c!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .ua_2345explorer:hover { opacity: .4; } .ua_2345chrome { background-color: #F9D024!important; border-color: #4cae4c!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .ua_2345chrome:hover { opacity: .4; } .ua_mi { background-color: #FF4A00!important; border-color: #4cae4c!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .ua_mi:hover { opacity: .4; } .ua_lbbrowser { background-color: #FC9D2E!important; border-color: #4cae4c!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .ua_lbbrowser:hover { opacity: .4; } .ua_chrome { background-color: #EE6252!important; border-color: #4cae4c!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .ua_chrome:hover { opacity: .4; } .ua_qq { background-color: #3D88A8!important; border-color: #4cae4c!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .ua_qq:hover { opacity: .4; } .ua_apple { background-color: #E95620!important; border-color: #4cae4c!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .ua_apple:hover { opacity: .4; } .ua_opera { background-color: #d9534f!important; border-color: #d43f3a!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .ua_opera:hover { opacity: .4; } .os_vista,.os_2000,.os_windows,.os_xp,.os_7,.os_8,.os_8_1 { background-color: #39b3d7!important; border-color: #46b8da!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .os_vista:hover,.os_2000:hover,.os_windows:hover,.os_xp:hover,.os_7:hover,.os_8:hover,.os_8_1:hover { opacity: .4; } .os_android { background-color: #98C13D!important; border-color: #01B171!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .os_android:hover { opacity: .4; } .os_ubuntu { background-color: #DD4814!important; border-color: #01B171!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .os_ubuntu:hover { opacity: .4; } .os_linux { background-color: #3A3A3A!important; border-color: #1F1F1F!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .os_linux:hover { opacity: .4; } .os_mac { background-color: #666666!important; border-color: #1F1F1F!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .os_mac:hover { opacity: .4; } .os_unix { background-color: #006600!important; border-color: #1F1F1F!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .os_unix:hover { opacity: .4; } .os_nokia { background-color: #014485!important; border-color: #1F1F1F!important; border-radius: 4px; padding: 0 5px!important; opacity: 1; } .os_nokia:hover { opacity: .4; } /* UA End */ /* 博主标记 CSS */ .sskadmin { background-color: #00a67c!important; border-color: #01B171!important; border-radius: 4px; padding: 0 5px!important; } .sskadmin:hover { opacity: .5; } /* 鼠标悬停旋转头像 */ #ds-reset .ds-avatar img,#ds-reset .ds-avatar img:hover { -webkit-animation-fill-mode: both; -moz-animation-fill-mode: both; -ms-animation-fill-mode: both; -o-animation-fill-mode: both; animation-fill-mode: both; -webkit-animation-duration: 0s; -moz-animation-duration: 0s; -ms-animation-duration: 0s; -o-animation-duration: 0s; animation-duration: 0s; -webkit-animation-duration: .7s; -moz-animation-duration: .7s; -ms-animation-duration: .7s; -o-animation-duration: .7s; animation-duration: .7s } @-webkit-keyframes wobble { 0% { -webkit-transform: translateX(0) } 15% { -webkit-transform: translateX(-25%) rotate(-5deg) } 30% { -webkit-transform: translateX(20%) rotate(3deg) } 45% { -webkit-transform: translateX(-15%) rotate(-3deg) } 60% { -webkit-transform: translateX(10%) rotate(2deg) } 75% { -webkit-transform: translateX(-5%) rotate(-1deg) } 100% { -webkit-transform: translateX(0) } } @-moz-keyframes wobble { 0% { -moz-transform: translateX(0) } 15% { -moz-transform: translateX(-25%) rotate(-5deg) } 30% { -moz-transform: translateX(20%) rotate(3deg) } 45% { -moz-transform: translateX(-15%) rotate(-3deg) } 60% { -moz-transform: translateX(10%) rotate(2deg) } 75% { -moz-transform: translateX(-5%) rotate(-1deg) } 100% { -moz-transform: translateX(0) } } @-o-keyframes wobble { 0% { -o-transform: translateX(0) } 15% { -o-transform: translateX(-25%) rotate(-5deg) } 30% { -o-transform: translateX(20%) rotate(3deg) } 45% { -o-transform: translateX(-15%) rotate(-3deg) } 60% { -o-transform: translateX(10%) rotate(2deg) } 75% { -o-transform: translateX(-5%) rotate(-1deg) } 100% { -o-transform: translateX(0) } } @keyframes wobble { 0% { transform: translateX(0) } 15% { transform: translateX(-25%) rotate(-5deg) } 30% { transform: translateX(20%) rotate(3deg) } 45% { transform: translateX(-15%) rotate(-3deg) } 60% { transform: translateX(10%) rotate(2deg) } 75% { transform: translateX(-5%) rotate(-1deg) } 100% { transform: translateX(0) } } #ds-reset .ds-avatar img:hover { -webkit-animation-name: wobble; -moz-animation-name: wobble; -o-animation-name: wobble; animation-name: wobble } /* 社交账号登陆透明度 */ #ds-thread #ds-reset .ds-login-buttons { opacity: 1; } #ds-thread #ds-reset .ds-login-buttons:hover { opacity: 1; } /* 留言板 CSS */ #ds-thread.ds-narrow #ds-reset .ds-replybox{ padding-left: 0px; } #ds-thread #ds-reset .ds-replybox{ width: auto; font-size: 12px; z-index: 3; margin: 8px 0; position: relative; padding: 0; border: 1px solid #2F2F2F; border-radius: 6px; -webkit-box-shadow: 4px 4px 18px rgba(0,0,0,0.46); box-shadow: 4px 4px 18px rgba(0,0,0,0.46); } #ds-thread #ds-reset .ds-replybox .ds-avatar{ display: none; } #ds-thread #ds-reset .ds-textarea-wrapper{ border: none; border-bottom: none; background-color: rgba(255, 255, 255, 0.01); background-image: none; } #ds-thread #ds-reset .ds-comment-body p, #ds-thread #ds-reset .ds-textarea-wrapper textarea { color: #FFF; } /* “发布”按钮背景 */ #ds-thread #ds-reset .ds-post-toolbar { box-shadow: none; background-color: #414141; } #ds-thread #ds-reset .ds-post-toolbar .ds-post-options { background-color: rgb(65, 65, 65); border-radius: 5px; border: 0px solid #2F2F2F; } #ds-thread #ds-reset .ds-sync{ right: 27px; } #ds-thread #ds-reset .ds-post-button { background: #2f2f2f; width: 62px; text-shadow: none; color: #FFF; height: 26px; border: 0px #FFF; margin-right: 18px; margin-top: 1px; border-radius: 6px; background-image: none; box-shadow: none; } #ds-thread #ds-reset .ds-post-button:hover{ background: #EE6252; color: #FFF; } #ds-thread #ds-reset .ds-powered-by a{ color: #999; } #ds-thread #ds-reset .ds-powered-by a:hover{ color: #FFF; } #ds-reset .ds-gradient-bg { background-color: rgba(63, 63, 63, 0); background-image: none; } /* 评论列表背景 */ #ds-thread #ds-reset a{ color: #999; } #ds-thread #ds-reset a:hover{ color: #FFF; } #ds-thread #ds-reset .ds-comments{ background-color: #3F3F3F; } #ds-reset .ds-avatar{ background-color: rgba(255, 255, 255, 0); } /* 喜欢 */ #ds-thread #ds-reset a.ds-like-thread-button { border: 1px solid #EE6252; border-radius: 42px; width: 120px; background-color: rgba(224, 224, 224, 0); margin-right: 12px; padding: 9px 15px; text-shadow: none; background-image: none; } #ds-thread #ds-reset a.ds-like-thread-button span { color: #EE6252; } #ds-thread #ds-reset .ds-like-tooltip{ border-radius: 6px; border: 1px solid #1F1F1F; text-shadow: none; position: absolute; z-index: 9999; background-color: #3F3F3F; background-repeat: repeat-x; background-image: -khtml-gradient(linear, left top, left bottom, from(#3F3F3F), to(#3F3F3F)); background: -moz-linear-gradient(top, #3F3F3F 0, #3F3F3F 100%); background: -webkit-gradient(linear, left top, left bottom, color-stop(0, #3F3F3F), color-stop(100%, #3F3F3F)); background: -webkit-linear-gradient(top, #3F3F3F 0, #3F3F3F 100%); background: -ms-linear-gradient(top, #3F3F3F 0, #3F3F3F 100%); background: linear-gradient(top, #3F3F3F 0, #3F3F3F 100%); } #ds-thread #ds-reset .ds-meta { border-bottom: 1px solid rgba(0, 0, 0, 0); } #ds-thread #ds-reset .ds-header { font-weight: bold; font-size: 14px; color: #999; line-height: 30px; padding: 0 12px; } #ds-thread #ds-reset #ds-hot-posts { border: none; } /* 简介 */ #ds-reset .ds-highlight { color: #3dbcf5 !important; } #ds-thread #ds-reset .ds-comment-body p, #ds-thread #ds-reset .ds-textarea-wrapper textarea { color: #FFFFFF; font-size: 13px; font-family: Helvetica, Arial, \"Hiragino Sans GB\", sans-serif; } #ds-thread #ds-reset .ds-comment-actions a,#ds-thread #ds-reset a,#ds-thread #ds-reset .ds-comment-actions a,#ds-thread #ds-reset .ds-time{ color: #999; } #ds-thread #ds-reset .ds-comment-actions a .ds-icon:hover#ds-thread #ds-reset .ds-comment-actions a:hover,#ds-thread #ds-reset a:hover{ color: #FFF; } #ds-thread #ds-reset .ds-comments-info{ padding: 8px 0 0 0; border-bottom: 3px solid rgba(61, 61, 61, 0); } #ds-thread #ds-reset li.ds-post { width: 100%; overflow: hidden; clear: both; border-top: 1px dashed rgb(8, 8, 8); margin: 0; padding-top: 8px; list-style: none; } #ds-thread #ds-reset .ds-comments { width: 100%; border-bottom: 1px solid rgba(0, 0, 0, 0); } #ds-thread #ds-reset .ds-account-control ul { display: none; position: absolute; top: 19px; left: 0; border: 1px solid #080808; background: #3F3F3F; box-shadow: none; border-radius: 6px; text-align: center; } #ds-thread #ds-reset .ds-account-control ul li a { border: none; display: block; padding: 3px 10px; text-shadow: none; } /* 头像简介 */ #ds-thread #ds-reset #ds-bubble{ position: absolute; background: #2f2f2f; padding: 10px; color: #333; border-radius: 6px; border: 1px solid #0C0C0C; } #ds-thread #ds-reset .ds-arrow-down{ border-left: 5px solid rgb(63, 63, 63); border-right: 5px solid rgb(63, 63, 63); border-top: 5px solid #0C0C0C; } /* 新回复弹窗 */ #ds-notify { position: fixed; z-index: 9999; max-width: 144px; _width: 130px; display: block; float: none; padding: 8px 12px; background-color: #3F3F3F; -webkit-border-radius: 5px; border-radius: 5px; box-shadow: 0 1px 1px rgba(0,0,0,0.25); border: 1px solid #2F2F2F; } #ds-notify #ds-reset ul.ds-notify-unread li a { color: #FFF; text-decoration: none; } #ds-wrapper #ds-reset .ds-dialog-inner { width: 100%; position: relative; border: 1px solid #000; background: #3F3F41; border-radius: 6px; } #ds-wrapper #ds-reset h2 { display: block; font-weight: normal; font-size: 16px; margin: 0 0 15px 0; color: #999; } #ds-wrapper #ds-reset .ds-unread-list li { position: relative; margin: 0; padding: 0; border-top: 0; line-height: 1.5em; color: #777; } #ds-wrapper #ds-reset .ds-dialog-footer { display: none; clear: both; border-top: 1px dotted #ccc; padding: 10px 15px 6px; } #ds-wrapper #ds-reset .ds-unread-list li a[rel~=\"author\"] { color: #FFF; } #ds-thread #ds-reset .ds-paginator div.ds-border { border-top: 1px dashed #080808; margin-bottom: 15px; } #ds-thread #ds-reset .ds-paginator { border-bottom: 1px solid rgba(0, 0, 0, 0); text-align: right; padding-bottom: 15px; clear: both; line-height: 1em; } #ds-thread #ds-reset .ds-paginator a.ds-current { color: #FFFFFF; border: 1px solid #2F2F2F; background-color: #2F2F2F; border-radius: 4px; } #ds-thread #ds-reset .ds-post-toolbar { box-shadow: none; background-color: rgba(255, 255, 255, 0); } #ds-thread #ds-reset ul.ds-children { margin-left: 70px; }","raw":null,"content":null},{"title":"404","date":"2016-12-16T12:55:50.000Z","updated":"2016-12-16T12:55:50.000Z","comments":true,"path":"404/index.html","permalink":"http://yusank.github.io/404/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"about me","date":"2016-12-18T03:47:39.000Z","updated":"2017-01-07T02:29:04.000Z","comments":true,"path":"about/index.html","permalink":"http://yusank.github.io/about/index.html","excerpt":"","text":"I`m Yusan , Welcome to my persnol blog Here`s my favorite song.","raw":null,"content":null},{"title":"categories","date":"2016-12-16T08:09:00.000Z","updated":"2016-12-16T08:11:50.000Z","comments":false,"path":"categories/index.html","permalink":"http://yusank.github.io/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"Gallery","date":"2017-02-18T06:09:54.000Z","updated":"2017-01-04T06:44:02.000Z","comments":true,"path":"gallery/index.html","permalink":"http://yusank.github.io/gallery/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"","date":"2017-02-18T06:09:54.000Z","updated":"2016-12-18T03:10:50.000Z","comments":true,"path":"tags/index.html","permalink":"http://yusank.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"友情链接","date":"2016-12-18T03:47:54.000Z","updated":"2016-12-18T03:49:55.000Z","comments":true,"path":"links/index.html","permalink":"http://yusank.github.io/links/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"Hexo 添加歌单","slug":"testlist","date":"2017-04-09T07:13:11.000Z","updated":"2017-04-09T07:13:11.000Z","comments":true,"path":"2017/04/09/testlist/","link":"","permalink":"http://yusank.github.io/2017/04/09/testlist/","excerpt":"测试添加歌单。。。。","text":"测试添加歌单。。。。 测试歌单 var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":1,\"mode\":\"random\",\"mutex\":true,\"theme\":\"#e6d0b2\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"匆匆那年\",\"author\":\"王菲\",\"url\":\"http://oid1xlj7h.bkt.clouddn.com/%E7%8E%8B%E8%8F%B2%20-%20%E5%8C%86%E5%8C%86%E9%82%A3%E5%B9%B4.mp3\",\"lrc\":\"http://oid1xlj7h.bkt.clouddn.com/ccnn.txt\"},{\"title\":\"Toca Toca\",\"author\":\"Fly project\",\"url\":\"http://oid1xlj7h.bkt.clouddn.com/Fly%20Project%20-%20Toca%20Toca.mp3\"},{\"title\":\"Danzo Kuduro\",\"author\":\"Don Omar\",\"url\":\"http://oid1xlj7h.bkt.clouddn.com/Don%20Omar,Lucenzo%20-%20Danza%20Kuduro%20-%20Album%20Version.mp3\"},{\"title\":\"难忘的一天\",\"author\":\"许巍\",\"url\":\"http://oid1xlj7h.bkt.clouddn.com/%E8%AE%B8%E5%B7%8D%20-%20%E9%9A%BE%E5%BF%98%E7%9A%84%E4%B8%80%E5%A4%A9.mp3\",\"lrc\":\"http://oid1xlj7h.bkt.clouddn.com/nwdyt.txt\"},{\"title\":\"Counting Stars\",\"author\":\"OneRepublic\",\"url\":\"http://oid1xlj7h.bkt.clouddn.com/OneRepublic%20-%20Counting%20Stars.mp3\"},{\"title\":\"Zoobi Doobi\",\"author\":\"Sonu Nigam,Shreya Ghoshal\",\"url\":\"http://oid1xlj7h.bkt.clouddn.com/Sonu%20Nigam,Shreya%20Ghoshal%20-%20Zoobi%20Doobi.mp3\",\"lrc\":\"http://oid1xlj7h.bkt.clouddn.com/tidoit.txt\"}]}; options.element = document.getElementById(\"aplayer2\"); new APlayer(options);","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Hexo 博客添加视频和音乐","slug":"HexoMedia","date":"2017-04-09T05:13:11.000Z","updated":"2017-04-09T05:13:11.000Z","comments":true,"path":"2017/04/09/HexoMedia/","link":"","permalink":"http://yusank.github.io/2017/04/09/HexoMedia/","excerpt":"找到一个炒鸡流弊的东西。。。","text":"找到一个炒鸡流弊的东西。。。 Hexo 博客中插入视频/音乐博客中插入音乐/视频，可以让博客的逼格瞬间提高。作为优秀的静态博客，Hexo 当然也少不了这些高大上的功能。 Markdown 通用音乐/视频插入方法Markdown 作为轻量级的标记语言，兼容 html 语法，所以可以直接在 Markdown 文档中使用 html 语法。 vedio 标签 123&lt;video width=\"480\" height=\"320\" controls&gt;&lt;source src=\"movie.mp4\"&gt;&lt;/video&gt; 其中在 src 后面需要替换自己的音乐/视频链接 效果: ​ ​ ​ embed标签1&lt;embed src=\"http://player.youku.com/player.php/Type/Folder/Fid/27690810/Ob/1/sid/XMTY1MTI3NjMyNA==/v.swf\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowScriptAccess=\"always\" allowFullScreen=\"true\" mode=\"transparent\" type=\"application/x-shockwave-flash\"&gt;&lt;/embed&gt; ifreame标签1&lt;iframe height=498 width=510 src=\"http://player.youku.com/embed/XMTY1MTI3NjMyNA==\" frameborder=0 allowfullscreen&gt;&lt;/iframe&gt; 网易云音乐网页版提供生成 iframe 标签。 1&lt;script type=\"text/javascript\" src=\"http://www.xiami.com/widget/player-single?uid=32329501&amp;sid=1776238762&amp;mode=js\"&gt;&lt;/script&gt; 除了 vedio 标签外，大部分音乐/视频网站都可以直接生成播放代码，直接粘贴在 Markdown 文档即可。 不过有些标签不支持 HTTPS。 通过 Hexo 插件插入音频/视频这里需要两个播放器插件 123hexo-tag-aplayer:https://github.com/grzhan/hexo-tag-aplayer#upstream-issuehexo-tag-dplayer:https://github.com/NextMoe/hexo-tag-dplayer 这两款插件基于 DIYgod 编写的 html5 播放器 APlayer 和 DPlayer 开发。 首先安装两款插件 打开 shell，切换到 Hexo 目录下，运行两条目录 12npm install hexo-tag-dplayer --savenpm install hexo-tag-aplayer --save 安装成功后，在 Markdown 文档中添加 APlayer 和 DPlayer 标签即可。 12&#123;% aplayer \"Caffeine\" \"Jeff Williams\" \"http://7xq131.com1.z0.glb.clouddn.com/Preparation.mp3\" \"autoplay\" %&#125;&#123;% dplayer \"url=http://devtest.qiniudn.com/若能绽放光芒.mp4\" \"api=http://dplayer.daoapp.io\" \"pic=http://devtest.qiniudn.com/若能绽放光芒.png\" \"id=9E2E3368B56CDBB4\" \"loop=yes\" \"theme=#FADFA3\" \"autoplay=false\" \"token=tokendemo\" %&#125; APlayer 和 DPlayer 具体参数设置可以到 GitHub 项目主页，不过默认参数足够了。 '[00:00.00]Zoobi Doobi [00:00.38]Sonu Nigam & Shreya Ghoshal [00:00.53]LRC：Meselson (QQ 445942376) [00:01.18] [00:03.50]Gungunati hain yeh hawayein [00:12.73]Gungunata hai gagan [00:19.91]Gaa raha hai yeh saara aalam [00:26.90]Zoobi do… param pum… [00:37.35]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum [00:42.67]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann [00:47.99]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum [00:53.30]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann [00:58.34]Shaakhon pe pattey gaa rahe hain Phoolon pe bhanvre gaa rahe [01:03.69]Deewani kirine gaa rahi hain Yeh panchhi gaa rahe [01:08.38]Ohhh Bagiya mein do phoolon ki Ho rahi hai guft-gu [01:14.02]Jaisa filmon mein hota hai Ho raha hai hu-bahoo [01:19.18]I iiii iii.. [01:20.11]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum [01:25.21]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann [01:30.52] [01:30.81]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum [01:35.98]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann [01:40.68] [02:02.67]Rimjhim rimjhim rimjhim San san san san hawaa [02:07.63]Tip tip tip tip boondein Gurrati bijliyaan [02:13.00]Bheegi bheegi saree mein Yun thumke lagati tu [02:18.24]Ho raha hai hu bahoo [02:23.58]I iiii iii.. [02:24.23]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum [02:29.16]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann [02:32.50] [02:34.30]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum [02:39.58]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann [02:45.70] [03:06.55]Amber ka chand zameen par Itra ke gaa raha [03:12.02]Ek tim tim toota tara Ithla ka gaa raha [03:17.29]Hai raat akeli tanha Mujhe choo le aake tu [03:22.47]Jaisa filmon mein hota hai Ho raha hai hubahoo [03:27.24]I iiii iii.. [03:27.78]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum [03:33.28]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann [03:38.57]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum [03:43.79]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann [03:48.58]LRC：Meselson (QQ 445942376) [03:50.47]THE END new APlayer({ element: document.getElementById(\"aplayer1\"), narrow: false, autoplay: 1, showlrc: 2, music: { title: \"Zoobi Doobi\", author: \"Three ediot\", url: \"http://oid1xlj7h.bkt.clouddn.com/Sonu%20Nigam,Shreya%20Ghoshal%20-%20Zoobi%20Doobi.mp3\", pic: \"http://oid1xlj7h.bkt.clouddn.com/3_idiots_wallpaper.jpg\", } }); var dplayer1 = new DPlayer({\"element\":document.getElementById(\"dplayer1\"),\"autoplay\":false,\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"http://oid1xlj7h.bkt.clouddn.com/WeChatSight72.mp4\"},\"danmaku\":{\"api\":\"http://dplayer.daoapp.io\",\"id\":\"9E2E3368B56CDBB4\",\"token\":\"tokendemo\"}}); APlayer 和 DPlayer 均支持 HTTPS。 上述两种方法都有优缺点，选择一种适合自己的方法，打造自己专属的博客吧。 转载：【login926】login926.github.io","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Vim 快捷键","slug":"Vimkyboard","date":"2017-04-07T07:07:00.000Z","updated":"2017-04-07T07:07:01.000Z","comments":true,"path":"2017/04/07/Vimkyboard/","link":"","permalink":"http://yusank.github.io/2017/04/07/Vimkyboard/","excerpt":"Vim 快捷键一. 移动：h,j,k,l: 左，下，上，右。\nw: 下一个词的词首。\ne:下一个词的词尾。\n​    b:上一个词的词首。\n&lt;&gt;: v 模式选中后进行缩进。\n","text":"Vim 快捷键一. 移动：h,j,k,l: 左，下，上，右。 w: 下一个词的词首。 e:下一个词的词尾。 ​ b:上一个词的词首。 &lt;&gt;: v 模式选中后进行缩进。 new APlayer({ element: document.getElementById(\"aplayer0\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"Wadilar Keni\", author: \"from nobody\", url: \"http://oid1xlj7h.bkt.clouddn.com/elyarr%20-%20wadilar%C2%A0keni%EF%BC%88%E5%90%AC%E4%BA%86%E5%B0%B1%E6%B2%A1%E9%94%99%EF%BC%89.mp3\", pic: \"\", } }); var dplayer0 = new DPlayer({\"element\":document.getElementById(\"dplayer0\"),\"autoplay\":false,\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"http://oid1xlj7h.bkt.clouddn.com/WeChatSight72.mp4\"},\"danmaku\":{\"api\":\"http://dplayer.daoapp.io\",\"id\":\"9E2E3368B56CDBB4\",\"token\":\"tokendemo\"}}); 二. 跳转：%: 可以匹配{},&quot;&quot;,(),[]之间跳转。 H、M、L：直接跳转到当前屏幕的顶部、中部、底部。 “#H”：跳转到当前屏的第#行。 // 由于markdown语法原因，加上了双引号，实际用的时候没有双引号的, 以下所有加引号的雷同。 “#L”：跳转到当前屏的倒数第#行。 zt: 当前编辑行置为屏顶。 zz: 当前编辑行置为屏中。 zb: 当前编辑行置为屏底。 G：直接跳转到文件的底部。 gg: 跳转到文件首。 ():跳转到当前的行首、行尾。 {}：向上、向下跳转到最近的空行。 [{：跳转到目前区块开头。 ]}：跳转到目前区块结尾。 0: 跳转到行首。 $: 跳转到行尾。 2$: 跳转到下一行的行尾。 “#”：跳转到该行的第#个位置。 “#G”: 15G,跳转到15行。 :#：跳转到#行。 f&apos;n&apos;：跳转到下一个&quot;n&quot;字母后。 ctrl+b: 向后翻一页。 ctrl+f：向前翻一页。 ctrl+u: 向后翻半页。 ctrl+d: 向前翻半页。 ctry+e: 下滚一行。 三. 选择：1.V: 选择一行。 2.^V: 矩形选择。 3.v3w: 选择三个字符。 四. 编辑： 新增：i: 光标前插入。 I: 在当前行首插入。 a: 光标后插入。 A: 当前行尾插入。 O: 在当前行之前插入新行。 o: 在当前行之后插入新行。 修改 c(change) 为主： r: 替换光标所在处的字符。 R：替换光标所到之处的字符。 cw: 更改光标所在处的字到字尾处。 c#w: c3w 修改3个字符。 C：修改到行尾。 ci&apos;：修改配对标点符号中的文本内容。 di&apos;：删除配对标点符号中的文本内容。 yi&apos;：复制配对标点符号中的文本内容。 vi&apos;：选中配对标点符号中的文本内容。 s：替换当前一个光标所处字符。 ​ “#S”：删除 # 行，并以新文本代替。 删除 d(delete) 为主：D：删除到行尾。 X: 每按一次，删除光标所在位置的前面一个字符。 x: 每按一次，删除光标所在位置的后面一个字符。 ​ “#x”: 删除光标所在位置后面6个字符。 d^: 删至行首。 d$: 删至行尾。 dd:(剪切)删除光标所在行。 dw: 删除一个单词/光标之后的单词剩余部分。 d4w: 删除4个word。 ​”#dd”: 从光标所在行开始删除#行。 daB: 删除{}及其内的内容。 diB: 删除{}中的内容。 n1,n2 d：将n1,n2行之间的内容删除。 查找：/： 输入关键字，发现不是要找的，直接在按n，向后查找直到找到为止。 ?： 输入关键字，发现不是要找的，直接在按n，向前查找直到找到为止。 *: 在当前页向后查找同一字。 ​ “#”: 在当前页向前查找同一字。 复制 y(yank)为主： yw: 将光标所在之处到字尾的字符复制到缓冲区中。 “#yw”: 复制#个字到缓冲区。 Y：相当于yy, 复制整行。 ​ “#yy”:表示复制从光标所在的该行往下数#行文字。 p: 粘贴。所有与y相关的操作必用p来结合粘贴。 n1,n2 co n3：复制第n1行到第n2行之间的内容到第n3行后面。 6. 大小写转换： gUU: 将当前行的字母改为大写。 guu: 将当前行的字母改为小写。 gUw: 将当前光标下的单词改为大写。 guw: 将当前光标下的单词改为小写。 a. 整篇大写: ggguG gg: 光标到文件第一个字符。 gu: 把选择范围全部小写。 G: 到文件结束。 b. 整篇小写：gggUG 7. 其它： J：当前行和下一行合并成一行。 8. 移动： n1,n2 m n3：将n1行到n2行之间的内容移至n3行下。 五.退出：1. w filename: 保存正在编辑的文件filename 2. wq filename: 保存后退出正在编辑的文件filename 3. q：退出不保存。 六.窗口操作：1. ctrl+w p: 在两个分割窗口之间来回切换。 2. ctrl+w j: 跳到下面的分割窗 3. ctrl+w h: 跳到左边的分割窗。 4. ctrl+w k: 跳到上面的分割窗。 5. ctrl+w l: 跳到右边的分割窗。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"跨域资源共享 CORS 详解","slug":"CORS","date":"2017-01-30T07:07:00.000Z","updated":"2017-01-30T07:07:01.000Z","comments":true,"path":"2017/01/30/CORS/","link":"","permalink":"http://yusank.github.io/2017/01/30/CORS/","excerpt":"跨域资源共享 CORS 详解CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。本文详细介绍CORS的内部机制。","text":"跨域资源共享 CORS 详解CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。本文详细介绍CORS的内部机制。 一、简介CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 二、两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要同时满足以下两大条件，就属于简单请求。 1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。 三、简单请求3.1 基本流程对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。 下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。 123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。 （1）Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(&#39;FooBar&#39;)可以返回FooBar字段的值。 3.2 withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。 1Access-Control-Allow-Credentials: true 另一方面，开发者必须在AJAX请求中打开withCredentials属性。 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 1xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 四、非简单请求4.1 预检请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 下面是一段浏览器的JavaScript脚本。 12345var url = 'http://api.alice.com/cors';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'value');xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。 12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method 该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 （2）Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 4.2 预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 1Access-Control-Allow-Origin: * 如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 12XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他CORS相关字段如下。 1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 （2）Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 （3）Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 4.3 浏览器的正常请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 下面是”预检”请求之后，浏览器的正常CORS请求。 1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。 下面是服务器正常的回应。 12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。 五、与JSONP的比较CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 （完）","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Go Channel","slug":"Go Channel","date":"2017-01-07T04:20:00.000Z","updated":"2017-01-08T06:31:42.000Z","comments":true,"path":"2017/01/07/Go Channel/","link":"","permalink":"http://yusank.github.io/2017/01/07/Go Channel/","excerpt":"","text":"讲解 Golang 的 channel（通道），学 go 语言的有必要看一下。以下正文。。。 Go Channel 详解Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)。 它的操作符是箭头 &lt;- 。 12ch &lt;- v v := &lt;-ch (箭头的指向就是数据的流向) 就像 map 和 slice 数据类型一样, channel必须先创建再使用: 1ch := make(chan int) Channel 类型Channel类型的定义格式如下： 1ChannelType = ( \"chan\" | \"chan\" \"&lt;-\" | \"&lt;-\" \"chan\" ) ElementType . 它包括三种类型的定义。可选的&lt;-代表channel的方向。如果没有指定方向，那么Channel就是双向的，既可以接收数据，也可以发送数据。 123chan T // 可以接收和发送类型为 T 的数据chan&lt;- float64 // 只可以用来发送 float64 类型的数据&lt;-chan int // 只可以用来接收 int 类型的数据 &lt;-总是优先和最左边的类型结合。(The &lt;- operator associates with the leftmost chan possible) 1234chan&lt;- chan int // 等价 chan&lt;- (chan int)chan&lt;- &lt;-chan int // 等价 chan&lt;- (&lt;-chan int)&lt;-chan &lt;-chan int // 等价 &lt;-chan (&lt;-chan int)chan (&lt;-chan int) 使用make初始化Channel,并且可以设置容量: 1make(chan int, 100) 容量(capacity)代表Channel容纳的最多的元素的数量，代表Channel的缓存的大小。如果没有设置容量，或者容量设置为0, 说明Channel没有缓存，只有sender和receiver都准备好了后它们的通讯(communication)才会发生(Blocking)。如果设置了缓存，就有可能不发生阻塞， 只有buffer满了后 send才会阻塞， 而只有缓存空了后receive才会阻塞。一个nil channel不会通信。 可以通过内建的close方法可以关闭Channel。 你可以在多个goroutine从/往 一个channel 中 receive/send 数据, 不必考虑额外的同步措施。 Channel可以作为一个先入先出(FIFO)的队列，接收的数据和发送的数据的顺序是一致的。 channel的 receive支持 multi-valued assignment，如 1v, ok := &lt;-ch 它可以用来检查Channel是否已经被关闭了。 send语句send语句用来往Channel中发送数据， 如ch &lt;- 3。它的定义如下: 12SendStmt = Channel \"&lt;-\" Expression .Channel = Expression . 在通讯(communication)开始前channel和expression必选先求值出来(evaluated)，比如下面的(3+4)先计算出7然后再发送给channel。 12345c := make(chan int)defer close(c)go func() &#123; c &lt;- 3 + 4 &#125;()i := &lt;-cfmt.Println(i) send被执行前(proceed)通讯(communication)一直被阻塞着。如前所言，无缓存的channel只有在receiver准备好后send才被执行。如果有缓存，并且缓存未满，则send会被执行。 往一个已经被close的channel中继续发送数据会导致run-time panic。 往nil channel中发送数据会一致被阻塞着。 receive 操作符&lt;-ch用来从channel ch中接收数据，这个表达式会一直被block,直到有数据可以接收。 从一个nil channel中接收数据会一直被block。 从一个被close的channel中接收数据不会被阻塞，而是立即返回，接收完已发送的数据后会返回元素类型的零值(zero value)。 如前所述，你可以使用一个额外的返回参数来检查channel是否关闭。 123x, ok := &lt;-chx, ok = &lt;-chvar x, ok = &lt;-ch blocking缺省情况下，发送和接收会一直阻塞着，知道另一方准备好。这种方式可以用来在gororutine中进行同步，而不必使用显示的锁或者条件变量。 如官方的例子中x, y := &lt;-c, &lt;-c这句会一直等待计算结果发送到channel中。 12345678910111213141516import \"fmt\"func sum(s []int, c chan int) &#123; sum := 0 for _, v := range s &#123; sum += v &#125; c &lt;- sum &#125;func main() &#123; s := []int&#123;7, 2, 8, -9, 4, 0&#125; c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := &lt;-c, &lt;-c // receive from c fmt.Println(x, y, x+y)&#125; Buffered Channelsmake的第二个参数指定缓存的大小：ch := make(chan int, 100)。 通过缓存的使用，可以尽量避免阻塞，提供应用的性能。 Rangefor …… range语句可以处理Channel。 12345678910111213141516func main() &#123; go func() &#123; time.Sleep(1 * time.Hour) &#125;() c := make(chan int) go func() &#123; for i := 0; i &lt; 10; i = i + 1 &#123; c &lt;- i &#125; close(c) &#125;() for i := range c &#123; fmt.Println(i) &#125; fmt.Println(\"Finished\")&#125; range c产生的迭代值为Channel中发送的值，它会一直迭代知道channel被关闭。上面的例子中如果把close(c)注释掉，程序会一直阻塞在for …… range那一行。 selectselect语句选择一组可能的send操作和receive操作去处理。它类似switch,但是只是用来处理通讯(communication)操作。它的case可以是send语句，也可以是receive语句，亦或者default。 receive语句可以将值赋值给一个或者两个变量。它必须是一个receive操作。 最多允许有一个default case,它可以放在case列表的任何位置，尽管我们大部分会将它放在最后。 123456789101112131415161718192021222324import \"fmt\"func fibonacci(c, quit chan int) &#123; x, y := 0, 1 for &#123; select &#123; case c &lt;- x: x, y = y, x+y case &lt;-quit: fmt.Println(\"quit\") return &#125; &#125;&#125;func main() &#123; c := make(chan int) quit := make(chan int) go func() &#123; for i := 0; i &lt; 10; i++ &#123; fmt.Println(&lt;-c) &#125; quit &lt;- 0 &#125;() fibonacci(c, quit)&#125; 如果有同时多个case去处理,比如同时有多个channel可以接收数据，那么Go会伪随机的选择一个case处理(pseudo-random)。如果没有case需要处理，则会选择default去处理，如果default case存在的情况下。如果没有default case，则select语句会阻塞，直到某个case需要处理。 需要注意的是，nil channel上的操作会一直被阻塞，如果没有default case,只有nil channel的select会一直被阻塞。 select语句和switch语句一样，它不是循环，它只会选择一个case来处理，如果想一直处理channel，你可以在外面加一个无限的for循环： 123456789for &#123; select &#123; case c &lt;- x: x, y = y, x+y case &lt;-quit: fmt.Println(\"quit\") return &#125;&#125; timeoutselect有很重要的一个应用就是超时处理。 因为上面我们提到，如果没有case需要处理，select语句就会一直阻塞着。这时候我们可能就需要一个超时操作，用来处理超时的情况。下面这个例子我们会在2秒后往channel c1中发送一个数据，但是select设置为1秒超时,因此我们会打印出timeout 1,而不是result 1。 123456789101112131415import \"time\"import \"fmt\"func main() &#123; c1 := make(chan string, 1) go func() &#123; time.Sleep(time.Second * 2) c1 &lt;- \"result 1\" &#125;() select &#123; case res := &lt;-c1: fmt.Println(res) case &lt;-time.After(time.Second * 1): fmt.Println(\"timeout 1\") &#125;&#125; 其实它利用的是time.After方法，它返回一个类型为&lt;-chan Time的单向的channel，在指定的时间发送一个当前时间给返回的channel中。 Timer 和 Ticker我们看一下关于时间的两个Channel。timer是一个定时器，代表未来的一个单一事件，你可以告诉timer你要等待多长时间，它提供一个Channel，在将来的那个时间那个Channel提供了一个时间值。下面的例子中第二行会阻塞2秒钟左右的时间，直到时间到了才会继续执行。 123timer1 := time.NewTimer(time.Second * 2)&lt;-timer1.Cfmt.Println(\"Timer 1 expired\") 当然如果你只是想单纯的等待的话，可以使用time.Sleep来实现。 你还可以使用timer.Stop来停止计时器。 123456789timer2 := time.NewTimer(time.Second)go func() &#123; &lt;-timer2.C fmt.Println(\"Timer 2 expired\")&#125;()stop2 := timer2.Stop()if stop2 &#123; fmt.Println(\"Timer 2 stopped\")&#125; ticker是一个定时触发的计时器，它会以一个间隔(interval)往Channel发送一个事件(当前时间)，而Channel的接收者可以以固定的时间间隔从Channel中读取事件。下面的例子中ticker每500毫秒触发一次，你可以观察输出的时间。 123456ticker := time.NewTicker(time.Millisecond * 500)go func() &#123; for t := range ticker.C &#123; fmt.Println(\"Tick at\", t) &#125;&#125;() 类似timer, ticker也可以通过Stop方法来停止。一旦它停止，接收者不再会从channel中接收数据了。 close内建的close方法可以用来关闭channel。 总结一下channel关闭后sender的receiver操作。如果channel c已经被关闭,继续往它发送数据会导致panic: send on closed channel: 1234567891011import \"time\"func main() &#123; go func() &#123; time.Sleep(time.Hour) &#125;() c := make(chan int, 10) c &lt;- 1 c &lt;- 2 close(c) c &lt;- 3&#125; 但是从这个关闭的channel中不但可以读取出已发送的数据，还可以不断的读取零值: 12345678c := make(chan int, 10)c &lt;- 1c &lt;- 2close(c)fmt.Println(&lt;-c) //1fmt.Println(&lt;-c) //2fmt.Println(&lt;-c) //0fmt.Println(&lt;-c) //0 但是如果通过range读取，channel关闭后for循环会跳出： 1234567c := make(chan int, 10)c &lt;- 1c &lt;- 2close(c)for i := range c &#123; fmt.Println(i)&#125; 通过i, ok := &lt;-c可以查看Channel的状态，判断值是零值还是正常读取的值。 12345c := make(chan int, 10)close(c)i, ok := &lt;-cfmt.Printf(\"%d, %t\", i, ok) //0, false 同步channel可以用在goroutine之间的同步。下面的例子中main goroutine通过done channel等待worker完成任务。 worker做完任务后只需往channel发送一个数据就可以通知main goroutine任务完成。 123456789101112131415import ( \"fmt\" \"time\")func worker(done chan bool) &#123; time.Sleep(time.Second) // 通知任务已完成 done &lt;- true&#125;func main() &#123; done := make(chan bool, 1) go worker(done) // 等待任务完成 &lt;-done&#125; [参考资料]： https://gobyexample.com/channels https://tour.golang.org/concurrency/2 https://golang.org/ref/spec#Select_statements https://github.com/a8m/go-lang-cheat-sheet http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Docker 进阶与实践（第一讲）","slug":"Docker","date":"2017-01-03T10:11:00.000Z","updated":"2017-01-04T06:12:00.000Z","comments":true,"path":"2017/01/03/Docker/","link":"","permalink":"http://yusank.github.io/2017/01/03/Docker/","excerpt":"学习 Docker 技术，每看完一章或够写一篇文章的时候就上传一次. 这一篇讲容器技术。以下正文。。。","text":"学习 Docker 技术，每看完一章或够写一篇文章的时候就上传一次. 这一篇讲容器技术。以下正文。。。 Docker容器技术 对于容器，目前并没有一个严格的定义，但是普遍被认可的说法是，它首先必须是一个相对独立的环境，在这一点上有点类似虚拟机，但是没有虚拟机那么彻底。另外，在一个容器环境中，应该最小化其对外界的影响，比如不能在容器中吧host上的资源耗尽，这就是资源的控制。 容器技术之所以受欢迎，一个重要的原因是它已经集成到了 Linux 内核中，已经被当作 Linux 内核原生提供的特征。当然其他平台也有相应的容器技术，但是我们讨论的以及Docker涉及的都是指 Linux 平台上的容器技术。 一般来说，容器技术主要包括Namespace和Cgroup两个内核特征。 Namespace 命名空间，它主要做的是访问隔离。其原理是对一类资源进行抽象，并将其封装在一起提供给容器使用，对于这类资源，因为每个容器都有自己的抽象，而他们彼此之间是不可见的，所以就做到访问隔离。 Cgroup是 control group 的简称，又称为控制组，它主要是控制资源控制。其原理是将一组进程放在一个控制组里，通过给这个控制组分配指定的可用资源，达到控制这一组进程可用资源的目的。 容器最核心技术是 Namespace+Cgroup，但是光有这两个抽象的技术概念是无法组成一个完整的容器的。对于 linux 容器的最小组成，是由一下四个部分构成： Cgroup： 资源控制。 Namespace： 访问隔离。 rootfs： 系统文件隔离。 容器引擎： 生命周期控制。 容器的创建原理代码一123456pid = clone(fun, stack, flags, clone_arg);(flags: CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWUTS | ...) 对于以上代码，通过clone系统调用，并传入各个Namespace对应的clone flag，创建了一个新的子进程，该进程拥有自己的Namespace。从上面的代码可以看出，该进程拥有自己的pid,mount,user,net,ipc,uts namespace 。 代码二：123456echo $pid &gt; /sys/fs/cgroup/cpu/tasksecho $pid &gt; /sys/fs/cgroup/cpuset/tasksecho $pid &gt; /sys/fs/cgroup/blkio/tasksecho $pid &gt; /sys/fs/cgroup/memory/tasksecho $pid &gt; /sys/fs/cgroup/devices/tasksecho $pid &gt; /sys/fs/cgroup/freezer/tasks 对于代码二，将代码一中的pid写入各个Cgroup子系统中，这样该进程就可以受到相应Cgroup子系统的控制。 代码三：12345678910fun ()&#123; ... pivot_root(\"path_of_rootfs/\", path); ... exec(\"/bin/bash\"); ...&#125; 对于代码三，该fun函数由上面生成的新进程执行，在fun函数中，通过pivot_root系统调用，使进程进入新的rootfs，之后通过exec系统调用，在新的Namespace,Cgroup,rootfs中执行&quot;/bin/bash&quot;程序。 通过以上操作，成功在一个“容器”中运行了一个bash程序。对于Cgroup和Namespace的技术细节，我们下一节详细描述 CgroupCgroup 是什么Cgroup是control group 的简写，属于 Linux 内核提供的一个特性，用于限制和隔离一组进程对系统资源的使用。这些资源主要包括 CPU， 内存， block I/O（数据块 I/O） 和网络宽带。Cgroup 从 2.6.24版本进入内核主线，目前各大发行版linux都默认打开了 Cgroup 特性 从实现的角度来看，Cgroup 实现了一个通用的进程分组的框架，而不同资源的具体管理则是由各个 Cgroup 子系统实现的。截止内核4.1版本，Cgroup 中实现的子系统的及其作用如下： devices： 设备权限控制 cpuset： 分配指定的CPU和内存节点 cpu： 控制 CPU 占用率 cpuacct： 统计 CPU 使用情况 memory： 限制内存的使用上限 freezer： 冻结（暂停）Cgroup 中的进程 net_cls： 配合tc（traffic controller）限制网络宽带 net_prio： 设置进程的网络流量优先级 huge_tlb： 限制HugeTLB（块表缓冲区）的使用 perf_event： 允许 Perf 工具基于Cgroup分组做性能测试 NamespaceNamespace 是什么Namespace 是将内核的全局资源做封装，使得每个Namespace都有有一份独立的资源，因此不同的进程各自的 Namespace 内对同一个资源的使用不会互相干扰。举个例子，执行 sethostname 这个系统调用时，可以改变系统的主机名，这个主机名就是一个内核的全局资源。内核通过实现 UTS Namespace，可以将不同的进程分隔在不同的 UTS Namespace 中，在某个 Namespace 修改主机名时，另一个 Namespace 的主机名还是保持不变。 目前 Linux 内核总共实现了6种 Namespace： IPC： 隔离 System V IPC 和 POSIX 消息队列 Network： 隔离网络资源 Mount： 隔离文件系统挂载点 PID： 隔离进程 ID UTS： 隔离主机名和域名 User： 隔离用户 ID 和 组 ID Namespace 和 Cgroup 的使用是灵活的，同时也有不少需要注意的地方，因此直接操作 Namespace 和 Cgroup 并不是很容易。正是因为这些原因，Docker 通过 Libcontainer 来处理这些底层的事情。这样一来，Docker 只需简单地调用 Libcontainer 的 API ，就能将完整的容器搭建起来。而作为 Docker 的用户，就更不用操心这些事情了。 容器造就 Docker关于容器是否是 Docker 的技术核心技术，业界一直存在着争议。 在理解了容器，理解了容器的核心技术 Cgroup 和 Namespace，理解了容器技术如何巧妙且轻量地实现“容器”本身的资源控制和访问隔离之后，可以看到 Docker 和容器是一种完美的融合和辅助相成的关系，它们不是唯一的搭配，但一定是最完美的结合（目前来说）。与其说是容器造就了 Docker ， 不如说是它们造就了彼此，容器技术让 Docker 得到更多的应用和推广，Docker 也使得容器技术被更多人熟知。[须知]：转载请标明出处，请尊重笔者和作者的功劳，O(∩_∩)O谢谢！[参考]:Docker 进阶与实践 华为Docker实践小组 著（机械工业出版社）","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Goddbye 2016 and Hello 2017","slug":"再见了2016，你好2017","date":"2016-12-31T09:07:55.000Z","updated":"2016-12-31T09:07:56.000Z","comments":true,"path":"2016/12/31/再见了2016，你好2017/","link":"","permalink":"http://yusank.github.io/2016/12/31/再见了2016，你好2017/","excerpt":"突然想写一篇文章纪念一下我的2016，语文水平不是很好，要是写的不好，就不要在意太多的细节了，以下正文。。。。","text":"突然想写一篇文章纪念一下我的2016，语文水平不是很好，要是写的不好，就不要在意太多的细节了，以下正文。。。。 再见了2016，你好2017来点音乐吧， ​ 纵观过去的这一年，发生了很多我没有预料的到时事儿，不管是感情还是学习工作方面。 ​ 去年的今天我做了不少的计划，许了不少的愿，但是实现了几个没做到几个，现在我是真想不出来。从我现在的情况来看，2016过得并不是很糟糕，也许可以用过得还不错的这句话来形容。 ​ 寒假跟每年的寒假没有任何区别，玩儿吃喝，非要说有区别的话，我还是想不起来任何的区别【微笑】。3月份回学校，做了我人生第一次烫发，自我感觉还可以。生活还是一如既往，学习吃饭周末出去通宵。就这样，2016年也快一半了，6月初的出去旅游，给我们每个人一次难忘的回忆，那回忆如此的美好，甜蜜。然而好梦总是不长的，6月末，我听到了一个我最不想听的一个消息。以前一直以为如果真有这么一天，我会怎么怎么样。但是真的碰到了这个情况的时候，我不知道该干嘛了，不知道该为自己伤心还是为她开心，但是我不认为这就是最终结果。一个对我来说是一个不是很正常的暑假的开始了，除了一个月帮老爸跑腿开车以为，我脑子里只有一个人，也许这就是爱吧。但是我一直都只动嘴皮子不干实际性的，到目前我都很后悔这事儿。 ​ 暑假结束回到学校不到两个月，我遇到了思异，遇到了我的人生转折点。大学两年荒废过去的我终于见到一丁点曙光在远处向我招手，我不能再荒废下去了，我得努力，我得为以后找出路。就这样，我的几乎每一天都是要么在实习要么在去实习的路上度过，一直到现在，2016的最后一天。 ​ 这几个月，跟她关系越来越好，感觉已经离不开她了。每次见到到都是一种幸福满，遇到她是我大学生活发生的最幸运最幸福的事情，绝对没有之一。 ​ 时间总是过得很快，一年时间说长很长说短很短，依然记得去年的今天，但是又觉得是很久之前的事儿。再过几个小时，就得送2016了，在送它之前，我还是要好好的感谢2016，给我这么多的快乐的时光，给我了配家人配爱人的时间，谢谢你！！！ ​ 在这儿我不会许什么愿做什么计划，我只是静静的等2017的到来，静静地欢迎它，不管是到来的是哪一年，我只是希望陪我欢迎新一年的人，依然是她！ 再见了2016， ​ 你好2017.","raw":null,"content":null,"categories":[],"tags":[]},{"title":"linux命令","slug":"linux命令","date":"2016-12-28T05:13:13.000Z","updated":"2016-12-28T05:13:13.000Z","comments":true,"path":"2016/12/28/linux命令/","link":"","permalink":"http://yusank.github.io/2016/12/28/linux命令/","excerpt":"welcome to learn terminal command!!!","text":"welcome to learn terminal command!!! linux命令永！远！不！要！执！行！你！不！清！楚！在！干！啥！的！命！令！实用性1$ sudo !! 以root权限执行上一条命令（注意上一条命令的内容，以免发生意外） 1$ ls -l | sed &apos;1d&apos; | sort -n -k5 | awk &apos;&#123;printf &quot;%15s %10s\\n&quot;, $9,$5&#125;&apos; 按文件大小增序打印出当前目录下的文件名及其文件大小(单位字节） 1$ history | awk &apos;&#123;print $2&#125;&apos; | sort | uniq -c | sort -rn | head -10 输出你最常用的十条命令 1$ http POST http://localhost:4000/ &lt; /&lt;json文件路径&gt; 做测试的时候很有用的一个命令，需要下载http 1$ brew install http 1234567$ lsof -n -P -i TCP -s TCP:LISTENCOMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEQQ 290 smartestee 33u IPv4 0x2f3beaa58a62d73b 0t0 TCP 127.0.0.1:4300 (LISTEN)QQ 290 smartestee 34u IPv4 0x2f3beaa58c69673b 0t0 TCP 127.0.0.1:4301 (LISTEN)idea 3257 smartestee 164u IPv4 0x2f3beaa588d11e43 0t0 TCP 127.0.0.1:6942 (LISTEN)idea 3257 smartestee 385u IPv4 0x2f3beaa58c69316b 0t0 TCP 127.0.0.1:63342 (LISTEN) 查看端口的使用情况， 1$ kill -9 xxxx 端口冲突时，用此命令，关闭某个端口。用PID替换xxxx 1$ history 查看历史命令记录 1$ pwd 当前位置 1$ which xx path位置，搭建环境的时候肯定会用得到 1$ git 必须得会的一个命令。本地库的管理用的 先给出比较常用的 1$ git add &lt;一个或多个文件名(文件名之间是用空格，也可以是一个点，表示添加全部)&gt; 1$ git commit -m &quot;注释&quot; 本地提交 1$ git checkout &lt;分支名或master&gt; 切换分支与master 1$ git branch &lt;分支名&gt; 新开一个分支 1$ git merge &lt;分支名&gt; 主分支与分支的合并 1$ git push origin master 提交到github上 压轴1$ fuck 刚发现的一个新命令，纠正命令行输入的错误，比手动改快，实用。 安装： 1$ brew install thefuck 娱乐1$ cmatrix 1$ telnet towel.blinkenlights.nl telnet是基于Telnet协议的远程登录客户端程序,经常用来远程登录服务器.除此还可以用它来观看星球大战 1$ fortune 随机输出名言或者笑话， 还有很多，有兴趣的可以通过这个链接去看：知乎 比较牛逼的一个查找命令的网站：http://www.commandlinefu.com/commands/browse/sort-by-votes 每天都有更新各种命令组合","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Material 的配置","slug":" Material 原质","date":"2016-12-18T06:14:14.000Z","updated":"2016-12-19T06:14:14.000Z","comments":true,"path":"2016/12/18/ Material 原质/","link":"","permalink":"http://yusank.github.io/2016/12/18/ Material 原质/","excerpt":"","text":"Material 原质Material Theme Nature, Source stay with light`s Contents 目录 General 概括 Demo 演示 Quick start 快速开始 Docs 文档 Contributing 贡献 License 许可证 Render 渲染 Changelog 开发日志 General 概括 Demo 演示Viosey’s Blog Quick start 快速开始Install Material 安装 Material Docs 文档Material Theme Docs Material 主题文档 Docs Markdown Files Contributing 贡献All kinds of contributions (enhancements, new features, documentation &amp; code improvements, issues &amp; bugs reporting) are welcome. 欢迎各种形式的贡献，包括但不限于优化，添加功能，文档 &amp; 代码的改进，问题和 bugs 的报告。期待您的 Pull Request。 License 许可证 Open sourced under the GPL v3.0 license. 根据 GPL V3.0 许可证开源。 Render 渲染","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Python 资源大全","slug":"awesomepython","date":"2016-12-17T12:55:55.000Z","updated":"2016-12-16T12:48:35.000Z","comments":true,"path":"2016/12/17/awesomepython/","link":"","permalink":"http://yusank.github.io/2016/12/17/awesomepython/","excerpt":"Python 资源大全中文版","text":"Python 资源大全中文版 我想很多程序员应该记得 GitHub 上有一个 Awesome - XXX 系列的资源整理。awesome-python 是 vinta 发起维护的 Python 资源列表，内容包括：Web框架、网络爬虫、网络内容提取、模板引擎、数据库、数据可视化、图片处理、文本处理、自然语言处理、机器学习、日志、代码分析等。由伯乐在线持续更新。 Awesome 系列虽然挺全，但基本只对收录的资源做了极为简要的介绍，如果有更详细的中文介绍，对相应开发者的帮助会更大。这也是我们发起这个开源项目的初衷。 我们要做什么？ 基于 awesome-python 列表，我们将对其中的各个资源项进行编译整理。此外还将从其他来源补充好资源。 整理后的内容，将收录在伯乐在线资源频道。可参考已整理的内容： 《Scrapy：Python的爬虫框架》 《Flask：一个使用Python编写的轻量级Web应用框架》 如何参与本项目？从下面的目录来看，本项目的工作量小不了，所以非常期待能有更多程序员一起来参与。 不过加入前，有几个小要求： 英文还不错，能读懂英文并用自己的话复述； 在用 Python； 如有兴趣，请加 QQ：50872495。加 Q 时请注明「Python大全」 如何为列表贡献新资源？欢迎大家为列表贡献高质量的新资源，提交PR时请参照以下要求： 请确保推荐的资源自己使用过 提交PR时请注明推荐理由 资源列表管理收到PR请求后，会定期（每周）在微博转发本周提交的PR列表，并在微博上面听取使用过这些资源的意见。确认通过后，会加入资源大全。 感谢您的贡献！ 本项目的参与者 维护者： 贡献者：艾凌风、Namco、Daetalus、黄利民、atupal、rainbow、木头lbj、beyondwu、cissoid、李广胜、polyval、冰斌、赵叶宇、л stalgic、硕恩 注：名单不分排名，不定期补充更新 奖励计划虽然奖励可能并不是你加入的主要原因，但还是有必要提一下： 整理超过 20 个资源后，可在伯乐在线上开通打赏； 每整理 20 个资源，有机会获得技术书籍或各种有意思的创意、极客产品； 奖励详情 环境管理管理 Python 版本和环境的工具 p：非常简单的交互式 python 版本管理工具。官网 pyenv：简单的 Python 版本管理工具。官网 Vex：可以在虚拟环境中执行命令。官网 virtualenv：创建独立 Python 环境的工具。官网 virtualenvwrapper：virtualenv 的一组扩展。官网 包管理管理包和依赖的工具。 pip：Python 包和依赖关系管理工具。官网 pip-tools：保证 Python 包依赖关系更新的一组工具。官网 conda：跨平台，Python 二进制包管理工具。官网 Curdling：管理 Python 包的命令行工具。官网 wheel：Python 分发的新标准，意在取代 eggs。官网 包仓库本地 PyPI 仓库服务和代理。 warehouse：下一代 PyPI。官网 Warehouse：PyPA 提供的 PyPI 镜像工具。官网 bandersnatch devpi：PyPI 服务和打包/测试/分发工具。官网 localshop：本地 PyPI 服务（自定义包并且自动对 PyPI 镜像）。官网 分发打包为可执行文件以便分发。 PyInstaller：将 Python 程序转换成独立的执行文件（跨平台）。官网 dh-virtualenv：构建并将 virtualenv 虚拟环境作为一个 Debian 包来发布。官网 Nuitka：将脚本、模块、包编译成可执行文件或扩展模块。官网 py2app：将 Python 脚本变为独立软件包（Mac OS X）。官网 py2exe：将 Python 脚本变为独立软件包（Windows）。官网 pynsist：一个用来创建 Windows 安装程序的工具，可以在安装程序中打包 Python本身。官网 构建工具将源码编译成软件。 buildout：一个构建系统，从多个组件来创建，组装和部署应用。官网 BitBake：针对嵌入式 Linux 的类似 make 的构建工具。官网 fabricate：对任何语言自动找到依赖关系的构建工具。官网 PlatformIO：多平台命令行构建工具。官网 PyBuilder：纯 Python 实现的持续化构建工具。官网 SCons：软件构建工具。官网 交互式解析器交互式 Python 解析器。 IPython：功能丰富的工具，非常有效的使用交互式 Python。官网 bpython：界面丰富的 Python 解析器。官网 ptpython：高级交互式Python解析器， 构建于python-prompt-toolkit 之上。官网 文件文件管理和 MIME（多用途的网际邮件扩充协议）类型检测。 imghdr：（Python 标准库）检测图片类型。官网 mimetypes：（Python 标准库）将文件名映射为 MIME 类型。官网 path.py：对 os.path 进行封装的模块。官网 pathlib：（Python3.4+ 标准库）跨平台的、面向对象的路径操作库。官网 python-magic：文件类型检测的第三方库 libmagic 的 Python 接口。官网 Unipath：用面向对象的方式操作文件和目录。官网 watchdog：管理文件系统事件的 API 和 shell 工具官网 日期和时间操作日期和时间的类库。 arrow：更好的 Python 日期时间操作类库。官网 Chronyk：Python 3 的类库，用于解析手写格式的时间和日期。官网 dateutil：Python datetime 模块的扩展。官网 delorean：解决 Python 中有关日期处理的棘手问题的库。官网 moment：一个用来处理时间和日期的Python库。灵感来自于Moment.js。官网 PyTime：一个简单易用的Python模块，用于通过字符串来操作日期/时间。官网 pytz：现代以及历史版本的世界时区定义。将时区数据库引入Python。官网 when.py：提供用户友好的函数来帮助用户进行常用的日期和时间操作。官网 文本处理用于解析和操作文本的库。 通用 chardet：字符编码检测器，兼容 Python2 和 Python3。官网 difflib：(Python 标准库)帮助我们进行差异化比较。官网 ftfy：让Unicode文本更完整更连贯。官网 fuzzywuzzy：模糊字符串匹配。官网 Levenshtein：快速计算编辑距离以及字符串的相似度。官网 pangu.py：在中日韩语字符和数字字母之间添加空格。官网 yfiglet-figlet：pyfiglet -figlet 的 Python实现。 shortuuid：一个生成器库，用以生成简洁的，明白的，URL 安全的 UUID。官网 unidecode：Unicode 文本的 ASCII 转换形式 。官网 uniout：打印可读的字符，而不是转义的字符串。官网 xpinyin：一个用于把汉字转换为拼音的库。官网 simplejson：Python的JSON编码、解码器。官网、GitHub Slug化 awesome-slugify：一个 Python slug 化库，可以保持 Unicode。官网 python-slugify：Python slug 化库，可以把 unicode 转化为 ASCII。官网 unicode-slugify：一个 slug 工具，可以生成 unicode slugs ,需要依赖 Django 。官网 解析器 phonenumbers：解析，格式化，储存，验证电话号码。官网 PLY：lex 和 yacc 解析工具的 Python 实现。官网 Pygments：通用语法高亮工具。官网 pyparsing：生成通用解析器的框架。官网 python-nameparser：把一个人名分解为几个独立的部分。官网 python-user-agents：浏览器 user agent 解析器。官网 sqlparse：一个无验证的 SQL 解析器。官网 特殊文本格式处理一些用来解析和操作特殊文本格式的库。 通用 tablib：一个用来处理中表格数据的模块。官网 Office Marmir：把输入的Python 数据结构转换为电子表单。官网 openpyxl：一个用来读写 Excel 2010 xlsx/xlsm/xltx/xltm 文件的库。官网 python-docx：读取，查询以及修改 Microsoft Word 2007/2008 docx 文件。官网 unoconv：在 LibreOffice/OpenOffice 支持的任意文件格式之间进行转换。官网 XlsxWriter：一个用于创建 Excel .xlsx 文件的 Python 模块。官网 xlwings：一个使得在 Excel 中方便调用 Python 的库（反之亦然），基于 BSD 协议。官网 xlwt：读写 Excel 文件的数据和格式信息。官网 / xlrd relatorio：模板化OpenDocument 文件。官网 PDF PDFMiner：一个用于从PDF文档中抽取信息的工具。官网 PyPDF2：一个可以分割，合并和转换 PDF 页面的库。官网 ReportLab：快速创建富文本 PDF 文档。官网 Markdown Mistune：快速并且功能齐全的纯 Python 实现的 Markdown 解析器。官网 Python-Markdown：John Gruber’s Markdown 的 Python 版实现。官网 Python-Markdiwn2：纯 Python 实现的 Markdown 解析器，比 Python-Markdown 更快，更准确，可扩展。官网 YAML PyYAML：Python 版本的 YAML 解析器。官网 CSV csvkit：用于转换和操作 CSV 的工具。官网 Archive unp：一个用来方便解包归档文件的命令行工具。官网 自然语言处理用来处理人类语言的库。 NLTK：一个先进的平台，用以构建处理人类语言数据的 Python 程序。官网 jieba：中文分词工具。官网 langid.py：独立的语言识别系统。官网 Pattern：Python 网络信息挖掘模块。官网 SnowNLP：一个用来处理中文文本的库。官网 TextBlob：为进行普通自然语言处理任务提供一致的 API。官网 TextGrocery：一简单高效的短文本分类工具，基于 LibLinear 和 Jieba。官网 文档用以生成项目文档的库。 Sphinx：Python 文档生成器。官网 awesome-sphinxdoc：官网 MkDocs：对 Markdown 友好的文档生成器。官网 pdoc：一个可以替换Epydoc 的库，可以自动生成 Python 库的 API 文档。官网 Pycco：文学编程（literate-programming）风格的文档生成器。官网 配置用来保存和解析配置的库。 config：logging 模块作者写的分级配置模块。官网 ConfigObj：INI 文件解析器，带验证功能。官网 ConfigParser：(Python 标准库) INI 文件解析器。官网 profig：通过多种格式进行配置，具有数值转换功能。官网 python-decouple：将设置和代码完全隔离。官网 命令行工具用于创建命令行程序的库。 命令行程序开发 cement：Python 的命令行程序框架。官网 click：一个通过组合的方式来创建精美命令行界面的包。官网 cliff：一个用于创建命令行程序的框架，可以创建具有多层命令的命令行程序。官网 clint：Python 命令行程序工具。官网 colorama：跨平台彩色终端文本。官网 docopt：Python 风格的命令行参数解析器。官网 Gooey：一条命令，将命令行程序变成一个 GUI 程序。官网 python-prompt-toolkit：一个用于构建强大的交互式命令行程序的库。官网 Pythonpy：在命令行中直接执行任何Python指令。官网 生产力工具 aws-cli：Amazon Web Services 的通用命令行界面。官网 bashplotlib：在终端中进行基本绘图。官网 caniusepython3：判断是哪个项目妨碍你你移植到 Python 3。官网 cookiecutter：从 cookiecutters（项目模板）创建项目的一个命令行工具。官网 doitlive：一个用来在终端中进行现场演示的工具。官网 howdoi：通过命令行获取即时的编程问题解答。官网 httpie：一个命令行HTTP 客户端，cURL 的替代品，易用性更好。官网 PathPicker：从bash输出中选出文件。官网 percol：向UNIX shell 传统管道概念中加入交互式选择功能。官网 SAWS：一个加强版的 AWS 命令行。官网 thefuck：修正你之前的命令行指令。官网 mycli：一个 MySQL 命令行客户端，具有自动补全和语法高亮功能。官网 pgcli：Postgres 命令行工具，具有自动补全和语法高亮功能。官网 下载器用来进行下载的库. s3cmd：一个用来管理Amazon S3 和 CloudFront 的命令行工具。官网 s4cmd：超级 S3 命令行工具，性能更加强劲。官网 you-get：一个 YouTube/Youku/Niconico 视频下载器，使用 Python3 编写。官网 youtube-dl：一个小巧的命令行程序，用来下载 YouTube 视频。官网 图像处理用来操作图像的库. pillow：Pillow 是一个更加易用版的 PIL。官网 hmap：图像直方图映射。官网 imgSeek：一个使用视觉相似性搜索一组图片集合的项目。官网 nude.py：裸体检测。官网 pyBarcode：不借助 PIL 库在 Python 程序中生成条形码。官网 pygram：类似 Instagram 的图像滤镜。官网 python-qrcode：一个纯 Python 实现的二维码生成器。官网 Quads：基于四叉树的计算机艺术。官网 scikit-image：一个用于（科学）图像处理的 Python 库。官网 thumbor：一个小型图像服务，具有剪裁，尺寸重设和翻转功能。官网 wand：MagickWand的Python 绑定。MagickWand 是 ImageMagick的 C API 。官网 OCR光学字符识别库。 pyocr：Tesseract 和 Cuneiform 的一个封装(wrapper)。官网 pytesseract：Google Tesseract OCR 的另一个封装(wrapper)。官网 python-tesseract - Google Tesseract OCR 的一个包装类。 音频用来操作音频的库 audiolazy：Python 的数字信号处理包。官网 audioread：交叉库 (GStreamer + Core Audio + MAD + FFmpeg) 音频解码。官网 beets：一个音乐库管理工具及 MusicBrainz 标签添加工具官网 dejavu：音频指纹提取和识别官网 django-elastic-transcoder：Django + Amazon Elastic Transcoder。官网 eyeD3：一个用来操作音频文件的工具，具体来讲就是包含 ID3 元信息的 MP3 文件。官网 id3reader：一个用来读取 MP3 元数据的 Python 模块。官网 m3u8：一个用来解析 m3u8 文件的模块。官网 mutagen：一个用来处理音频元数据的 Python 模块。官网 pydub：通过简单、简洁的高层接口来操作音频文件。官网 pyechonest：Echo Nest API 的 Python 客户端官网 talkbox：一个用来处理演讲/信号的 Python 库官网 TimeSide：开源 web 音频处理框架。官网 tinytag：一个用来读取MP3, OGG, FLAC 以及 Wave 文件音乐元数据的库。官网 mingus：一个高级音乐理论和曲谱包，支持 MIDI 文件和回放功能。官网 Video用来操作视频和GIF的库。 moviepy：一个用来进行基于脚本的视频编辑模块，适用于多种格式，包括动图 GIFs。官网 scikit-video：SciPy 视频处理常用程序。官网 地理位置地理编码地址以及用来处理经纬度的库。 GeoDjango：世界级地理图形 web 框架。官网 GeoIP：MaxMind GeoIP Legacy 数据库的 Python API。官网 geojson：GeoJSON 的 Python 绑定及工具。官网 geopy：Python 地址编码工具箱。官网 pygeoip：纯 Python GeoIP API。官网 django-countries：一个 Django 应用程序，提供用于表格的国家选择功能，国旗图标静态文件以及模型中的国家字段。官网 HTTP使用HTTP的库。 requests：人性化的HTTP请求库。官网 grequests：requests 库 + gevent ，用于异步 HTTP 请求.官网 httplib2：全面的 HTTP 客户端库。官网 treq：类似 requests 的Python API 构建于 Twisted HTTP 客户端之上。官网 urllib3：一个具有线程安全连接池，支持文件 post，清晰友好的 HTTP 库。官网 数据库Python实现的数据库。 pickleDB：一个简单，轻量级键值储存数据库。官网 PipelineDB：流式 SQL 数据库。官网 TinyDB：一个微型的，面向文档型数据库。官网 ZODB：一个 Python 原生对象数据库。一个键值和对象图数据库。官网 数据库驱动用来连接和操作数据库的库。 MySQL：awesome-mysql系列 mysql-python：Python 的 MySQL 数据库连接器。官网 ysqlclient：mysql-python 分支，支持 Python 3。 oursql：一个更好的 MySQL 连接器，支持原生预编译指令和 BLOBs.官网 PyMySQL：纯 Python MySQL 驱动，兼容 mysql-python。官网 PostgreSQL psycopg2：Python 中最流行的 PostgreSQL 适配器。官网 queries：psycopg2 库的封装，用来和 PostgreSQL 进行交互。官网 txpostgres：基于 Twisted 的异步 PostgreSQL 驱动。官网 其他关系型数据库 apsw：另一个 Python SQLite封装。官网 dataset：在数据库中存储Python字典 pymssql：一个简单的Microsoft SQL Server数据库接口。官网 NoSQL 数据库 cassandra-python-driver：Cassandra 的 Python 驱动。官网 HappyBase：一个为 Apache HBase 设计的，对开发者友好的库。官网 Plyvel：一个快速且功能丰富的 LevelDB 的 Python 接口。官网 py2neo：Neo4j restful 接口的Python 封装客户端。官网 pycassa：Cassandra 的 Python Thrift 驱动。官网 PyMongo：MongoDB 的官方 Python 客户端。官网 redis-py：Redis 的 Python 客户端。官网 telephus：基于 Twisted 的 Cassandra 客户端。官网 txRedis：基于 Twisted 的 Redis 客户端。官网 ORM实现对象关系映射或数据映射技术的库。 关系型数据库 Django Models：Django 的一部分。官网 SQLAlchemy：Python SQL 工具以及对象关系映射工具。官网 awesome-sqlalchemy系列 Peewee：一个小巧，富有表达力的 ORM。官网 PonyORM：提供面向生成器的 SQL 接口的 ORM。官网 python-sql：编写 Python 风格的 SQL 查询。官网 NoSQL 数据库 django-mongodb-engine：Django MongoDB 后端。官网 PynamoDB：Amazon DynamoDB 的一个 Python 风格接口。官网 flywheel：Amazon DynamoDB 的对象映射工具。官网 MongoEngine：一个Python 对象文档映射工具，用于 MongoDB。官网 hot-redis：为 Redis 提供 Python 丰富的数据类型。官网 redisco：一个 Python 库，提供可以持续存在在 Redis 中的简单模型和容器。官网 其他 butterdb：Google Drive 电子表格的 Python ORM。官网 Web 框架全栈 Web 框架。 Django：Python 界最流行的 web 框架。官网 awesome-django系列 Flask：一个 Python 微型框架。官网 awesome-flask系列 pyramid：一个小巧，快速，接地气的开源Python web 框架。 awesome-pyramid系列 Bottle：一个快速小巧，轻量级的 WSGI 微型 web 框架。官网 CherryPy：一个极简的 Python web 框架，服从 HTTP/1.1 协议且具有WSGI 线程池。官网 TurboGears：一个可以扩展为全栈解决方案的微型框架。官网 web.py：一个 Python 的 web 框架，既简单，又强大。官网 web2py：一个全栈 web 框架和平台，专注于简单易用。官网 Tornado：一个web 框架和异步网络库。官网 权限允许或拒绝用户访问数据或功能的库。 Carteblanche：Module to align code with thoughts of users and designers. Also magically handles navigation and permissions.官网 django-guardian：Django 1.2+ 实现了单个对象权限。官网 django-rules：一个小巧但是强大的应用，提供对象级别的权限管理，且不需要使用数据库。官网 CMS内容管理系统 odoo-cms: 一个开源的，企业级 CMS，基于odoo。官网 django-cms：一个开源的，企业级 CMS，基于 Django。官网 djedi-cms：一个轻量级但却非常强大的 Django CMS ，考虑到了插件，内联编辑以及性能。官网 FeinCMS：基于 Django 构建的最先进的内容管理系统之一。官网 Kotti：一个高级的，Python 范的 web 应用框架，基于 Pyramid 构建。官网 Mezzanine：一个强大的，持续的，灵活的内容管理平台。官网 Opps：一个为杂志，报纸网站以及大流量门户网站设计的 CMS 平台，基于 Django。官网 Plone：一个构建于开源应用服务器 Zope 之上的 CMS。官网 Quokka：灵活，可扩展的小型 CMS，基于 Flask 和 MongoDB。官网 Wagtail：一个 Django 内容管理系统。官网 Widgy：最新的 CMS 框架，基于 Django。官网 电子商务用于电子商务以及支付的框架和库。 django-oscar：一个用于 Django 的开源的电子商务框架。官网 django-shop：一个基于 Django 的店铺系统。官网 Cartridge：一个基于 Mezzanine 构建的购物车应用。官网 shoop：一个基于 Django 的开源电子商务平台。官网 alipay：非官方的 Python 支付宝 API。官网 merchant：一个可以接收来自多种支付平台支付的 Django 应用。官网 money：货币类库with optional CLDR-backed locale-aware formatting and an extensible currency exchange solution.官网 python-currencies：显示货币格式以及它的数值。官网 RESTful API用来开发RESTful APIs的库 Django django-rest-framework：一个强大灵活的工具，用来构建 web API。官网 django-tastypie：为Django 应用开发API。官网 django-formapi：为 Django 的表单验证，创建 JSON APIs 。官网 Flask flask-api：为 flask 开发的，可浏览 Web APIs 。官网 flask-restful：为 flask 快速创建REST APIs 。官网 flask-restless：为 SQLAlchemy 定义的数据库模型创建 RESTful APIs 。官网 flask-api-utils：为 Flask 处理 API 表示和验证。官网 eve：REST API 框架，由 Flask, MongoDB 等驱动。官网 Pyramid cornice：一个Pyramid 的 REST 框架 。官网 与框架无关的 falcon：一个用来建立云 API 和 web app 后端的高性能框架。官网 sandman：为现存的数据库驱动系统自动创建 REST APIs 。官网 restless：框架无关的 REST 框架 ，基于从 Tastypie 学到的知识。官网 ripozo：快速创建 REST/HATEOAS/Hypermedia APIs。官网 验证实现验证方案的库。 OAuth Authomatic：简单但是强大的框架，身份验证/授权客户端。官网 django-allauth：Django 的验证应用。官网 django-oauth-toolkit：为 Django 用户准备的 OAuth2。官网 django-oauth2-provider：为 Django 应用提供 OAuth2 接入。官网 Flask-OAuthlib：OAuth 1.0/a, 2.0 客户端实现，供 Flask 使用。官网 OAuthLib：一个 OAuth 请求-签名逻辑通用、 完整的实现。官网 python-oauth2：一个完全测试的抽象接口。用来创建 OAuth 客户端和服务端。官网 python-social-auth：一个设置简单的社会化验证方式。官网 rauth：OAuth 1.0/a, 2.0, 和 Ofly 的 Python 库。官网 sanction：一个超级简单的OAuth2 客户端实现。官网 其他 jose：JavaScript 对象签名和加密草案的实现。官网 PyJWT：JSON Web 令牌草案 01。官网 python-jws：JSON Web 签名草案 02 的实现。官网 python-jwt：一个用来生成和验证 JSON Web 令牌的模块。官网 模板引擎模板生成和词法解析的库和工具。 Jinja2：一个现代的，对设计师友好的模板引擎。官网 Chameleon：一个 HTML/XML 模板引擎。 模仿了 ZPT（Zope Page Templates）, 进行了速度上的优化。官网 Genshi：Python 模板工具，用以生成 web 感知的结果。官网 Mako：Python 平台的超高速轻量级模板。官网 Queue处理事件以及任务队列的库。 celery：一个异步任务队列/作业队列，基于分布式消息传递。官网 huey：小型多线程任务队列。官网 mrq：Mr. Queue -一个 Python 的分布式 worker 任务队列， 使用 Redis 和 gevent。官网 rq：简单的 Python 作业队列。官网 simpleq：一个简单的，可无限扩张的，基于亚马逊 SQS 的队列。官网 搜索对数据进行索引和执行搜索查询的库和软件。 django-haystack：Django 模块化搜索。官网 elasticsearch-py：Elasticsearch 的官方底层 Python 客户端。官网 elasticsearch-dsl-py：Elasticsearch 的官方高级 Python 客户端。官网 solrpy：solr的 Python 客户端。官网 Whoosh：一个快速的纯 Python 搜索引擎库。官网 动态消息用来创建用户活动的库。 django-activity-stream：从你的站点行为中生成通用活动信息流。官网 Stream-Framework：使用 Cassandra 和 Redis 创建动态消息和通知系统。官网 资源管理管理、压缩、缩小网站资源的工具。 django-compressor：将链接和内联的 JavaScript 或 CSS 压缩到一个单独的缓存文件中。官网 django-storages：一个针对 Django 的自定义存储后端的工具集合。官网 fanstatic：打包、优化，并且把静态文件依赖作为 Python 的包来提供。官网 File Conveyor：一个后台驻留的程序，用来发现和同步文件到 CDNs, S3 和 FTP。官网 Flask-Assets：帮你将 web 资源整合到你的 Flask app 中。官网 jinja-assets-compressor：一个 Jinja 扩展，用来编译和压缩你的资源。官网 webassets：为你的静态资源打包、优化和管理生成独一无二的缓存 URL。官网 缓存缓存数据的库。 Beaker：一个缓存和会话库，可以用在 web 应用和独立 Python脚本和应用上。官网 django-cache-machine：Django 模型的自动缓存和失效。官网 django-cacheops：具有自动颗粒化事件驱动失效功能的 ORM。官网 django-viewlet：渲染模板，同时具有额外的缓存控制功能。官网 dogpile.cache：dogpile.cache 是 Beaker 的下一代替代品，由同一作者开发。官网 HermesCache：Python 缓存库，具有基于标签的失效和 dogpile effect 保护功能。官网 johnny-cache：django应用缓存框架。官网 pylibmc：libmemcached 接口的 Python 封装。官网 电子邮件用来发送和解析电子邮件的库。 django-celery-ses：带有 AWS SES 和 Celery 的 Django email 后端。官网 envelopes：供人类使用的电子邮件库。官网 flanker：一个 email 地址和 Mime 解析库。官网 imbox：Python IMAP 库官网 inbox.py：Python SMTP 服务器。官网 inbox：一个开源电子邮件工具箱。官网 lamson：Python 风格的 SMTP 应用服务器。官网 mailjet：Mailjet API 实现，用来提供批量发送邮件，统计等功能。官网 marrow.mailer：高性能可扩展邮件分发框架。官网 modoboa：一个邮件托管和管理平台，具有现代的、简约的 Web UI。官网 pyzmail：创建，发送和解析电子邮件。官网 Talon：Mailgun 库，用来抽取信息和签名。官网 国际化用来进行国际化的库。 Babel：一个Python 的国际化库。官网 Korean：一个韩语词态库。官网 URL处理解析URLs的库 furl：一个让处理 URL 更简单小型 Python 库。官网 purl：一个简单的，不可变的URL类，具有简洁的 API 来进行询问和处理。官网 pyshorteners：一个纯 Python URL 缩短库。官网 shorturl：生成短小 URL 和类似 bit.ly 短链的Python 实现。官网 webargs：一个解析 HTTP 请求参数的库，内置对流行 web 框架的支持，包括 Flask, Django, Bottle, Tornado和 Pyramid。官网 HTML处理处理 HTML和XML的库。 BeautifulSoup：以 Python 风格的方式来对 HTML 或 XML 进行迭代，搜索和修改。官网 bleach：一个基于白名单的 HTML 清理和文本链接库。官网 cssutils：一个 Python 的 CSS 库。官网 html5lib：一个兼容标准的 HTML 文档和片段解析及序列化库。官网 lxml：一个非常快速，简单易用，功能齐全的库，用来处理 HTML 和 XML。官网 MarkupSafe：为Python 实现 XML/HTML/XHTML 标记安全字符串。官网 pyquery：一个解析 HTML 的库，类似 jQuery。官网 untangle：将XML文档转换为Python对象，使其可以方便的访问。官网 xhtml2pdf：HTML/CSS 转 PDF 工具。官网 xmltodict：像处理 JSON 一样处理 XML。官网 爬取网络站点的库 Scrapy：一个快速高级的屏幕爬取及网页采集框架。官网 cola：一个分布式爬虫框架。官网 Demiurge：基于PyQuery 的爬虫微型框架。官网 feedparser：通用 feed 解析器。官网 Grab：站点爬取框架。官网 MechanicalSoup：用于自动和网络站点交互的 Python 库。官网 portia：Scrapy 可视化爬取。官网 pyspider：一个强大的爬虫系统。官网 RoboBrowser：一个简单的，Python 风格的库，用来浏览网站，而不需要一个独立安装的浏览器。官网 网页内容提取用于进行网页内容提取的库。 Haul：一个可以扩展的图像爬取工具。官网 html2text：将 HTML 转换为 Markdown 格式文本官网 lassie：人性化的网页内容检索库。官网 micawber：一个小型网页内容提取库，用来从 URLs 提取富内容。官网 newspaper：使用 Python 进行新闻提取，文章提取以及内容策展。官网 opengraph：一个用来解析开放内容协议(Open Graph Protocol)的 Python模块。官网 python-goose：HTML内容/文章提取器。官网 python-readability：arc90 公司 readability 工具的 Python 高速端口。官网 sanitize：为杂乱的数据世界带来调理性。官网 sumy：一个为文本文件和 HTML 页面进行自动摘要的模块。官网 textract：从任何格式的文档中提取文本，Word，PowerPoint，PDFs 等等。官网 表单进行表单操作的库。 Deform：Python HTML 表单生成库，受到了 formish 表单生成库的启发。官网 django-bootstrap3：集成了 Bootstrap 3 的 Django。官网 django-crispy-forms：一个 Django 应用，他可以让你以一种非常优雅且 DRY（Don’t repeat yourself） 的方式来创建美观的表单。官网 django-remote-forms：一个平台独立的 Django 表单序列化工具。官网 WTForms：一个灵活的表单验证和呈现库。官网 WTForms-JSON：一个 WTForms 扩展，用来处理 JSON 数据。官网 数据验证数据验证库。多用于表单验证。 Cerberus：A mappings-validator with a variety of rules, normalization-features and simple customization that uses a pythonic schema-definition.官网 colander：一个用于对从 XML, JSON，HTML 表单获取的数据或其他同样简单的序列化数据进行验证和反序列化的系统。官网 kmatch：一种用于匹配/验证/筛选 Python 字典的语言。官网 schema：一个用于对 Python 数据结构进行验证的库。官网 Schematics：数据结构验证。官网 valideer：轻量级可扩展的数据验证和适配库。官网 voluptuous：一个 Python 数据验证库。主要是为了验证传入 Python的 JSON，YAML 等数据。官网 反垃圾技术帮助你和电子垃圾进行战斗的库。 django-simple-captcha：一个简单、高度可定制的Django 应用，可以为任何Django表单添加验证码。官网 django-simple-spam-blocker：一个用于Django的简单的电子垃圾屏蔽工具。官网 标记用来进行标记的库。 django-taggit：简单的 Django 标记工具。官网 管理面板管理界面库。 Ajenti：一个你的服务器值得拥有的管理面板。官网 django-suit：Django 管理界面的一个替代品 (仅对于非商业用途是免费的)。官网 django-xadmin：Django admin 的一个替代品，具有很多不错的功能。官网 flask-admin：一个用于 Flask 的简单可扩展的管理界面框架。官网 flower：一个对 Celery 集群进行实时监控和提供 web 管理界面的工具。官网 Grappelli：Django 管理界面的一个漂亮的皮肤。官网 Wooey：一个 Django 应用，可以为 Python 脚本创建 web 用户界面。官网 静态站点生成器静态站点生成器是一个软件，它把文本和模板作为输入，然后输出HTML文件。 Pelican：使用 Markdown 或 ReST 来处理内容， Jinja 2 来制作主题。支持 DVCS, Disqus.。AGPL 许可。官网 Cactus：为设计师设计的静态站点生成器。官网 Hyde：基于 Jinja2 的静态站点生成器。官网 Nikola：一个静态网站和博客生成器。官网 Tinkerer：Tinkerer 是一个博客引擎/静态站点生成器，由Sphinx驱动。官网 Lektor：一个简单易用的静态 CMS 和博客引擎。官网 进程操作系统进程启动及通信库。 envoy：比 Python subprocess 模块更人性化。官网 sarge：另一 种 subprocess 模块的封装。官网 sh：一个完备的 subprocess 替代库。官网 并发和并行用以进行并发和并行操作的库。 multiprocessing：(Python 标准库) 基于进程的“线程”接口。官网 threading：(Python 标准库)更高层的线程接口。官网 eventlet：支持 WSGI 的异步框架。官网 gevent：一个基于协程的 Python 网络库，使用greenlet。官网 Tomorrow：用于产生异步代码的神奇的装饰器语法实现。官网 网络用于网络编程的库。 asyncio：(Python 标准库) 异步 I/O, 事件循环, 协程以及任务。官网 Twisted：一个事件驱动的网络引擎。官网 pulsar：事件驱动的并发框架。官网 diesel：基于Greenlet 的事件 I/O 框架。官网 pyzmq：一个 ZeroMQ 消息库的 Python 封装。官网 txZMQ：基于 Twisted 的 ZeroMQ 消息库的 Python 封装。官网 WebSocket帮助使用WebSocket的库。 AutobahnPython：给 Python 、使用的 WebSocket &amp; WAMP 基于 Twisted 和 asyncio。官网 Crossbar：开源统一应用路由(Websocket &amp; WAMP for Python on Autobahn).官网 django-socketio：给 Django 用的 WebSockets。官网 WebSocket-for-Python：为Python2/3 以及 PyPy 编写的 WebSocket 客户端和服务器库。官网 WSGI 服务器兼容 WSGI 的 web 服务器 gunicorn：Pre-forked, 部分是由 C 语言编写的。官网 uwsgi：uwsgi 项目的目的是开发一组全栈工具，用来建立托管服务， 由 C 语言编写。官网 bjoern：异步，非常快速，由 C 语言编写。官网 fapws3：异步 (仅对于网络端)，由 C 语言编写。官网 meinheld：异步，部分是由 C 语言编写的。官网 netius：异步，非常快速。官网 paste：多线程，稳定，久经考验。官网 rocket：多线程。官网 waitress：多线程, 是它驱动着 Pyramid 框架。官网 Werkzeug：一个 WSGI 工具库，驱动着 Flask ，而且可以很方便大嵌入到你的项目中去。官网 RPC 服务器兼容 RPC 的服务器。 SimpleJSONRPCServer：这个库是 JSON-RPC 规范的一个实现。官网 SimpleXMLRPCServer：(Python 标准库) 简单的 XML-RPC 服务器实现，单线程。官网 zeroRPC：zerorpc 是一个灵活的 RPC 实现，基于 ZeroMQ 和 MessagePack。官网 密码学 cryptography：这个软件包意在提供密码学基本内容和方法提供给 Python 开发者。官网 hashids：在 Python 中实现 hashids 。官网 Paramiko：SSHv2 协议的 Python (2.6+, 3.3+) ，提供客户端和服务端的功能。官网 Passlib：安全密码存储／哈希库，官网 PyCrypto：Python 密码学工具箱。官网 PyNacl：网络和密码学(NaCl) 库的 Python 绑定。官网 图形用户界面用来创建图形用户界面程序的库。 curses：内建的 ncurses 封装，用来创建终端图形用户界面。官网 enaml：使用类似 QML 的Declaratic语法来创建美观的用户界面。官网 kivy：一个用来创建自然用户交互（NUI）应用程序的库，可以运行在 Windows, Linux, Mac OS X, Android 以及 iOS平台上。官网 pyglet：一个Python 的跨平台窗口及多媒体库。官网 PyQt：跨平台用户界面框架 Qt 的 Python 绑定 ，支持Qt v4 和 Qt v5。官网 PySide：P跨平台用户界面框架 Qt 的 Python 绑定 ，支持Qt v4。官网 Tkinter：Tkinter 是 Python GUI 的一个事实标准库。官网 Toga：一个 Python 原生的, 操作系统原生的 GUI 工具包。官网 urwid：一个用来创建终端 GUI 应用的库，支持组件，事件和丰富的色彩等。官网 wxPython：wxPython 是 wxWidgets C++ 类库和 Python 语言混合的产物。官网 PyGObject：GLib/GObject/GIO/GTK+ (GTK+3) 的 Python 绑定官网 Flexx：Flexx 是一个纯 Python 语言编写的用来创建 GUI 程序的工具集，它使用 web 技术进行界面的展示。官网 游戏开发超赞的游戏开发库。 Cocos2d：cocos2d 是一个用来开发 2D 游戏， 示例和其他图形/交互应用的框架。基于 pyglet。官网 Panda3D：由迪士尼开发的 3D 游戏引擎，并由卡内基梅陇娱乐技术中心负责维护。使用C++编写, 针对 Python 进行了完全的封装。官网 Pygame：Pygame 是一组 Python 模块，用来编写游戏。官网 PyOgre：Ogre 3D 渲染引擎的 Python 绑定，可以用来开发游戏和仿真程序等任何 3D 应用。官网 PyOpenGL：OpenGL 的 Python 绑定及其相关 APIs。官网 PySDL2：SDL2 库的封装，基于 ctypes。官网 RenPy：一个视觉小说（visual novel）引擎。官网 日志用来生成和操作日志的库。 logging：(Python 标准库) 为 Python 提供日志功能。官网 logbook：Logging 库的替代品。官网 Eliot：为复杂的和分布式系统创建日志。官网 Raven：Sentry的 Python 客户端。官网 Sentry：实时记录和收集日志的服务器。官网 Testing进行代码库测试和生成测试数据的库。 测试框架 unittest：(Python 标准库) 单元测试框架。官网 nose：nose 扩展了 unittest 的功能。官网 contexts：一个 Python 3.3+ 的 BDD 框架。受到C# – Machine.Specifications的启发。官网 hypothesis：Hypothesis 是一个基于先进的 Quickcheck 风格特性的测试库。官网 mamba：Python 的终极测试工具， 拥护BDD。官网 PyAutoGUI：PyAutoGUI 是一个人性化的跨平台 GUI 自动测试模块。官网 pyshould：Should 风格的断言，基于 PyHamcrest。官网 pytest：一个成熟的全功能 Python 测试工具。官网 green：干净，多彩的测试工具。官网 pyvows：BDD 风格的测试工具，受Vows.js的启发。官网- Robot Framework：一个通用的自动化测试框架。官网 Web 测试 Selenium：Selenium WebDriver 的 Python 绑定。官网 locust：使用 Python 编写的，可扩展的用户加载测试工具。官网 sixpack：一个和语言无关的 A/B 测试框架。官网 splinter：开源的 web 应用测试工具。官网 Mock测试 mock：(Python 标准库) 一个用于伪造测试的库。官网 doublex：Python 的一个功能强大的 doubles 测试框架。官网 freezegun：通过伪造日期模块来生成不同的时间。官网 httmock：针对 Python 2.6+ 和 3.2+ 生成 伪造请求的库。官网 httpretty：Python 的 HTTP 请求 mock 工具。官网 responses：伪造 Python 中的 requests 库的一个通用库。官网 VCR.py：在你的测试中记录和重放 HTTP 交互。官网 对象工厂 factoryboy：一个 Python 用的测试固件 (test fixtures) 替代库。官网 mixer：另外一个测试固件 (test fixtures) 替代库，支持 Django, Flask, SQLAlchemy, Peewee 等。官网 modelmommy：为 Django 测试创建随机固件官网 代码覆盖率 coverage：代码覆盖率测量。官网 伪数据 faker：一个 Python 库，用来生成伪数据。官网 fake2db：伪数据库生成器。官网 radar：生成随机的日期/时间。官网 错误处理 FuckIt.py：FuckIt.py 使用最先进的技术来保证你的 Python 代码无论对错都能继续运行。官网 代码分析和Lint工具进行代码分析，解析和操作代码库的库和工具。 代码分析 code2flow：把你的 Python 和 JavaScript 代码转换为流程图。官网 pycallgraph：这个库可以把你的Python 应用的流程(调用图)进行可视化。官网 pysonar2：Python 类型推断和检索工具。官网 Lint工具 Flake8：模块化源码检查工具: pep8, pyflakes 以及 co。官网 Pylint：一个完全可定制的源码分析器。官网 pylama：Python 和 JavaScript 的代码审查工具。官网 代码格式化 autopep8：自动格式化 Python 代码，以使其符合 PEP8 规范。官网 Debugging Tools用来进行代码调试的库。 调试器 ipdb：IPython 启用的 pdb。官网 pudb：全屏，基于控制台的 Python 调试器。官网 pyringe：可以在 Python 进程中附加和注入代码的调试器。官网 wdb：一个奇异的 web 调试器，通过 WebSockets 工作。官网 winpdb：一个具有图形用户界面的 Python 调试器，可以进行远程调试，基于 rpdb2。官网 django-debug-toolbar：为 Django 显示各种调试信息。官网 django-devserver：一个 Django 运行服务器的替代品。官网 flask-debugtoolbar：django-debug-toolbar 的 flask 版。官网 性能分析器 lineprofiler：逐行性能分析。官网 Memory Profiler：监控 Python 代码的内存使用。官网、内存 profiling：一个交互式 Python 性能分析工具。官网 其他 pyelftools：解析和分析 ELF 文件以及 DWARF 调试信息。官网 python-statsd：statsd 服务器的 Python 客户端。官网 Science and Data Analysis用来进行科学计算和数据分析的库。 astropy：一个天文学 Python 库。官网 bcbio-nextgen：这个工具箱为全自动高通量测序分析提供符合最佳实践的处理流程。官网 bccb：生物分析相关代码集合官网 Biopython：Biopython 是一组可以免费使用的用来进行生物计算的工具。官网 blaze：NumPy 和 Pandas 的大数据接口。官网 cclib：一个用来解析和解释计算化学软件包输出结果的库。官网 NetworkX：一个为复杂网络设计的高性能软件。官网 Neupy：执行和测试各种不同的人工神经网络算法。官网 Numba：Python JIT (just in time) 编译器，针对科学用的 Python ，由Cython 和 NumPy 的开发者开发。官网 NumPy：使用 Python 进行科学计算的基础包。官网 Open Babel：一个化学工具箱，用来描述多种化学数据。官网 Open Mining：使用 Python 挖掘商业情报 (BI) (Pandas web 接口)。官网 orange：通过可视化编程或 Python 脚本进行数据挖掘，数据可视化，分析和机器学习。官网 Pandas：提供高性能，易用的数据结构和数据分析工具。官网 PyDy：PyDy 是 Python Dynamics 的缩写，用来为动力学运动建模工作流程提供帮助， 基于 NumPy, SciPy, IPython 和 matplotlib。官网 PyMC：马尔科夫链蒙特卡洛采样工具。官网 RDKit：化学信息学和机器学习软件。官网 SciPy：由一些基于 Python ，用于数学，科学和工程的开源软件构成的生态系统。官网 statsmodels：统计建模和计量经济学。官网 SymPy：一个用于符号数学的 Python 库。官网 zipline：一个 Python 算法交易库。官网 Bayesian-belief-networks：优雅的贝叶斯信念网络框架。官网 数据可视化进行数据可视化的库。 参见: awesome-javascript。 matplotlib：一个 Python 2D 绘图库。官网 bokeh：用 Python 进行交互式 web 绘图。官网 ggplot：ggplot2 给 R 提供的 API 的 Python 版本。官网 plotly：协同 Python 和 matplotlib 工作的 web 绘图库。官网 pygal：一个 Python SVG 图表创建工具。官网 pygraphviz：Graphviz 的 Python 接口。官网 PyQtGraph：交互式实时2D/3D/图像绘制及科学/工程学组件。官网 SnakeViz：一个基于浏览器的 Python’s cProfile 模块输出结果查看工具。官网 vincent：把 Python 转换为 Vega 语法的转换工具。官网 VisPy：基于 OpenGL 的高性能科学可视化工具。官网 计算机视觉计算机视觉库。 OpenCV：开源计算机视觉库。官网 SimpleCV：一个用来创建计算机视觉应用的开源框架。官网 机器学习机器学习库。 参见: awesome-machine-learning. Crab：灵活、快速的推荐引擎。官网 gensim：人性化的话题建模库。官网 hebel：GPU 加速的深度学习库。官网 NuPIC：智能计算 Numenta 平台。官网 pattern：Python 网络挖掘模块。官网 PyBrain：另一个 Python 机器学习库。官网 Pylearn2：一个基于 Theano 的机器学习库。官网 python-recsys：一个用来实现推荐系统的 Python 库。官网 scikit-learn：基于 SciPy 构建的机器学习 Python 模块。官网 pydeep：Python 深度学习库。官网 vowpalporpoise：轻量级 Vowpal Wabbit 的 Python 封装。官网 skflow：一个 TensorFlow 的简化接口(模仿 scikit-learn)。官网 MapReduceMapReduce 框架和库。 dpark：Spark 的 Python 克隆版，一个类似 MapReduce 的框架。官网 dumbo：这个 Python 模块可以让人轻松的编写和运行 Hadoop 程序。官网 luigi：这个模块帮你构建批处理作业的复杂流水线。官网 mrjob：在 Hadoop 或 Amazon Web Services 上运行 MapReduce 任务。官网 PySpark：Spark 的 Python API 。官网 streamparse：运行针对事实数据流的 Python 代码。集成了Apache Storm。官网 函数式编程使用 Python 进行函数式编程。 CyToolz：Toolz 的 Cython 实现 : 高性能函数式工具。官网 fn.py：在 Python 中进行函数式编程 : 实现了一些享受函数式编程缺失的功能。官网 funcy：炫酷又实用的函数式工具。官网 Toolz：一组用于迭代器，函数和字典的函数式编程工具。官网 第三方 API用来访问第三方 API的库。 参见： List of Python API Wrappers and Libraries。 apache-libcloud：一个为各种云设计的 Python 库。官网 boto：Amazon Web Services 的 Python 接口。官网 django-wordpress：WordPress models and views for Django.官网 facebook-sdk：Facebook 平台的 Python SDK.官网 facepy：Facepy 让和 Facebook’s Graph API 的交互变得更容易。官网 gmail：Gmail 的 Python 接口。官网 google-api-python-client：Python 用的 Google APIs 客户端库。官网 gspread：Google 电子表格的 Python API.官网 twython：Twitter API 的封装。官网 DevOps 工具用于 DevOps 的软件和库。 Ansible：一个非常简单的 IT 自动化平台。官网 SaltStack：基础设施自动化和管理系统。官网 OpenStack：用于构建私有和公有云的开源软件。官网 Docker Compose：快速，分离的开发环境，使用 Docker。官网 Fabric：一个简单的，Python 风格的工具，用来进行远程执行和部署。官网 cuisine：为 Fabric 提供一系列高级函数。官网 Fabtools：一个用来编写超赞的 Fabric 文件的工具。官网 gitapi：Git 的纯 Python API。官网 hgapi：Mercurial 的纯 Python API。官网 honcho：Foreman的 Python 克隆版，用来管理基于Procfile的应用。官网 pexpect：Controlling interactive programs in a pseudo-terminal like 在一个伪终端中控制交互程序，就像 GNU expect 一样。官网 psutil：一个跨平台进程和系统工具模块。官网 supervisor：UNIX 的进程控制系统。官网 任务调度任务调度库。 APScheduler：轻巧但强大的进程内任务调度，使你可以调度函数。官网 django-schedule：一个 Django 排程应用。官网 doit：一个任务执行和构建工具。官网 gunnery：分布式系统使用的多用途任务执行工具 ，具有 web 交互界面。官网 Joblib：一组为 Python 提供轻量级作业流水线的工具。官网 Plan：如有神助地编写 crontab 文件。官网 schedule：人性化的 Python 任务调度库。官网 Spiff：使用纯 Python 实现的强大的工作流引擎。官网 TaskFlow：一个可以让你方便执行任务的 Python 库，一致并且可靠。官网 外来函数接口使用外来函数接口的库。 cffi：用来调用 C 代码的外来函数接口。官网 ctypes：(Python 标准库) 用来调用 C 代码的外来函数接口。官网 PyCUDA：Nvidia CUDA API 的封装。官网 SWIG：简化的封装和接口生成器。官网 高性能让 Python 更快的库。 Cython：优化的 Python 静态编译器。使用类型混合使 Python 编译成 C 或 C++ 模块来获得性能的极大提升。官网 PeachPy：嵌入 Python 的 x86-64 汇编器。可以被用作 Python 内联的汇编器或者是独立的汇编器，用于 Windows, Linux, OS X, Native Client 或者 Go 。官网 PyPy：使用 Python 实现的 Python。解释器使用黑魔法加快 Python 运行速度且不需要加入额外的类型信息。官网 Pyston：使用 LLVM 和现代 JIT 技术构建的 Python 实现，目标是为了获得很好的性能。官网 Stackless Python：一个强化版的 Python。官网 微软的 Windows平台在 Windows 平台上进行 Python 编程。 Python(x,y)：面向科学应用的 Python 发行版，基于 Qt 和 Spyder。官网 pythonlibs：非官方的 Windows 平台 Python 扩展二进制包。官网 PythonNet：Python 与 .NET 公共语言运行库 (CLR)的集成。官网 PyWin32：针对 Windows 的Python 扩展。官网 WinPython：Windows 7/8 系统下便携式开发环境。官网 网络可视化和SDN用来进行网络可视化和SDN(软件定义网络)的工具和库。 Mininet：一款流行的网络模拟器以及用 Python 编写的 API。官网 POX：一个针对基于 Python 的软件定义网络应用（例如 OpenFlow SDN 控制器）的开源开发平台。官网 Pyretic：火热的 SDN 编程语言中的一员，为网络交换机和模拟器提供强大的抽象能力。官网 SDX Platform：基于 SDN 的 IXP 实现，影响了 Mininet, POX 和 Pyretic。官网 硬件用来对硬件进行编程的库。 ino：操作Arduino的命令行工具。官网 Pyro：Python 机器人编程库。官网 PyUserInput：跨平台的，控制鼠标和键盘的模块。官网 scapy：一个非常棒的操作数据包的库。官网 wifi：一个 Python 库和命令行工具用来在 Linux 平台上操作WiFi。官网 Pingo：Pingo 为类似Raspberry Pi，pcDuino， Intel Galileo等设备提供统一的API用以编程。官网 兼容性帮助从 Python 2 向 Python 3迁移的库。 Python-Future：这就是 Python 2 和 Python 3 之间丢失的那个兼容性层。官网 Python-Modernize：使 Python 代码更加现代化以便最终迁移到 Python 3。官网 Six：Python 2 和 3 的兼容性工具。官网 杂项不属于上面任何一个类别，但是非常有用的库。 blinker：一个快速的 Python 进程内信号/事件分发系统。官网 itsdangerous：一系列辅助工具用来将可信的数据传入不可信的环境。官网 pluginbase：一个简单但是非常灵活的 Python 插件系统。官网 Pychievements：一个用来创建和追踪成就的 Python 框架。官网 Tryton：一个通用商务框架。官网 算法和设计模式Python 实现的算法和设计模式。 algorithms：一个 Python 算法模块。官网 python-patterns：Python 设计模式的集合。官网 sortedcontainers：快速，纯 Python 实现的SortedList，SortedDict 和 SortedSet 类型。官网 编辑器插件编辑器和 IDE 的插件 Emacs Elpy：Emacs Python 开发环境。官网 Sublime Text SublimeJEDI：一个 Sublime Text 插件，用来使用超赞的自动补全库 Jedi。官网 Anaconda：Anaconda 把你的 Sublime Text 3 变成一个功能齐全的 Python IDE。官网 Vim YouCompleteMe：引入基于 Jedi 的 Python 自动补全引擎。官网 Jedi-vim：绑定 Vim 和 Jedi 自动补全库对 Python 进行自动补全。官网 Python-mode：将 Vim 变成 Python IDE 的一款多合一插件。官网 Visual Studio PTVS：Visual Studio 的 Python 工具官网 集成开发环境流行的 Python 集成开发环境。 PyCharm：商业化的 Python IDE ，由 JetBrains 开发。也有免费的社区版提供。官网 LiClipse：基于 Eclipse 的免费多语言 IDE 。使用 PyDev 来支持 Python 。官网 Spyder：开源 Python IDE。官网 服务在线工具和简化开发的 API 。 持续集成参见: awesome-CIandCD. Travis CI：一个流行的工具，为你的开源和私人项目提供持续集成服务。(仅支持 GitHub)官网 CircleCI：一个持续集成工具，可以非常快速的进行并行测试。 (仅支持 GitHub)官网 Vexor CI：一个为私人 app 提供持续集成的工具，支持按分钟付费。官网 Wercker：基于 Docker 平台，用来构建和部署微服务。官网 代码质量 Codacy：自动化代码审查，更加快速的发布高质量代码。对于开源项目是免费的。官网 QuantifiedCode：一个数据驱动、自动、持续的代码审查工具。官网 资源在这里可以找到新的 Python 库。 网站 r/Python CoolGithubProjects Django Packages Full Stack Python Python 3 Wall of Superpowers Python Hackers Python ZEEF Trending Python repositories on GitHub today PyPI Ranking 周刊 Import Python Newsletter Pycoder’s Weekly Python Weekly Twitter @codetengu @getpy @planetpython @pycoders @pypi @pythontrending @PythonWeekly 学习指南 Scipy-lecture-notes：如何用Python来做学术？官网 SScientific-python-lectures：Python科学计算的资料。官网 Mario-Level-1：用Python和Pygame写的超级马里奥第一关。官网 Python Koans：Python的交互式学习工具。官网 Minecraft：用python写的Minecraft游戏。官网 pycrumbs：Python资源大全。官网 python-patterns：使用python实现设计模式。官网 Projects：Python项目大集合。官网 The Hitchhiker’s Guide to Python：旅行者的Python学习指南。官网 Code Like a Pythonista: Idiomatic Python：如何像Python高手(Pythonista)一样编程。官网 知名网站值得关注的 Python 技术站点。 中文站点 伯乐在线 Python 频道：分享 Python 开发技术、相关的行业动态。官网 英文站点 《值得关注的 10 个 Python 英文博客》 微博、微信公众号 Python开发者 微博：@Python开发者 Python开发者：人生苦短，我用 Python。Python 越来越受广大程序员的喜爱。「Python开发者」是最受欢迎的、专注分享Python技术的微信公众号，主要分享 Python 相关的技术文章、工具资源和资讯等。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"xx-net 使用方法","slug":"xxnet","date":"2016-12-17T05:13:13.000Z","updated":"2016-12-19T05:13:13.000Z","comments":true,"path":"2016/12/17/xxnet/","link":"","permalink":"http://yusank.github.io/2016/12/17/xxnet/","excerpt":"","text":"注意： 由于封锁严重，软件自带IP已经被封杀殆尽。因此需要数分钟到数小时的初始化IP扫描，方能正常运行。 虽然系统内置了公共appid, 还是建议[[部署自己的appid|how to create my appids]]，公共appid限制看视频。需要注意的是，只有当你能访问Google之后，才能部署自己的APPID。 概述总体来说，使用XX-Net科学上网，大致需要如下步骤： [[获取XX-Net|https://github.com/XX-net/XX-Net/blob/master/code/default/download.md]] 设置和初始化：安装、设置完成后，如果无法翻墙，则需要等待后台程序扫描IP（10分钟到数小时）。 [可选][[创建和使用自己的appid|how to create my appids]] [[设置代理]] [强烈建议]获取和配置可靠的浏览器（[[Firefox火狐浏览器|使用Firefox浏览器]]，或[[Chrome谷歌浏览器|使用Chrome浏览器]]），并使用[[代理切换插件|安装和使用-SwitchyOmega]]。 下面分别介绍各个操作系统平台下的使用方法： Windows系统 双击 start.vbs或者start.bat启动。 Win7/8/10：将提示请求管理员权限（出于[[安装CA证书|GoAgent Import CA]]的需要）。请点击同意。 启动完毕后，将弹出浏览器，访问 http://localhost:8085/ （[[配置页面简介]]） 右下角将出现托盘图标：点击可弹出上述的XX-Net配置页面, 右键可显示[[常用功能菜单|托盘右键菜单]]。 第一次启动, 会提示在桌面建立快捷方式,可根据自己需要选择。 推荐[[使用Chrome浏览器]], [[安装SwichySharp|安装和使用SwichySharp]], 可在XX-Net目录中的SwitchySharp文件夹下找到插件和配置文件。 也可以选择[[使用Firefox（火狐）浏览器|使用Firefox浏览器]]。需[[手动导入证书|GoAgent Import CA#Firefox浏览器手动导入的方式]] 启动失败，请关闭后双击start.bat再次启动程序，把日志发到bug反馈区 WinXP，需要破解tcp连接数，推荐使用tcp-z Win8，win10 的APP，需要使用：https://loopback.codeplex.com/ Windows Server 2008，需要安装 Visual C++ 2008 Redistributable - x86 针对两种常用浏览器，分别有详细的新手图文教程：[[使用Firefox浏览器]]、[[使用Chrome浏览器]] Mac系统 双击 start 启动 证书将被自动导入，如果还有提示非安全连接，请手动导入data/gae_proxy/CA.crt证书 注： 命令行启动方式：./start 推荐[[使用Chrome|使用Chrome浏览器]]和[[SwitchyOmega扩展|安装和使用SwichySharp]] 部分版本可能需要手动升级python。命令为：brew upgrade Linux系统 执行 ./start 启动 自动导入证书，需安装 libnss3-tools 包sudo apt-get install libnss3-tools 没有安装PyGtk的，需要先安装gtk：sudo apt-get install python-gtk2 配置http代理 localhost 8087, 勾选全部协议使用这个代理。如Firefox，如果管理页面弹不出，请在地址栏输入127.0.0.1:8085，注意和代理端口的区别：推荐Chrome + SwitchyOmega ubuntu 下，可能需要安装 sudo apt-get install python-openssl sudo apt-get install libffi-dev sudo apt-get install -y python-gtk2 sudo apt-get install python-appindicator sudo apt-get install libnss3-tools 后台运行：在终端中运行： code/default/xx_net.sh start/stop/restart 开机自启：在/etc/rc.local中添加一行： sudo /home/username/xxnet/code/default/xx_net.sh start 关于 ArchLinux 可能需要的包: python-pyopenssl python2-pyopenssl libffi pygtk python2-notify nss 关于 Fedora 添加 FZUG 源，安装 xx-net 执行 xx-net 或 systemctl --user start xx-net (后台)启动 配置浏览器代理插件 其他平台OpenWrt [[在OpenWrt里运行XX-Net]] [[在装有梅林固件的Netgear R6300V2上安装XX Net]] Android 计划开发中 [[Android技术设计]] 附录关于服务端 服务端兼容 GoAgent 3.1.x/3.2.x的客户端 虽然系统内置了公共appid, 还是建议[[部署自己的appid|how to create my appids]]。 异常处理如果出现异常，请翻阅[[故障速查手册]]，查看常见问题和解决方法。 无法解决的，参考[[异常处理|How-to-get-start-error-log]]，将问题反馈到：https://github.com/XX-net/XX-Net/issueshttps://groups.google.com/forum/#!forum/xx-net 提交issue时请贴出状态页、GAE_proxy日志、部署日志，以便开发者和其他用户更好地帮助你。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2016-12-16T12:12:02.000Z","updated":"2016-12-16T12:12:02.000Z","comments":true,"path":"2016/12/16/hello-world/","link":"","permalink":"http://yusank.github.io/2016/12/16/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":null,"content":null,"categories":[],"tags":[]}]}