---
title: "go 语言中的分片 map 的实现"
date: 2022-01-13T10:50:00+08:00
lastmod: 2022-01-13T11:50:00+08:00
categories: ["代码技巧"]
tags: ["go", "map", "数据结构"]
draft: true
---

> 本篇分享一个分片式的 map 结构，在一些场景下该结构比原生 `syncMap` 更有优势，本文会对该结构的实现，原理以及时候的场景进行详细的介绍。

<!--more-->

## 背景

`map` 作为一个基础的数据结构，在编程过程中可以说是无处不在，应用场景十分广泛。在大部分场景下用原生的 `map` 就能解决当前的问题。如果是高并发场景可以加入 `sync.RWMutex` 来控制并发读写或者直接使用 `sync.Map` 来减少手动写锁的处理逻辑。如果作为一个应用的基础数据结构，性能可以说是非常的高了，绝大部分场景下是完全足够的。但是总有人在优化性能这块想做到极致（包括我自己），即便是原生的数据结构也会有人想优化。既然想优化 map，那首先得了解 map 在什么情况下性能会受损或者性能不够高呢？

对 map 结构熟悉的同学应该都知道，map 又称之为哈希表，key 是按照哈希值存储的，map 在元素增多/减少的过程在 go 里叫 `grow`,而这个过程中有个非常关键的步骤 `rehash`。即会对 map 内的数据进行重新哈希计算和移动位置，在数据量比较大的时候，map 的写性能会有一定的受损的。

如果我有个对性能要求很高的程序（其实如果对性能要求极高其实可以考虑 C 或者 rust 的，这里就不考虑了），想在 map 上做进一步的优化的，应该如何优化，从什么地方入手呢？

## 实现

## 场景 & 压测

## 总结
