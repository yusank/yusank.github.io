---
date: 2021-07-08T18:22:00+08:00
title: "如何自定义 protoc 插件"
categories:
- 技术
- protobuf
tag:
- go
- proto
- protobuf
---

## 前言

如果大家接触过 grpc 和 protobuf ，那对 `protoc` 这个命令应该不陌生。

`protoc` 为基于 proto buffer 文件生成不同语言代码的工具，在日常业务开发中能经常用到。那先抛出一个问题，你有没有基于 pb 文件生成满足自己特殊要求的需求？比如生成对应的 http 代码或校验参数等。

我个人需求为，除了生成正常的 `grpc` 代码外，需要生成一套对应的 `http` 代码，而且最好是能直接在 gin/iris 这种主流 web 框架内注册使用。

其实 `golang/protobuf` 包支持自定义插件的，而且还提供很多好用的方法，方便我们读写 pb 文件。我们写好自己的插件安装到 `$GOPATH/bin` 下，然后在调用 `protoc` 命令时，指定我们自己的插件名和输出位置即可。

## 效果

先看原始 pb 文件。

test.proto

```protobuf
syntax = "proto3";

package hello.service.v1;
option go_package = "api/hello/service/v1;v1";

// 下载 `github.com/googleapis/googleapis` 至`GOPATH`, 生成 http 代码需要。
import "google/api/annotations.proto";

service Hello {
    rpc Add(AddRequest) returns (AddResponse) {
        option (google.api.http) = {
            post: "/api/hello/service/v1/add"
            body: "*"
        };
    }

    rpc Get(GetRequest) returns (GetResponse) {
        option (google.api.http) = {
            get: "/api/hello/service/v1/get"
        };
    }
}

message AddRequest {
    uint32 id = 1;
    string name = 2;
}

message AddResponse {
    uint32 id = 1;
    string name = 2;
}

message GetRequest {
    uint32 id = 1;
}

message GetResponse {
    uint32 id = 1;
    string name = 2;
    float score = 3;
    bytes bs = 4;
    map<string, string> m = 5;
}
```

因为我需要生成 http 代码，所以定义 rpc 时，http 路由和method 需要在 pb 文件指定。

我实现的插件起码叫 `protoc-gen-go-http`, 必须以 `protoc-gen` 开头否则 protoc 不认。

执行命令：

```shell
# --go-http 为我自己的插件
# 还可以 --go-http_opts=key=val 的方式传参给插件 这个我也用到了 后面详细介绍
protoc -I$GOPATH/src/github.com/googleapis/googleapis --proto_path=$GOPATH/src:. --go_out=. --go-http_out=. --micro_out=. test.proto
```

执行完命令后，会生成三个文件分别为 `test.pb.go`,`test.pb.micro.go`和`test.http.pb.go`， 生成的文件名是可以自定义的。

`test.pb.micro.go` 文件是由 go-micro 提供的工具生成 grpc 代码文件。

看一下 `test.http.pb.go` 文件

```go
// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v0.0.9

package v1

import (
    context "context"
    gin "github.com/gin-gonic/gin"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the galaxy package it is being compiled against.
var _ context.Context
const _ = gin.Version

type HelloHTTPHandler interface {
    Add(context.Context, *AddRequest, *AddResponse) error
    Get(context.Context, *GetRequest, *GetResponse) error
}

// RegisterHelloHTTPHandler define http router handle by gin.
func RegisterHelloHTTPHandler(g *gin.RouterGroup, srv HelloHTTPHandler) {
    g.POST("/api/hello/service/v1/add", _Hello_Add0_HTTP_Handler(srv))
    g.GET("/api/hello/service/v1/get", _Hello_Get0_HTTP_Handler(srv))
}

func _Hello_Add0_HTTP_Handler(srv HelloHTTPHandler) func(c *gin.Context) {
    return func(c *gin.Context) {
        var (
            in  AddRequest
            out AddResponse
        )

        if err := c.ShouldBind(&in); err != nil {
            c.AbortWithStatusJSON(400, gin.H{"err": err.Error()})
            return
        }

        err := srv.Add(context.Background(), &in, &out)
        if err != nil {
            c.AbortWithStatusJSON(500, gin.H{"err": err.Error()})
            return
        }

        c.JSON(200, &out)
    }
}

func _Hello_Get0_HTTP_Handler(srv HelloHTTPHandler) func(c *gin.Context) {
    return func(c *gin.Context) {
        var (
            in  GetRequest
            out GetResponse
        )

        if err := c.ShouldBind(&in); err != nil {
            c.AbortWithStatusJSON(400, gin.H{"err": err.Error()})
            return
        }

        err := srv.Get(context.Background(), &in, &out)
        if err != nil {
            c.AbortWithStatusJSON(500, gin.H{"err": err.Error()})
            return
        }

        c.JSON(200, &out)
    }
}
```

重点是 `RegisterHelloHTTPHandler` 方法，这样我就注册一个 gin.RouterGroup 和 HelloHTTPHandler 就可以直接提供一个 http 服务 `HelloHTTPHandler` 接口里方法的签名与`go-micro`生成的 grpc 方法保持了一致， 这样我只需要实现 grpc 的代码里对应的 Interface{} 接口，就可以服用，完全不会产生多余代码。

go-micro 生成的 pb 代码片段：

```go
type HelloHandler interface {
    Add(context.Context, *AddRequest, *AddResponse) error
    Get(context.Context, *GetRequest, *GetResponse) error
}

func RegisterHelloHandler(s server.Server, hdlr HelloHandler, opts ...server.HandlerOption) error {}
```

我在 main 函数注册的时候也只需要多注册一次 http handler 即可，

main.go

```go

// 它实现了 HelloHandler
type implHello struct{}

RegisterHelloHandler(micro.Server, &implHello)
g := gin.New()
// implHello 实现HelloHandler 那就是实现了HelloHTTPHandler
RegisterHelloHTTPHandler(g.Group("/"), &implHello)
```

所以我就很容易通过 http 接口调试 grpc 方法，甚至可以对外提供服务，一举两堵。

## 如何实现

> 近期补充
