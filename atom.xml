<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yusank&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yusank.github.io/"/>
  <updated>2017-09-01T09:12:11.000Z</updated>
  <id>http://yusank.github.io/</id>
  
  <author>
    <name>Yusank</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go Image</title>
    <link href="http://yusank.github.io/go-image.html/"/>
    <id>http://yusank.github.io/go-image.html/</id>
    <published>2017-08-22T04:20:00.000Z</published>
    <updated>2017-09-01T09:12:11.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><p>用 GO 实现图片处理和文字合成<br><a id="more"></a></p>
<h1 id="Go-的图片处理"><a href="#Go-的图片处理" class="headerlink" title="Go 的图片处理"></a>Go 的图片处理</h1><p>最近需要一个合成明信片的工具，即往背景图的固定位置上添加一个图片和一段文字， 最后合成一张图片。由于是 go 程序的一个子功能，所以我想我只加拿 go 写好了，正好有 go 的 <code>image</code> 库，拿来练练。</p>
<h2 id="图片合成"><a href="#图片合成" class="headerlink" title="图片合成"></a>图片合成</h2><p>图片合成我用到了这个库  <code>github.com/disintegration/imaging</code></p>
<p>代码：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"image"</span>

    <span class="token string">"github.com/disintegration/imaging"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">HandleUserImage</span><span class="token punctuation">(</span>fileName <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    m<span class="token punctuation">,</span> err <span class="token operator">:=</span> imaging<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"target.jpg"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"open file failed"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    bm<span class="token punctuation">,</span> err <span class="token operator">:=</span> imaging<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"bg.jpg"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"open file failed"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 图片按比例缩放</span>
    dst <span class="token operator">:=</span> imaging<span class="token punctuation">.</span><span class="token function">Resize</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> imaging<span class="token punctuation">.</span>Lanczos<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 将图片粘贴到背景图的固定位置</span>
    result <span class="token operator">:=</span> imaging<span class="token punctuation">.</span><span class="token function">Overlay</span><span class="token punctuation">(</span>bm<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> image<span class="token punctuation">.</span><span class="token function">Pt</span><span class="token punctuation">(</span><span class="token number">120</span><span class="token punctuation">,</span> <span class="token number">140</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>

    fileName <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%d.jpg"</span><span class="token punctuation">,</span> fileName<span class="token punctuation">)</span>
    err <span class="token operator">=</span> imaging<span class="token punctuation">.</span><span class="token function">Save</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> fileName<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> fileName<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上是将 <code>target.jpg</code> 文件先进行缩放，再贴到 <code>bg.jpg</code> 文件的 （120，140）位置，最后保存成文件。</p>
<h2 id="图片上写文字"><a href="#图片上写文字" class="headerlink" title="图片上写文字"></a>图片上写文字</h2><p>以下是写文字和贴图的一块用的实例：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"image"</span>
    <span class="token string">"image/color"</span>
    <span class="token string">"io/ioutil"</span>

    <span class="token string">"github.com/disintegration/imaging"</span>
    <span class="token string">"github.com/golang/freetype"</span>
    <span class="token string">"github.com/golang/freetype/truetype"</span>
    <span class="token string">"golang.org/x/image/font"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">HandleUserImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// HandleUserImage paste user image onto background</span>
<span class="token keyword">func</span> <span class="token function">HandleUserImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    m<span class="token punctuation">,</span> err <span class="token operator">:=</span> imaging<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"target.png"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"open file failed"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    bm<span class="token punctuation">,</span> err <span class="token operator">:=</span> imaging<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"bg.jpg"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"open file failed"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 图片按比例缩放</span>
    dst <span class="token operator">:=</span> imaging<span class="token punctuation">.</span><span class="token function">Resize</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> imaging<span class="token punctuation">.</span>Lanczos<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 将图片粘贴到背景图的固定位置</span>
    result <span class="token operator">:=</span> imaging<span class="token punctuation">.</span><span class="token function">Overlay</span><span class="token punctuation">(</span>bm<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> image<span class="token punctuation">.</span><span class="token function">Pt</span><span class="token punctuation">(</span><span class="token number">120</span><span class="token punctuation">,</span> <span class="token number">140</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token function">writeOnImage</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>

    fileName <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%d.jpg"</span><span class="token punctuation">,</span> <span class="token number">1234</span><span class="token punctuation">)</span>
    err <span class="token operator">=</span> imaging<span class="token punctuation">.</span><span class="token function">Save</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> fileName<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> fileName<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> dpi <span class="token operator">=</span> flag<span class="token punctuation">.</span><span class="token function">Float64</span><span class="token punctuation">(</span><span class="token string">"dpi"</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token string">"screen resolution"</span><span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">writeOnImage</span><span class="token punctuation">(</span>target <span class="token operator">*</span>image<span class="token punctuation">.</span>NRGBA<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    c <span class="token operator">:=</span> freetype<span class="token punctuation">.</span><span class="token function">NewContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    c<span class="token punctuation">.</span><span class="token function">SetDPI</span><span class="token punctuation">(</span><span class="token operator">*</span>dpi<span class="token punctuation">)</span>
    c<span class="token punctuation">.</span><span class="token function">SetClip</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">Bounds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    c<span class="token punctuation">.</span><span class="token function">SetDst</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    c<span class="token punctuation">.</span><span class="token function">SetHinting</span><span class="token punctuation">(</span>font<span class="token punctuation">.</span>HintingFull<span class="token punctuation">)</span>

        <span class="token comment" spellcheck="true">// 设置文字颜色、字体、字大小</span>
    c<span class="token punctuation">.</span><span class="token function">SetSrc</span><span class="token punctuation">(</span>image<span class="token punctuation">.</span><span class="token function">NewUniform</span><span class="token punctuation">(</span>color<span class="token punctuation">.</span>RGBA<span class="token punctuation">{</span>R<span class="token punctuation">:</span> <span class="token number">240</span><span class="token punctuation">,</span> G<span class="token punctuation">:</span> <span class="token number">240</span><span class="token punctuation">,</span> B<span class="token punctuation">:</span> <span class="token number">245</span><span class="token punctuation">,</span> A<span class="token punctuation">:</span> <span class="token number">180</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    c<span class="token punctuation">.</span><span class="token function">SetFontSize</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span>
    fontFam<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">getFontFamily</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"get font family error"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    c<span class="token punctuation">.</span><span class="token function">SetFont</span><span class="token punctuation">(</span>fontFam<span class="token punctuation">)</span>

    pt <span class="token operator">:=</span> freetype<span class="token punctuation">.</span><span class="token function">Pt</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">)</span>

    <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">DrawString</span><span class="token punctuation">(</span><span class="token string">"我是水印"</span><span class="token punctuation">,</span> pt<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"draw error: %v \n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">getFontFamily</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>truetype<span class="token punctuation">.</span>Font<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 这里需要读取中文字体，否则中文文字会变成方格</span>
    fontBytes<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span><span class="token string">"Hei.ttc"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read file error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">&amp;</span>truetype<span class="token punctuation">.</span>Font<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> err
    <span class="token punctuation">}</span>

    f<span class="token punctuation">,</span> err <span class="token operator">:=</span> freetype<span class="token punctuation">.</span><span class="token function">ParseFont</span><span class="token punctuation">(</span>fontBytes<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"parse font error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">&amp;</span>truetype<span class="token punctuation">.</span>Font<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> err
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> f<span class="token punctuation">,</span> err
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后来一张效果图<br><img src="http://oid1xlj7h.bkt.clouddn.com/image/jpg/1234.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做的过程中，合作这一块比较好做，但是图片上写文字，相对比较麻烦，而且 <code>freetype</code> 库并没有默认的中英文字体，如果不指定字体会报错，而且字体格式只限制于 <code>ttf</code> 和 <code>ttc</code> 两种。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用 GO 实现图片处理和文字合成&lt;br&gt;
    
    </summary>
    
      <category term="GO" scheme="http://yusank.github.io/categories/GO/"/>
    
      <category term="技术" scheme="http://yusank.github.io/categories/GO/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="GO" scheme="http://yusank.github.io/tags/GO/"/>
    
      <category term="图形处理" scheme="http://yusank.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Cobra - 一个 Golang 命令行项目生成工具</title>
    <link href="http://yusank.github.io/cobra-terminal_tools.html/"/>
    <id>http://yusank.github.io/cobra-terminal_tools.html/</id>
    <published>2017-08-17T07:07:14.000Z</published>
    <updated>2017-09-05T09:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><p><strong>转载于</strong>   <a href="https://jsharkc.github.io/2017/07/17/cobra%E5%85%A5%E9%97%A8%E5%B0%8F%E6%95%99%E7%A8%8B/" target="_blank" rel="external">Jsharkc 的博客</a></p>
<h1 id="Cobra-Golang-命令行库"><a href="#Cobra-Golang-命令行库" class="headerlink" title="Cobra - Golang 命令行库"></a>Cobra - Golang 命令行库</h1><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>Cobra 是一个创建 CLI 命令行的 golang 库。</p>
<h3 id="组成："><a href="#组成：" class="headerlink" title="组成："></a>组成：</h3><p>Cobra 结构由三部分组成：命令( Command )、参数( Args )、标志( Flag )。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Command <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Use   <span class="token builtin">string</span>  <span class="token comment" spellcheck="true">// The one-line usage message.</span>
    Short <span class="token builtin">string</span>  <span class="token comment" spellcheck="true">// The short description shown in the 'help' output.</span>
    Long  <span class="token builtin">string</span>  <span class="token comment" spellcheck="true">// The long message shown in the 'help&lt;this-command>' output.</span>
    Run   <span class="token keyword">func</span><span class="token punctuation">(</span>cmd <span class="token operator">*</span>Command<span class="token punctuation">,</span> args <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// Run runs the command.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>前三个是不同场景下的说明，最后一个是要执行的函数。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 Cobra 很简单，首先，用 <code>go get</code> 安装最新版本的库，这个命令会安装 Cobra 框架生成工具和依赖。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">go</span> get <span class="token operator">-</span>u github<span class="token punctuation">.</span>com<span class="token operator">/</span>spf13<span class="token operator">/</span>cobra<span class="token operator">/</span>cobra
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后，把 Cobra 添加到你的 app 中：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"github.com/spf13/cobra"</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><p>​一般用 cobra 命令生成d的项目结构如下：</p>
<pre class="line-numbers language-go"><code class="language-go"> ▾ appName<span class="token operator">/</span>
    ▾ cmd<span class="token operator">/</span>
        add<span class="token punctuation">.</span><span class="token keyword">go</span>
        your<span class="token punctuation">.</span><span class="token keyword">go</span>
        commands<span class="token punctuation">.</span><span class="token keyword">go</span>
        here<span class="token punctuation">.</span><span class="token keyword">go</span>
      main<span class="token punctuation">.</span><span class="token keyword">go</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>main 函数中非常简洁，只有一个目的：初始化 Cobra.</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"os"</span>

    <span class="token string">"{pathToYourApp}/cmd"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span>RootCmd<span class="token punctuation">.</span><span class="token function">Execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
        os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="用-Cobra-工具生成项目框架"><a href="#用-Cobra-工具生成项目框架" class="headerlink" title="用 Cobra 工具生成项目框架"></a>用 Cobra 工具生成项目框架</h3><h4 id="cobra-init"><a href="#cobra-init" class="headerlink" title="cobra init"></a>cobra init</h4><p><code>cobra init [yourAppName]</code> ，这个命令可以让你的程序有一个正确的结构，你立刻能够感受到 Cobra 带给你的快乐，你可以配置它自动生成你需要的开源协议。</p>
<pre class="line-numbers language-go"><code class="language-go">cobra init newAppName
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>newAppName 是你的项目名称。它会在你的 GOPATH 目录下面生成项目。</p>
<p>我们看一下 main.go 函数</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"cobra_exp1/cmd"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cmd<span class="token punctuation">.</span><span class="token function">Execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>main 调用 cmd.Execute()，那我们找到这个地方，cmd/root.go 文件：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> cmd

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"os"</span>

    <span class="token string">"github.com/spf13/cobra"</span>
    <span class="token string">"github.com/spf13/viper"</span>
<span class="token punctuation">)</span>

<span class="token keyword">var</span> cfgFile <span class="token builtin">string</span>

<span class="token comment" spellcheck="true">// RootCmd represents the base command when called without any subcommands</span>
<span class="token keyword">var</span> RootCmd <span class="token operator">=</span> <span class="token operator">&amp;</span>cobra<span class="token punctuation">.</span>Command<span class="token punctuation">{</span>
    Use<span class="token punctuation">:</span>   <span class="token string">"cobra_exp1"</span><span class="token punctuation">,</span>
    Short<span class="token punctuation">:</span> <span class="token string">"A brief description of your application"</span><span class="token punctuation">,</span>
    Long<span class="token punctuation">:</span> <span class="token string">`A longer description that spans multiple lines and likely contains
examples and usage of using your application. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`</span><span class="token punctuation">,</span>
<span class="token comment" spellcheck="true">// Uncomment the following line if your bare application</span>
<span class="token comment" spellcheck="true">// has an action associated with it:</span>
<span class="token comment" spellcheck="true">//    Run: func(cmd *cobra.Command, args []string) { },</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Execute adds all child commands to the root command sets flags appropriately.</span>
<span class="token comment" spellcheck="true">// This is called by main.main(). It only needs to happen once to the rootCmd.</span>
<span class="token keyword">func</span> <span class="token function">Execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> RootCmd<span class="token punctuation">.</span><span class="token function">Execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
        os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cobra<span class="token punctuation">.</span><span class="token function">OnInitialize</span><span class="token punctuation">(</span>initConfig<span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">// Here you will define your flags and configuration settings.</span>
    <span class="token comment" spellcheck="true">// Cobra supports Persistent Flags, which, if defined here,</span>
    <span class="token comment" spellcheck="true">// will be global for your application.</span>

    RootCmd<span class="token punctuation">.</span><span class="token function">PersistentFlags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">StringVar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cfgFile<span class="token punctuation">,</span> <span class="token string">"config"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"config file (default is $HOME/.cobra_exp1.yaml)"</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// Cobra also supports local flags, which will only run</span>
    <span class="token comment" spellcheck="true">// when this action is called directly.</span>
    RootCmd<span class="token punctuation">.</span><span class="token function">Flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">BoolP</span><span class="token punctuation">(</span><span class="token string">"toggle"</span><span class="token punctuation">,</span> <span class="token string">"t"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"Help message for toggle"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// initConfig reads in config file and ENV variables if set.</span>
<span class="token keyword">func</span> <span class="token function">initConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> cfgFile <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// enable ability to specify config file via flag</span>
        viper<span class="token punctuation">.</span><span class="token function">SetConfigFile</span><span class="token punctuation">(</span>cfgFile<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    viper<span class="token punctuation">.</span><span class="token function">SetConfigName</span><span class="token punctuation">(</span><span class="token string">".cobra_exp1"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// name of config file (without extension)</span>
    viper<span class="token punctuation">.</span><span class="token function">AddConfigPath</span><span class="token punctuation">(</span><span class="token string">"$HOME"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// adding home directory as first search path</span>
    viper<span class="token punctuation">.</span><span class="token function">AutomaticEnv</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">// read in environment variables that match</span>

    <span class="token comment" spellcheck="true">// If a config file is found, read it in.</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> viper<span class="token punctuation">.</span><span class="token function">ReadInConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Using config file:"</span><span class="token punctuation">,</span> viper<span class="token punctuation">.</span><span class="token function">ConfigFileUsed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们看到 Execute() 函数中调用 RootCmd.Execute()，RootCmd 是开始讲组成 Command 结构的一个实例。</p>
<p>我们运行看看：</p>
<pre class="line-numbers language-sh"><code class="language-sh">> go run main.go 
A longer description that spans multiple lines and likely contains
examples and usage of using your application. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>空空如也，还什么也没有，那接下来我们来添加一些子命令。</p>
<h4 id="cobra-add"><a href="#cobra-add" class="headerlink" title="cobra add"></a>cobra add</h4><p>这个命令用来创建子命令，子命令就是像下面这样：</p>
<ul>
<li>app serve</li>
<li>app config</li>
<li>app config create</li>
</ul>
<p>在你项目的目录下，运行下面这些命令：</p>
<pre class="line-numbers language-go"><code class="language-go">cobra add serve
cobra add config
cobra add create <span class="token operator">-</span>p <span class="token string">'configCmd'</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这样以后，你就可以运行上面那些 app serve 之类的命令了。项目目录如下：</p>
<pre class="line-numbers language-Sh"><code class="language-Sh">  ▾ app/
    ▾ cmd/
        serve.go
        config.go
        create.go
      main.go
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后再运行程序：</p>
<pre class="line-numbers language-Sh"><code class="language-Sh">❯ go run main.go 
A longer description that spans multiple lines and likely contains
examples and usage of using your application. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.

Usage:
  llleon [command]

Available Commands:
  config      A brief description of your command
  help        Help about any command
  serve       A brief description of your command

Flags:
      --config string   config file (default is $HOME/.llleon.yaml)
  -h, --help            help for llleon
  -t, --toggle          Help message for toggle

Use "llleon [command] --help" for more information about a command.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在我们有了三个子命令，并且都可以使用，然后只要添加命令逻辑就能真正用了。</p>
<h4 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h4><p>cobra 有两种 flag，一个是全局变量，一个是局部变量。全局什么意思呢，就是所以子命令都可以用。局部的只有自己能用。先看全局的：</p>
<pre class="line-numbers language-go"><code class="language-go">RootCmd<span class="token punctuation">.</span><span class="token function">PersistentFlags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">StringVar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cfgFile<span class="token punctuation">,</span> <span class="token string">"config"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"config file (default is $HOME/.cobra_exp1.yaml)"</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在看局部的：</p>
<pre class="line-numbers language-go"><code class="language-go">RootCmd<span class="token punctuation">.</span><span class="token function">Flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">BoolP</span><span class="token punctuation">(</span><span class="token string">"toggle"</span><span class="token punctuation">,</span> <span class="token string">"t"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"Help message for toggle"</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>区别就在 RootCmd 后面的是 Flags 还是 PersistentFlags。</p>
<p>好了，入门教程到此结束，感兴趣的童鞋可以到 <a href="https://github.com/spf13/cobra" target="_blank" rel="external">Cobra</a> 深入研究一番。</p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;&lt;strong&gt;转载于&lt;/strong&gt;   &lt;a href=&quot;https
    
    </summary>
    
      <category term="Go" scheme="http://yusank.github.io/categories/Go/"/>
    
      <category term="技术" scheme="http://yusank.github.io/categories/Go/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Golang" scheme="http://yusank.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Go UDP Socket</title>
    <link href="http://yusank.github.io/GO-UDP.html/"/>
    <id>http://yusank.github.io/GO-UDP.html/</id>
    <published>2017-08-02T11:00:01.000Z</published>
    <updated>2017-08-23T14:19:23.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><p>udp 和 tcp 的简单比较和用 go 实现最简单的 udp 客户端和服务端 ……<br><a id="more"></a></p>
<h1 id="用-go-实现简单的-udp"><a href="#用-go-实现简单的-udp" class="headerlink" title="用 go 实现简单的 udp"></a>用 go 实现简单的 udp</h1><p>用户数据包协议（英语：User Datagram Protocol，缩写为UDP），又称用户数据报文协议，是一个简单的面向数据报的传输层协议，正式规范为RFC 768。<br>在TCP/IP模型中，UDP为网络层以上和应用层以下提供了一个简单的接口。UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议）。UDP在IP数据报的头部仅仅加入了复用和数据校验（字段）。</p>
<h2 id="UDP-与-TCP-的比较"><a href="#UDP-与-TCP-的比较" class="headerlink" title="UDP 与 TCP 的比较"></a>UDP 与 TCP 的比较</h2><ul>
<li><p>UDP – 用户数据协议包，是一个简单的面向数据报的运输层协议。UDP 不提供可靠性，它只是把应用程序给 IP 层的数据报发送出去，但是并不能保证他们能达到目的地。由于 UDP 在传输数据报之前不用在客户端和服务端之间建立连接，且没有超时机制，故而传输速度很快。</p>
</li>
<li><p>TCP – 传输控制协议，提供的是面向连接，可靠的字节流服务。当客户端和服务端彼此交换数据前，必须先在双方之间建立 TCP 连接，之后才能传输数据。TCP 提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一段传到另一端。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>-</th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否连接</td>
<td>面向连接</td>
<td>面向非连接</td>
</tr>
<tr>
<td>传输可靠性</td>
<td>可靠</td>
<td>会丢包，不可靠</td>
</tr>
<tr>
<td>应用场景</td>
<td>传输数据量大</td>
<td>传输数据量小</td>
</tr>
<tr>
<td>速度</td>
<td>慢</td>
<td>快</td>
</tr>
</tbody>
</table>
<h2 id="TCP-与-UDP-的选择"><a href="#TCP-与-UDP-的选择" class="headerlink" title="TCP 与 UDP 的选择"></a>TCP 与 UDP 的选择</h2><p>当数据传输的性能必须让位于数据传输的完整性、可控制性和可靠性时，TCP协议是当然的选择。当强调传输性能而不是传输的完整性时，如：音频和多媒体应用，UDP是最好的选择。在数据传输时间很短，以至于此前的连接过程成为整个流量主体的情况下，UDP也是一个好的选择，如：DNS交换。把SNMP建立在UDP上的部分原因是设计者认为当发生网络阻塞时，UDP较低的开销使其有更好的机会去传送管理数据。TCP丰富的功能有时会导致不可预料的性能低下，但是我们相信在不远的将来，TCP可靠的点对点连接将会用于绝大多数的网络应用。</p>
<h2 id="UDP-使用场景"><a href="#UDP-使用场景" class="headerlink" title="UDP 使用场景"></a>UDP 使用场景</h2><p>在选择使用协议的时候，选择UDP必须要谨慎。在网络质量令人十分不满意的环境下，UDP协议数据包丢失会比较严重。但是由于UDP的特性：它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。而且如果在内网的情况下，丢包率也很低，所以内网的数据传输也可以用 UDP 协议。我们常用的 QQ，一部分数据传输功能也是用 UDP协议来实现的。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>下面分别是服务端和客户端实现代码：<br>服务端代码 <code>server.go</code>:</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"net"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 解析地址</span>
    addr<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">ResolveUDPAddr</span><span class="token punctuation">(</span><span class="token string">"udp"</span><span class="token punctuation">,</span> <span class="token string">":3017"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Can't resolve addr:"</span><span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 监听端口</span>
    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">ListenUDP</span><span class="token punctuation">(</span><span class="token string">"udp"</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"listen error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        <span class="token function">handlerClient</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">handlerClient</span><span class="token punctuation">(</span>conn <span class="token operator">*</span>net<span class="token punctuation">.</span>UDPConn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    data <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 从 UDP 中读取内容并写到 data</span>
    <span class="token boolean">_</span><span class="token punctuation">,</span> remoteAddr<span class="token punctuation">,</span> err <span class="token operator">:=</span> conn<span class="token punctuation">.</span><span class="token function">ReadFromUDP</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read udp msg failed with:"</span><span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 给收到消息的 client 写回信息</span>
    conn<span class="token punctuation">.</span><span class="token function">WriteToUDP</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> remoteAddr<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>客户端代码<code>client.go</code>：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> client

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"net"</span>
<span class="token punctuation">)</span>

<span class="token keyword">var</span> <span class="token punctuation">(</span>
    <span class="token comment" spellcheck="true">// Connection *net.UDPConn</span>
    Connection <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>net<span class="token punctuation">.</span>UDPConn
<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// Client 创建一个 UDP 连接</span>
<span class="token keyword">func</span> <span class="token function">Client</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    addr<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">ResolveUDPAddr</span><span class="token punctuation">(</span><span class="token string">"udp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:3017"</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Can't resolve address: "</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>

        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">DialUDP</span><span class="token punctuation">(</span><span class="token string">"udp"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>

    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Can't dial: "</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>

        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    Connection <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>Connection<span class="token punctuation">,</span> conn<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// WriteTo 像传入参数 conn 写数据</span>
<span class="token keyword">func</span> <span class="token function">WriteTo</span><span class="token punctuation">(</span>conn <span class="token operator">*</span>net<span class="token punctuation">.</span>UDPConn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"hello from the other site"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"failed:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    data <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>
    <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>

    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"failed to read UDP msg because of "</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是一个最简单的 UDP 客户端服务器的代码，只有启动服务和收发消息的功能，但实际应用 UDP 协议到具体需求的时候，需要考虑的问题很多，比如包的设计，包头的设计，错误处理，丢包处理，包顺序调换处理等。所以需要用到传输数据协议的时候，请考虑好需求和可能遇到的问题，以及对问题的处理方案。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;udp 和 tcp 的简单比较和用 go 实现最简单的 udp 客户端和服务端 ……&lt;br&gt;
    
    </summary>
    
      <category term="GO" scheme="http://yusank.github.io/categories/GO/"/>
    
    
      <category term="GO" scheme="http://yusank.github.io/tags/GO/"/>
    
      <category term="UDP" scheme="http://yusank.github.io/tags/UDP/"/>
    
      <category term="网络编程" scheme="http://yusank.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Go TCP Socket</title>
    <link href="http://yusank.github.io/Go-TCP%20Socket.html/"/>
    <id>http://yusank.github.io/Go-TCP Socket.html/</id>
    <published>2017-07-31T02:00:01.000Z</published>
    <updated>2017-08-23T14:19:51.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><p>转载文章</p>
<h1 id="Go语言TCP-Socket编程"><a href="#Go语言TCP-Socket编程" class="headerlink" title="Go语言TCP Socket编程"></a>Go语言TCP Socket编程</h1><p><strong>文章原始地址:</strong> <a href="http://tonybai.com/2015/11/17/tcp-programming-in-golang/" target="_blank" rel="external">http://tonybai.com/2015/11/17/tcp-programming-in-golang/</a></p>
<p><a href="http://tonybai.com/tag/go" target="_blank" rel="external">Golang</a>的主要 设计目标之一就是面向大规模后端服务程序，网络通信这块是服务端 程序必不可少也是至关重要的一部分。在日常应用中，我们也可以看到Go中的net以及其subdirectories下的包均是“高频+刚需”，而TCP socket则是网络编程的主流，即便您没有直接使用到net中有关TCP Socket方面的接口，但net/http总是用到了吧，http底层依旧是用tcp socket实现的。</p>
<p>网络编程方面，我们最常用的就是tcp socket编程了，在posix标准出来后，socket在各大主流OS平台上都得到了很好的支持。关于tcp programming，最好的资料莫过于<a href="http://en.wikipedia.org/wiki/W._Richard_Stevens" target="_blank" rel="external">W. Richard Stevens</a> 的网络编程圣经《<a href="http://book.douban.com/subject/4859464/" target="_blank" rel="external">UNIX网络 编程 卷1：套接字联网API</a>》 了，书中关于tcp socket接口的各种使用、行为模式、异常处理讲解的十分细致。Go是自带runtime的跨平台编程语言，Go中暴露给语言使用者的tcp socket api是建立OS原生tcp socket接口之上的。由于Go runtime调度的需要，golang tcp socket接口在行为特点与异常处理方面与OS原生接口有着一些差别。这篇博文的目标就是整理出关于Go tcp socket在各个场景下的使用方法、行为特点以及注意事项。</p>
<h2 id="一、模型"><a href="#一、模型" class="headerlink" title="一、模型"></a>一、模型</h2><p>从tcp socket诞生后，网络编程架构模型也几经演化，大致是：“每进程一个连接” –&gt; “每线程一个连接” –&gt; “Non-Block + I/O多路复用(linux epoll/windows iocp/freebsd darwin kqueue/solaris Event Port)”。伴随着模型的演化，服务程序愈加强大，可以支持更多的连接，获得更好的处理性能。</p>
<p>目前主流web server一般均采用的都是”Non-Block + I/O多路复用”（有的也结合了多线程、多进程）。不过I/O多路复用也给使用者带来了不小的复杂度，以至于后续出现了许多高性能的I/O多路复用框架， 比如<a href="http://libevent.org/" target="_blank" rel="external">libevent</a>、<a href="http://software.schmorp.de/pkg/libev.html" target="_blank" rel="external">libev</a>、<a href="https://github.com/joyent/libuv" target="_blank" rel="external">libuv</a>等，以帮助开发者简化开发复杂性，降低心智负担。不过Go的设计者似乎认为I/O多路复用的这种通过回调机制割裂控制流 的方式依旧复杂，且有悖于“一般逻辑”设计，为此Go语言将该“复杂性”隐藏在Runtime中了：Go开发者无需关注socket是否是 non-block的，也无需亲自注册文件描述符的回调，只需在每个连接对应的goroutine中以<strong>“block I/O”</strong>的方式对待socket处理即可，这可以说大大降低了开发人员的心智负担。一个典型的Go server端程序大致如下：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">//go-tcpsock/server.go</span>
<span class="token keyword">func</span> <span class="token function">handleConn</span><span class="token punctuation">(</span>c net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">defer</span> c<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// read from the connection</span>
        <span class="token comment" spellcheck="true">// ... ...</span>
        <span class="token comment" spellcheck="true">// write to the connection</span>
        <span class="token comment" spellcheck="true">//... ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    l<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">":8888"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"listen error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        c<span class="token punctuation">,</span> err <span class="token operator">:=</span> l<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"accept error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
            <span class="token keyword">break</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// start a new goroutine to handle</span>
        <span class="token comment" spellcheck="true">// the new connection.</span>
        <span class="token keyword">go</span> <span class="token function">handleConn</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用户层眼中看到的goroutine中的“block socket”，实际上是通过Go runtime中的netpoller通过Non-block socket + I/O多路复用机制“模拟”出来的，真实的underlying socket实际上是non-block的，只是runtime拦截了底层socket系统调用的错误码，并通过netpoller和goroutine 调度让goroutine“阻塞”在用户层得到的Socket fd上。比如：当用户层针对某个socket fd发起read操作时，如果该socket fd中尚无数据，那么runtime会将该socket fd加入到netpoller中监听，同时对应的goroutine被挂起，直到runtime收到socket fd 数据ready的通知，runtime才会重新唤醒等待在该socket fd上准备read的那个Goroutine。而这个过程从Goroutine的视角来看，就像是read操作一直block在那个socket fd上似的。具体实现细节在后续场景中会有补充描述。</p>
<h2 id="二、TCP连接的建立"><a href="#二、TCP连接的建立" class="headerlink" title="二、TCP连接的建立"></a>二、TCP连接的建立</h2><p>众所周知，TCP Socket的连接的建立需要经历客户端和服务端的三次握手的过程。连接建立过程中，服务端是一个标准的Listen + Accept的结构(可参考上面的代码)，而在客户端Go语言使用net.Dial或DialTimeout进行连接建立：</p>
<p>阻塞Dial：</p>
<pre class="line-numbers language-go"><code class="language-go">conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"google.com:80"</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//handle error</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// read or write on conn</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>或是带上超时机制的Dial：</p>
<pre class="line-numbers language-go"><code class="language-go">conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">DialTimeout</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">":8080"</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//handle error</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// read or write on conn</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于客户端而言，连接的建立会遇到如下几种情形：</p>
<h3 id="1、网络不可达或对方服务未启动"><a href="#1、网络不可达或对方服务未启动" class="headerlink" title="1、网络不可达或对方服务未启动"></a>1、网络不可达或对方服务未启动</h3><p>如果传给Dial的Addr是可以立即判断出网络不可达，或者Addr中端口对应的服务没有启动，端口未被监听，Dial会几乎立即返回错误，比如：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">//go-tcpsock/conn_establish/client1.go</span>
<span class="token operator">...</span> <span class="token operator">...</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"begin dial..."</span><span class="token punctuation">)</span>
    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">":8888"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"dial error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"dial ok"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果本机8888端口未有服务程序监听，那么执行上面程序，Dial会很快返回错误：</p>
<pre class="line-numbers language-shell"><code class="language-shell">$go run client1.go
2015/11/16 14:37:41 begin dial...
2015/11/16 14:37:41 dial error: dial tcp :8888: getsockopt: connection refused
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="2、对方服务的listen-backlog满"><a href="#2、对方服务的listen-backlog满" class="headerlink" title="2、对方服务的listen backlog满"></a>2、对方服务的listen backlog满</h3><p>还有一种场景就是对方服务器很忙，瞬间有大量client端连接尝试向server建立，server端的listen backlog队列满，server accept不及时((即便不accept，那么在backlog数量范畴里面，connect都会是成功的，因为new conn已经加入到server side的listen queue中了，accept只是从queue中取出一个conn而已)，这将导致client端Dial阻塞。我们还是通过例子感受Dial的行为特点：</p>
<p>服务端代码：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">//go-tcpsock/conn_establish/server2.go</span>
<span class="token operator">...</span> <span class="token operator">...</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    l<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">":8888"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"error listen:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">defer</span> l<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"listen ok"</span><span class="token punctuation">)</span>

    <span class="token keyword">var</span> i <span class="token builtin">int</span>
    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> l<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"accept error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
            <span class="token keyword">break</span>
        <span class="token punctuation">}</span>
        i<span class="token operator">++</span>
        log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d: accept a new connection\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>客户端代码：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">//go-tcpsock/conn_establish/client2.go</span>
<span class="token operator">...</span> <span class="token operator">...</span>
<span class="token keyword">func</span> <span class="token function">establishConn</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> net<span class="token punctuation">.</span>Conn <span class="token punctuation">{</span>
    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">":8888"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d: dial error: %s"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">nil</span>
    <span class="token punctuation">}</span>
    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token string">":connect to server ok"</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> conn
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> sl <span class="token punctuation">[</span><span class="token punctuation">]</span>net<span class="token punctuation">.</span>Conn
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        conn <span class="token operator">:=</span> <span class="token function">establishConn</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
        <span class="token keyword">if</span> conn <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            sl <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>sl<span class="token punctuation">,</span> conn<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">10000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从程序可以看出，服务端在listen成功后，每隔10s钟accept一次。客户端则是串行的尝试建立连接。这两个程序在Darwin下的执行 结果：</p>
<pre class="line-numbers language-shell"><code class="language-shell">$go run server2.go
2015/11/16 21:55:41 listen ok
2015/11/16 21:55:51 1: accept a new connection
2015/11/16 21:56:01 2: accept a new connection
... ...

$go run client2.go
2015/11/16 21:55:44 1 :connect to server ok
2015/11/16 21:55:44 2 :connect to server ok
2015/11/16 21:55:44 3 :connect to server ok
... ...

2015/11/16 21:55:44 126 :connect to server ok
2015/11/16 21:55:44 127 :connect to server ok
2015/11/16 21:55:44 128 :connect to server ok

2015/11/16 21:55:52 129 :connect to server ok
2015/11/16 21:56:03 130 :connect to server ok
2015/11/16 21:56:14 131 :connect to server ok
... ...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出Client初始时成功地一次性建立了128个连接，然后后续每阻塞近10s才能成功建立一条连接。也就是说在server端 backlog满时(未及时accept)，客户端将阻塞在Dial上，直到server端进行一次accept。至于为什么是128，这与darwin 下的默认设置有关：</p>
<pre class="line-numbers language-shell"><code class="language-shell">$sysctl -a|grep kern.ipc.somaxconn
kern.ipc.somaxconn: 128
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果我在ubuntu 14.04上运行上述server程序，我们的client端初始可以成功建立499条连接。</p>
<p>如果server一直不accept，client端会一直阻塞么？我们去掉accept后的结果是：在Darwin下，client端会阻塞大 约1分多钟才会返回timeout：</p>
<pre class="line-numbers language-shell"><code class="language-shell">2015/11/16 22:03:31 128 :connect to server ok
2015/11/16 22:04:48 129: dial error: dial tcp :8888: getsockopt: operation timed out
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>而如果server运行在ubuntu 14.04上，client似乎一直阻塞，我等了10多分钟依旧没有返回。 阻塞与否看来与server端的网络实现和设置有关。</p>
<h3 id="3、网络延迟较大，Dial阻塞并超时"><a href="#3、网络延迟较大，Dial阻塞并超时" class="headerlink" title="3、网络延迟较大，Dial阻塞并超时"></a>3、网络延迟较大，Dial阻塞并超时</h3><p>如果网络延迟较大，TCP握手过程将更加艰难坎坷（各种丢包），时间消耗的自然也会更长。Dial这时会阻塞，如果长时间依旧无法建立连接，则Dial也会返回“ getsockopt: operation timed out”错误。</p>
<p>在连接建立阶段，多数情况下，Dial是可以满足需求的，即便阻塞一小会儿。但对于某些程序而言，需要有严格的连接时间限定，如果一定时间内没能成功建立连接，程序可能会需要执行一段“异常”处理逻辑，为此我们就需要DialTimeout了。下面的例子将Dial的最长阻塞时间限制在2s内，超出这个时长，Dial将返回timeout error：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">//go-tcpsock/conn_establish/client3.go</span>
<span class="token operator">...</span> <span class="token operator">...</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"begin dial..."</span><span class="token punctuation">)</span>
    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">DialTimeout</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"104.236.176.96:80"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"dial error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"dial ok"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行结果如下（需要模拟一个延迟较大的网络环境）：</p>
<pre class="line-numbers language-shell"><code class="language-shell">$go run client3.go
2015/11/17 09:28:34 begin dial...
2015/11/17 09:28:36 dial error: dial tcp 104.236.176.96:80: i/o timeout
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="三、Socket读写"><a href="#三、Socket读写" class="headerlink" title="三、Socket读写"></a>三、Socket读写</h2><p>连接建立起来后，我们就要在conn上进行读写，以完成业务逻辑。前面说过Go runtime隐藏了I/O多路复用的复杂性。语言使用者只需采用goroutine+Block I/O的模式即可满足大部分场景需求。Dial成功后，方法返回一个net.Conn接口类型变量值，这个接口变量的动态类型为一个*TCPConn：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">//$GOROOT/src/net/tcpsock_posix.go</span>
<span class="token keyword">type</span> TCPConn <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    conn
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>TCPConn内嵌了一个unexported类型：conn，因此TCPConn”继承”了conn的Read和Write方法，后续通过Dial返回值调用的Write和Read方法均是net.conn的方法：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">//$GOROOT/src/net/net.go</span>
<span class="token keyword">type</span> conn <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    fd <span class="token operator">*</span>netFD
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> c<span class="token punctuation">.</span>fd <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Implementation of the Conn interface.</span>

<span class="token comment" spellcheck="true">// Read implements the Conn Read method.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span>b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token operator">!</span>c<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>EINVAL
    <span class="token punctuation">}</span>
    n<span class="token punctuation">,</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> err <span class="token operator">!=</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>
        err <span class="token operator">=</span> <span class="token operator">&amp;</span>OpError<span class="token punctuation">{</span>Op<span class="token punctuation">:</span> <span class="token string">"read"</span><span class="token punctuation">,</span> Net<span class="token punctuation">:</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>net<span class="token punctuation">,</span> Source<span class="token punctuation">:</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>laddr<span class="token punctuation">,</span> Addr<span class="token punctuation">:</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>raddr<span class="token punctuation">,</span> Err<span class="token punctuation">:</span> err<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> n<span class="token punctuation">,</span> err
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Write implements the Conn Write method.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">Write</span><span class="token punctuation">(</span>b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token operator">!</span>c<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>EINVAL
    <span class="token punctuation">}</span>
    n<span class="token punctuation">,</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        err <span class="token operator">=</span> <span class="token operator">&amp;</span>OpError<span class="token punctuation">{</span>Op<span class="token punctuation">:</span> <span class="token string">"write"</span><span class="token punctuation">,</span> Net<span class="token punctuation">:</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>net<span class="token punctuation">,</span> Source<span class="token punctuation">:</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>laddr<span class="token punctuation">,</span> Addr<span class="token punctuation">:</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>raddr<span class="token punctuation">,</span> Err<span class="token punctuation">:</span> err<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> n<span class="token punctuation">,</span> err
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面我们先来通过几个场景来总结一下conn.Read的行为特点。</p>
<h3 id="1、Socket中无数据"><a href="#1、Socket中无数据" class="headerlink" title="1、Socket中无数据"></a>1、Socket中无数据</h3><p>连接建立后，如果对方未发送数据到socket，接收方(Server)会阻塞在Read操作上，这和前面提到的“模型”原理是一致的。执行该Read操作的goroutine也会被挂起。runtime会监视该socket，直到其有数据才会重新<br>调度该socket对应的Goroutine完成read。由于篇幅原因，这里就不列代码了，例子对应的代码文件：go-tcpsock/read_write下的client1.go和server1.go。</p>
<h3 id="2、Socket中有部分数据"><a href="#2、Socket中有部分数据" class="headerlink" title="2、Socket中有部分数据"></a>2、Socket中有部分数据</h3><p>如果socket中有部分数据，且长度小于一次Read操作所期望读出的数据长度，那么Read将会成功读出这部分数据并返回，而不是等待所有期望数据全部读取后再返回。</p>
<p>Client端：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">//go-tcpsock/read_write/client2.go</span>
<span class="token operator">...</span> <span class="token operator">...</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"usage: go run client2.go YOUR_CONTENT"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"begin dial..."</span><span class="token punctuation">)</span>
    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">":8888"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"dial error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"dial ok"</span><span class="token punctuation">)</span>

    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
    data <span class="token operator">:=</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
    conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>

    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">10000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Server端：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">//go-tcpsock/read_write/server2.go</span>
<span class="token operator">...</span> <span class="token operator">...</span>
<span class="token keyword">func</span> <span class="token function">handleConn</span><span class="token punctuation">(</span>c net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">defer</span> c<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// read from the connection</span>
        <span class="token keyword">var</span> buf <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"start to read from conn"</span><span class="token punctuation">)</span>
        n<span class="token punctuation">,</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"conn read error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">}</span>
        log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"read %d bytes, content is %s\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">...</span> <span class="token operator">...</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们通过<code>client2.go</code>发送”hi”到Server端：<br>运行结果:</p>
<pre class="line-numbers language-shell"><code class="language-shell">$go run client2.go hi
2015/11/17 13:30:53 begin dial...
2015/11/17 13:30:53 dial ok

$go run server2.go
2015/11/17 13:33:45 accept a new connection
2015/11/17 13:33:45 start to read from conn
2015/11/17 13:33:47 read 2 bytes, content is hi
...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Client向socket中写入两个字节数据(“hi”)，Server端创建一个len = 10的slice，等待Read将读取的数据放入slice；Server随后读取到那两个字节：”hi”。Read成功返回，n =2 ，err = nil。</p>
<h3 id="3、Socket中有足够数据"><a href="#3、Socket中有足够数据" class="headerlink" title="3、Socket中有足够数据"></a>3、Socket中有足够数据</h3><p>如果socket中有数据，且长度大于等于一次Read操作所期望读出的数据长度，那么Read将会成功读出这部分数据并返回。这个情景是最符合我们对Read的期待的了：Read将用Socket中的数据将我们传入的slice填满后返回：n = 10, err = nil。</p>
<p>我们通过client2.go向Server2发送如下内容：abcdefghij12345，执行结果如下：</p>
<pre class="line-numbers language-shell"><code class="language-shell">$go run client2.go abcdefghij12345
2015/11/17 13:38:00 begin dial...
2015/11/17 13:38:00 dial ok

$go run server2.go
2015/11/17 13:38:00 accept a new connection
2015/11/17 13:38:00 start to read from conn
2015/11/17 13:38:02 read 10 bytes, content is abcdefghij
2015/11/17 13:38:02 start to read from conn
2015/11/17 13:38:02 read 5 bytes, content is 12345
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>client端发送的内容长度为15个字节，Server端Read buffer的长度为10，因此Server Read第一次返回时只会读取10个字节；Socket中还剩余5个字节数据，Server再次Read时会把剩余数据读出（如：情形2）。</p>
<h3 id="4、Socket关闭"><a href="#4、Socket关闭" class="headerlink" title="4、Socket关闭"></a>4、Socket关闭</h3><p>如果client端主动关闭了socket，那么Server的Read将会读到什么呢？这里分为“有数据关闭”和“无数据关闭”。</p>
<p>“有数据关闭”是指在client关闭时，socket中还有server端未读取的数据，我们在go-tcpsock/read_write/client3.go和server3.go中模拟这种情况：</p>
<pre class="line-numbers language-shell"><code class="language-shell">$go run client3.go hello
2015/11/17 13:50:57 begin dial...
2015/11/17 13:50:57 dial ok

$go run server3.go
2015/11/17 13:50:57 accept a new connection
2015/11/17 13:51:07 start to read from conn
2015/11/17 13:51:07 read 5 bytes, content is hello
2015/11/17 13:51:17 start to read from conn
2015/11/17 13:51:17 conn read error: EOF
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从输出结果来看，当client端close socket退出后，server3依旧没有开始Read，10s后第一次Read成功读出了5个字节的数据，当第二次Read时，由于client端 socket关闭，Read返回EOF error。</p>
<p>通过上面这个例子，我们也可以猜测出“无数据关闭”情形下的结果，那就是Read直接返回EOF error。</p>
<h3 id="5、读取操作超时"><a href="#5、读取操作超时" class="headerlink" title="5、读取操作超时"></a>5、读取操作超时</h3><p>有些场合对Read的阻塞时间有严格限制，在这种情况下，Read的行为到底是什么样的呢？在返回超时错误时，是否也同时Read了一部分数据了呢？这个实验比较难于模拟，下面的测试结果也未必能反映出所有可能结果。我们编写了<code>client4.go</code>和<code>server4.go</code>来模拟这一情形。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">//go-tcpsock/read_write/client4.go</span>
<span class="token operator">...</span> <span class="token operator">...</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"begin dial..."</span><span class="token punctuation">)</span>
    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">":8888"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"dial error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"dial ok"</span><span class="token punctuation">)</span>

    data <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">65536</span><span class="token punctuation">)</span>
    conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>

    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">10000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//go-tcpsock/read_write/server4.go</span>
<span class="token operator">...</span> <span class="token operator">...</span>
<span class="token keyword">func</span> <span class="token function">handleConn</span><span class="token punctuation">(</span>c net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">defer</span> c<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// read from the connection</span>
        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
        <span class="token keyword">var</span> buf <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">65536</span><span class="token punctuation">)</span>
        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"start to read from conn"</span><span class="token punctuation">)</span>
        c<span class="token punctuation">.</span><span class="token function">SetReadDeadline</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Microsecond <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        n<span class="token punctuation">,</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"conn read %d bytes,  error: %s"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
            <span class="token keyword">if</span> nerr<span class="token punctuation">,</span> ok <span class="token operator">:=</span> err<span class="token punctuation">.</span><span class="token punctuation">(</span>net<span class="token punctuation">.</span>Error<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token operator">&amp;&amp;</span> nerr<span class="token punctuation">.</span><span class="token function">Timeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">continue</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">}</span>
        log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"read %d bytes, content is %s\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在Server端我们通过Conn的SetReadDeadline方法设置了10微秒的读超时时间，Server的执行结果如下：</p>
<pre class="line-numbers language-shell"><code class="language-shell">$go run server4.go

2015/11/17 14:21:17 accept a new connection
2015/11/17 14:21:27 start to read from conn
2015/11/17 14:21:27 conn read 0 bytes,  error: read tcp 127.0.0.1:8888->127.0.0.1:60970: i/o timeout
2015/11/17 14:21:37 start to read from conn
2015/11/17 14:21:37 read 65536 bytes, content is
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虽然每次都是10微秒超时，但结果不同，第一次Read超时，读出数据长度为0；第二次读取所有数据成功，没有超时。反复执行了多次，没能出现“读出部分数据且返回超时错误”的情况。</p>
<p>和读相比，Write遇到的情形一样不少，我们也逐一看一下。</p>
<h3 id="1、成功写"><a href="#1、成功写" class="headerlink" title="1、成功写"></a>1、成功写</h3><p>前面例子着重于Read，client端在Write时并未判断Write的返回值。所谓“成功写”指的就是Write调用返回的n与预期要写入的数据长度相等，且error = nil。这是我们在调用Write时遇到的最常见的情形，这里不再举例了。</p>
<h3 id="2、写阻塞"><a href="#2、写阻塞" class="headerlink" title="2、写阻塞"></a>2、写阻塞</h3><p>TCP连接通信两端的OS都会为该连接保留数据缓冲，一端调用Write后，实际上数据是写入到OS的协议栈的数据缓冲的。TCP是全双工通信，因此每个方向都有独立的数据缓冲。当发送方将对方的接收缓冲区以及自身的发送缓冲区写满后，Write就会阻塞。我们来看一个例子：client5.go和server.go。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">//go-tcpsock/read_write/client5.go</span>
<span class="token operator">...</span> <span class="token operator">...</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"begin dial..."</span><span class="token punctuation">)</span>
    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">":8888"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"dial error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"dial ok"</span><span class="token punctuation">)</span>

    data <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">65536</span><span class="token punctuation">)</span>
    <span class="token keyword">var</span> total <span class="token builtin">int</span>
    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        n<span class="token punctuation">,</span> err <span class="token operator">:=</span> conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            total <span class="token operator">+=</span> n
            log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"write %d bytes, error:%s\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
            <span class="token keyword">break</span>
        <span class="token punctuation">}</span>
        total <span class="token operator">+=</span> n
        log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"write %d bytes this time, %d bytes in total\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> total<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"write %d bytes in total\n"</span><span class="token punctuation">,</span> total<span class="token punctuation">)</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">10000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//go-tcpsock/read_write/server5.go</span>
<span class="token operator">...</span> <span class="token operator">...</span>
<span class="token keyword">func</span> <span class="token function">handleConn</span><span class="token punctuation">(</span>c net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">defer</span> c<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// read from the connection</span>
        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
        <span class="token keyword">var</span> buf <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">60000</span><span class="token punctuation">)</span>
        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"start to read from conn"</span><span class="token punctuation">)</span>
        n<span class="token punctuation">,</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"conn read %d bytes,  error: %s"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
            <span class="token keyword">if</span> nerr<span class="token punctuation">,</span> ok <span class="token operator">:=</span> err<span class="token punctuation">.</span><span class="token punctuation">(</span>net<span class="token punctuation">.</span>Error<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token operator">&amp;&amp;</span> nerr<span class="token punctuation">.</span><span class="token function">Timeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">continue</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"read %d bytes, content is %s\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">...</span> <span class="token operator">...</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Server5在前10s中并不Read数据，因此当client5一直尝试写入时，写到一定量后就会发生阻塞：</p>
<pre class="line-numbers language-shell"><code class="language-shell">$go run client5.go

2015/11/17 14:57:33 begin dial...
2015/11/17 14:57:33 dial ok
2015/11/17 14:57:33 write 65536 bytes this time, 65536 bytes in total
2015/11/17 14:57:33 write 65536 bytes this time, 131072 bytes in total
2015/11/17 14:57:33 write 65536 bytes this time, 196608 bytes in total
2015/11/17 14:57:33 write 65536 bytes this time, 262144 bytes in total
2015/11/17 14:57:33 write 65536 bytes this time, 327680 bytes in total
2015/11/17 14:57:33 write 65536 bytes this time, 393216 bytes in total
2015/11/17 14:57:33 write 65536 bytes this time, 458752 bytes in total
2015/11/17 14:57:33 write 65536 bytes this time, 524288 bytes in total
2015/11/17 14:57:33 write 65536 bytes this time, 589824 bytes in total
2015/11/17 14:57:33 write 65536 bytes this time, 655360 bytes in total
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在Darwin上，这个size大约在679468bytes。后续当server5每隔5s进行Read时，OS socket缓冲区腾出了空间，client5就又可以写入了：</p>
<pre class="line-numbers language-shell"><code class="language-shell">$go run server5.go
2015/11/17 15:07:01 accept a new connection
2015/11/17 15:07:16 start to read from conn
2015/11/17 15:07:16 read 60000 bytes, content is
2015/11/17 15:07:21 start to read from conn
2015/11/17 15:07:21 read 60000 bytes, content is
2015/11/17 15:07:26 start to read from conn
2015/11/17 15:07:26 read 60000 bytes, content is
....

client端：

2015/11/17 15:07:01 write 65536 bytes this time, 720896 bytes in total
2015/11/17 15:07:06 write 65536 bytes this time, 786432 bytes in total
2015/11/17 15:07:16 write 65536 bytes this time, 851968 bytes in total
2015/11/17 15:07:16 write 65536 bytes this time, 917504 bytes in total
2015/11/17 15:07:27 write 65536 bytes this time, 983040 bytes in total
2015/11/17 15:07:27 write 65536 bytes this time, 1048576 bytes in total
.... ...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3、写入部分数据"><a href="#3、写入部分数据" class="headerlink" title="3、写入部分数据"></a>3、写入部分数据</h3><p>Write操作存在写入部分数据的情况，比如上面例子中，当client端输出日志停留在“write 65536 bytes this time, 655360 bytes in total”时，我们杀掉server5，这时我们会看到client5输出以下日志：</p>
<pre class="line-numbers language-shell"><code class="language-shell">...
2015/11/17 15:19:14 write 65536 bytes this time, 655360 bytes in total
2015/11/17 15:19:16 write 24108 bytes, error:write tcp 127.0.0.1:62245->127.0.0.1:8888: write: broken pipe
2015/11/17 15:19:16 write 679468 bytes in total
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>显然Write并非在655360这个地方阻塞的，而是后续又写入24108后发生了阻塞，server端socket关闭后，我们看到Wrote返回er != nil且n = 24108，程序需要对这部分写入的24108字节做特定处理。</p>
<h3 id="4、写入超时"><a href="#4、写入超时" class="headerlink" title="4、写入超时"></a>4、写入超时</h3><p>如果非要给Write增加一个期限，那我们可以调用SetWriteDeadline方法。我们copy一份client5.go，形成client6.go，在client6.go的Write之前增加一行timeout设置代码：</p>
<pre class="line-numbers language-go"><code class="language-go">conn<span class="token punctuation">.</span><span class="token function">SetWriteDeadline</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Microsecond <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>启动server6.go，启动client6.go，我们可以看到写入超时的情况下，Write的返回结果：</p>
<pre class="line-numbers language-shell"><code class="language-shell">$go run client6.go
2015/11/17 15:26:34 begin dial...
2015/11/17 15:26:34 dial ok
2015/11/17 15:26:34 write 65536 bytes this time, 65536 bytes in total
... ...
2015/11/17 15:26:34 write 65536 bytes this time, 655360 bytes in total
2015/11/17 15:26:34 write 24108 bytes, error:write tcp 127.0.0.1:62325->127.0.0.1:8888: i/o timeout
2015/11/17 15:26:34 write 679468 bytes in total
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到在写入超时时，依旧存在部分数据写入的情况。</p>
<p>综上例子，虽然Go给我们提供了阻塞I/O的便利，但在调用Read和Write时依旧要综合需要方法返回的n和err的结果，以做出正确处理。net.conn实现了io.Reader和io.Writer接口，因此可以试用一些wrapper包进行socket读写，比如bufio包下面的Writer和Reader、io/ioutil下的函数等。</p>
<h3 id="Goroutine-safe"><a href="#Goroutine-safe" class="headerlink" title="Goroutine safe"></a>Goroutine safe</h3><p>基于goroutine的网络架构模型，存在在不同goroutine间共享conn的情况，那么conn的读写是否是goroutine safe的呢？在深入这个问题之前，我们先从应用意义上来看read操作和write操作的goroutine-safe必要性。</p>
<p>对于read操作而言，由于TCP是面向字节流，conn.Read无法正确区分数据的业务边界，因此多个goroutine对同一个conn进行read的意义不大，goroutine读到不完整的业务包反倒是增加了业务处理的难度。对与Write操作而言，倒是有多个goroutine并发写的情况。不过conn读写是否goroutine-safe的测试不是很好做，我们先深入一下runtime代码，先从理论上给这个问题定个性：</p>
<p>net.conn只是*netFD的wrapper结构，最终Write和Read都会落在其中的fd上：</p>
<pre><code>type conn struct {
    fd *netFD
}
</code></pre><p>netFD在不同平台上有着不同的实现，我们以net/fd_unix.go中的netFD为例：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Network file descriptor.</span>
<span class="token keyword">type</span> netFD <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// locking/lifetime of sysfd + serialize access to Read and Write methods</span>
    fdmu fdMutex

    <span class="token comment" spellcheck="true">// immutable until Close</span>
    sysfd       <span class="token builtin">int</span>
    family      <span class="token builtin">int</span>
    sotype      <span class="token builtin">int</span>
    isConnected <span class="token builtin">bool</span>
    net         <span class="token builtin">string</span>
    laddr       Addr
    raddr       Addr

    <span class="token comment" spellcheck="true">// wait server</span>
    pd pollDesc
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们看到netFD中包含了一个runtime实现的fdMutex类型字段，从注释上来看，该fdMutex用来串行化对该netFD对应的sysfd的Write和Read操作。从这个注释上来看，所有对conn的Read和Write操作都是有fdMutex互斥的，从netFD的Read和Write方法的实现也证实了这一点：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>fd <span class="token operator">*</span>netFD<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> fd<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> err
    <span class="token punctuation">}</span>
    <span class="token keyword">defer</span> fd<span class="token punctuation">.</span><span class="token function">readUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> fd<span class="token punctuation">.</span>pd<span class="token punctuation">.</span><span class="token function">PrepareRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> err
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        n<span class="token punctuation">,</span> err <span class="token operator">=</span> syscall<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>fd<span class="token punctuation">.</span>sysfd<span class="token punctuation">,</span> p<span class="token punctuation">)</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            n <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token keyword">if</span> err <span class="token operator">==</span> syscall<span class="token punctuation">.</span>EAGAIN <span class="token punctuation">{</span>
                <span class="token keyword">if</span> err <span class="token operator">=</span> fd<span class="token punctuation">.</span>pd<span class="token punctuation">.</span><span class="token function">WaitRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
                    <span class="token keyword">continue</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        err <span class="token operator">=</span> fd<span class="token punctuation">.</span><span class="token function">eofError</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> err<span class="token punctuation">.</span><span class="token punctuation">(</span>syscall<span class="token punctuation">.</span>Errno<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>
        err <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">NewSyscallError</span><span class="token punctuation">(</span><span class="token string">"read"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>fd <span class="token operator">*</span>netFD<span class="token punctuation">)</span> <span class="token function">Write</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>nn <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> fd<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> err
    <span class="token punctuation">}</span>
    <span class="token keyword">defer</span> fd<span class="token punctuation">.</span><span class="token function">writeUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> fd<span class="token punctuation">.</span>pd<span class="token punctuation">.</span><span class="token function">PrepareWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> err
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> n <span class="token builtin">int</span>
        n<span class="token punctuation">,</span> err <span class="token operator">=</span> syscall<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>fd<span class="token punctuation">.</span>sysfd<span class="token punctuation">,</span> p<span class="token punctuation">[</span>nn<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> n <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>
            nn <span class="token operator">+=</span> n
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> nn <span class="token operator">==</span> <span class="token function">len</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> err <span class="token operator">==</span> syscall<span class="token punctuation">.</span>EAGAIN <span class="token punctuation">{</span>
            <span class="token keyword">if</span> err <span class="token operator">=</span> fd<span class="token punctuation">.</span>pd<span class="token punctuation">.</span><span class="token function">WaitWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
                <span class="token keyword">continue</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            err <span class="token operator">=</span> io<span class="token punctuation">.</span>ErrUnexpectedEOF
            <span class="token keyword">break</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> err<span class="token punctuation">.</span><span class="token punctuation">(</span>syscall<span class="token punctuation">.</span>Errno<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>
        err <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">NewSyscallError</span><span class="token punctuation">(</span><span class="token string">"write"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> nn<span class="token punctuation">,</span> err
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每次Write操作都是受lock保护，直到此次数据全部write完。因此在应用层面，要想保证多个goroutine在一个conn上write操作的Safe，需要一次write完整写入一个“业务包”；一旦将业务包的写入拆分为多次write，那就无法保证某个Goroutine的某“业务包”数据在conn发送的连续性。</p>
<p>同时也可以看出即便是Read操作，也是lock保护的。多个Goroutine对同一conn的并发读不会出现读出内容重叠的情况，但内容断点是依 runtime调度来随机确定的。存在一个业务包数据，1/3内容被goroutine-1读走，另外2/3被另外一个goroutine-2读 走的情况。比如一个完整包：world，当goroutine的read slice size &lt; 5时，存在可能：一个goroutine读到 “worl”,另外一个goroutine读出”d”。</p>
<h2 id="四、Socket属性"><a href="#四、Socket属性" class="headerlink" title="四、Socket属性"></a>四、Socket属性</h2><p>原生Socket API提供了丰富的sockopt设置接口，但Golang有自己的网络架构模型，golang提供的socket options接口也是基于上述模型的必要的属性设置。包括</p>
<ul>
<li>SetKeepAlive</li>
<li>SetKeepAlivePeriod</li>
<li>SetLinger</li>
<li>SetNoDelay （默认no delay）</li>
<li>SetWriteBuffer</li>
<li>SetReadBuffer</li>
</ul>
<p>不过上面的Method是TCPConn的，而不是Conn的，要使用上面的Method的，需要type assertion：</p>
<pre class="line-numbers language-go"><code class="language-go">tcpConn<span class="token punctuation">,</span> ok <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>TCPConn<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//error handle</span>
<span class="token punctuation">}</span>

tcpConn<span class="token punctuation">.</span><span class="token function">SetNoDelay</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于listener socket, golang默认采用了 SO_REUSEADDR，这样当你重启 listener程序时，不会因为address in use的错误而启动失败。而listen backlog的默认值是通过获取系统的设置值得到的。不同系统不同：mac 128, linux 512等。</p>
<h2 id="五、关闭连接"><a href="#五、关闭连接" class="headerlink" title="五、关闭连接"></a>五、关闭连接</h2><p>和前面的方法相比，关闭连接算是最简单的操作了。由于socket是全双工的，client和server端在己方已关闭的socket和对方关闭的socket上操作的结果有不同。看下面例子：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">//go-tcpsock/conn_close/client1.go</span>
<span class="token operator">...</span> <span class="token operator">...</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"begin dial..."</span><span class="token punctuation">)</span>
    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">":8888"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"dial error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"close ok"</span><span class="token punctuation">)</span>

    <span class="token keyword">var</span> buf <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span>
    n<span class="token punctuation">,</span> err <span class="token operator">:=</span> conn<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"read % bytes, content is %s\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    n<span class="token punctuation">,</span> err <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"write error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"write % bytes, content is %s\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//go-tcpsock/conn_close/server1.go</span>
<span class="token operator">...</span> <span class="token operator">...</span>
<span class="token keyword">func</span> <span class="token function">handleConn</span><span class="token punctuation">(</span>c net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">defer</span> c<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">// read from the connection</span>
    <span class="token keyword">var</span> buf <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"start to read from conn"</span><span class="token punctuation">)</span>
    n<span class="token punctuation">,</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"conn read error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"read %d bytes, content is %s\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    n<span class="token punctuation">,</span> err <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"conn write error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"write %d bytes, content is %s\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">...</span> <span class="token operator">...</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述例子的执行结果如下：</p>
<pre class="line-numbers language-shell"><code class="language-shell">$go run server1.go
2015/11/17 17:00:51 accept a new connection
2015/11/17 17:00:51 start to read from conn
2015/11/17 17:00:51 conn read error: EOF
2015/11/17 17:00:51 write 10 bytes, content is

$go run client1.go
2015/11/17 17:00:51 begin dial...
2015/11/17 17:00:51 close ok
2015/11/17 17:00:51 read error: read tcp 127.0.0.1:64195->127.0.0.1:8888: use of closed network connection
2015/11/17 17:00:51 write error: write tcp 127.0.0.1:64195->127.0.0.1:8888: use of closed network connection
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从client1的结果来看，在己方已经关闭的socket上再进行read和write操作，会得到”use of closed network connection” error；<br>从server1的执行结果来看，在对方关闭的socket上执行read操作会得到EOF error，但write操作会成功，因为数据会成功写入己方的内核socket缓冲区中，即便最终发不到对方socket缓冲区了，因为己方socket并未关闭。因此当发现对方socket关闭后，己方应该正确合理处理自己的socket，再继续write已经无任何意义了。</p>
<h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p>本文比较基础，但却很重要，毕竟golang是面向大规模服务后端的，对通信环节的细节的深入理解会大有裨益。另外Go的goroutine+阻塞通信的网络通信模型降低了开发者心智负担，简化了通信的复杂性，这点尤为重要。</p>
<p>本文代码实验环境：go 1.5.1 on Darwin amd64以及部分在ubuntu 14.04 amd64。</p>
<p>本文demo代码在<a href="https://github.com/bigwhite/experiments/tree/master/go-tcpsock" target="_blank" rel="external">这里</a>可以找到。</p>
<p>© 2015, <a href="http://tonybai.com/" target="_blank" rel="external">bigwhite</a>. 版权所有.</p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;转载文章&lt;/p&gt;
&lt;h1 id=&quot;Go语言TCP-Socket编程&quot;&gt;&lt;a
    
    </summary>
    
      <category term="GO" scheme="http://yusank.github.io/categories/GO/"/>
    
    
      <category term="GO" scheme="http://yusank.github.io/tags/GO/"/>
    
      <category term="网络编程" scheme="http://yusank.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="TCP" scheme="http://yusank.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Docker 的使用</title>
    <link href="http://yusank.github.io/docker-practice.html/"/>
    <id>http://yusank.github.io/docker-practice.html/</id>
    <published>2017-07-17T07:52:00.000Z</published>
    <updated>2017-07-17T07:52:01.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><p> docker 的基本操作和使用。。。<br> <a id="more"></a></p>
<h1 id="Docker-的使用"><a href="#Docker-的使用" class="headerlink" title="Docker 的使用"></a>Docker 的使用</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><hr>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><hr>
<h4 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h4><p>所需的命令是 <code>docker run</code></p>
<p>例如：</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker run ubuntu:14.04 /bin/echo 'hello, worl'
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>容器执行后面的命令直接就会终止 .</p>
<p>下面的命令会启动容器并起一个 bash 终端,允许用户进行交互</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker run -t -i ubuntu:14.04 /bin/bash
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中 <code>-t</code>  让 Docker 分配一个伪终端 (pseudo-tty) 并绑定到容器的标准输入上, <code>-i</code> 则让容器的标准输入保持打开 .</p>
<p>利用 docker run 来创建容器是, Docker 在后台运行的标准操作包括:</p>
<ul>
<li>检查本地是否存在指定的镜像,不存在就从共有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统并在只读的镜像层外面挂载一层可读写层</li>
<li>在宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器终止</li>
</ul>
<h4 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h4><p>可以利用 <code>docker start</code> 命令,直接将一个已经终止的容器启动运行 .</p>
<p>可以通过 <code>docker ps -a</code> 查看所有的容器和其状态</p>
<pre class="line-numbers language-shell"><code class="language-shell">CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS                     PORTS                    NAMES
aada74689bf7        cockroachdb/cockroach   "/cockroach/cockro..."   3 weeks ago         Exited (137) 3 weeks ago                            roach_master
2e9eb6cf3f66        owncloud                "/entrypoint.sh ap..."   3 weeks ago         Up 3 weeks                 0.0.0.0:80->80/tcp       owncloud
91290c737c73        postgres                "docker-entrypoint..."   3 weeks ago         Up 3 weeks                 5432/tcp                 owncloud-postgres
8f546ec65e61        mysql                   "docker-entrypoint..."   3 weeks ago         Up 3 weeks                 0.0.0.0:3306->3306/tcp   mysql
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不难发现 name 为 roch_master 的容器已经终止了,想重新启动它,可以执行下面的命令</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker start aada74689bf7
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>参数为容器的 id .</p>
<h3 id="后台-background-运行"><a href="#后台-background-运行" class="headerlink" title="后台( background )运行"></a>后台( background )运行</h3><p>在很多时候,我们需要让 docker 在后台运行而并不是把执行结果直接输出出来.</p>
<p>这个时候我们可以添加 <code>-d</code> 参数来实现</p>
<p>如果使用 <code>-d</code> 参数运行容器</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker run -d mysql:5.7.17
77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>只会输出运行的容器 id, 而输出结果可以用 docker logs 查看 .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker logs [container ID or NAMES]
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>可以使用 <code>docker stop</code>  来终止正在运行的容器 .</p>
<p>此外,当 Docker 容器中指定的应用终结时, 容器也自动终止 . 例如运行一个容器时,指定了一个终端后,当退出终端的时候,所创建的容器也会立刻终止 .</p>
<p>终止状态的容器, 可以通过 <code>docker start</code> 来重新启动 .</p>
<p>此外,<code>docker restart</code> 命令会将一个运行态的容器终止,然后重新启动它 .</p>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>在使用 <code>-d</code> 参数时, docker 容器会在后台运行. 有些时候需要进入容器,如运行数据库时,需要进入增删改查库里的内容. 进入容器有很多种办法.</p>
<h4 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a>attach 命令</h4><figcaption>attach</code> 是 Docker 自带的命令,用法</p></figcaption><pre class="line-numbers language-docker"><code class="language-docker">&lt;p<span class="token punctuation">></span>但是使用 &lt;code<span class="token punctuation">></span>attach&lt;/code<span class="token punctuation">></span> 命令有个缺陷<span class="token punctuation">,</span>即多个窗口同时用 attach 命令到同一个容器的时候<span class="token punctuation">,</span>所有的窗口都是同步显示的<span class="token punctuation">,</span>如果其中一个窗口阻塞的时候<span class="token punctuation">,</span>其他窗口也无法使用 .&lt;/p<span class="token punctuation">></span>
&lt;h4 id=<span class="token string">"nsenter-命令"</span><span class="token punctuation">></span>&lt;a href=<span class="token string">"#nsenter-命令"</span> class=<span class="token string">"headerlink"</span> title=<span class="token string">"nsenter 命令"</span><span class="token punctuation">></span>&lt;/a<span class="token punctuation">></span>nsenter 命令&lt;/h4<span class="token punctuation">></span>&lt;p<span class="token punctuation">></span>这个工具需要用如下命令安装&lt;/p<span class="token punctuation">></span>
&lt;pre<span class="token punctuation">></span>&lt;code class=<span class="token string">"shell"</span><span class="token punctuation">></span>$ docker run <span class="token punctuation">-</span><span class="token punctuation">-</span>rm <span class="token punctuation">-</span>v /usr/local/bin<span class="token punctuation">:</span>/target jpetazzo/nsenter
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>使用方法也比较简单,首先是你要进入的容器的 ID</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ PID=$(docker inspect --format {{.State.Pid}} <container ID or NAMES>)
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后通过这个 PID 进入容器</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ nsenter --target $PID --mount --uts --ipc --net --pid
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果无法通过上述的命令连接到容器,有可能是因为宿主的默认 shell 在容器中并不存在,比如 zsh, 可以使用如下命令显示地使用 bash .</p>
<h4 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a>exec 命令</h4><pre class="line-numbers language-shell"><code class="language-shell">$docker exec -it [container ID or NAMES]
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>-i</code> <code>-t</code> 前面说过为了标准输入输出保持打开 .</p>
<h3 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h3><h4 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h4><p>如果要导出本地某个容器,可以使用 <code>docker export</code> 命令 .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker export [container ID or NAMES] > target.tar
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样将导出容器快照到本地文件 .</p>
<h4 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h4><p>可以使用 <code>docker import</code> 从容器快照文件导入镜像,</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ cat target.tar | docker import - test/mysql:v1.0
$ sudo docker images
REPOSITORY  TAG  IMAGE ID         CREATED             VIRTUAL SIZE
test/ubuntu v1.0 9d37a6082e97     About a minute ago     171.3 MB
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>此外,还可以通过指定 URL 或者某个目录来导入</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker import http://example.com/exampleimage.tgz example/imagerepo
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>*注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库,也可以使用 docker import 来导入一个容器快照到本地镜像库 .这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态）,而镜像存储文件将保存完整记录,体积也要大 .此外,从容器快照文件导入时可以重新指定标签等元数据信息 .</p>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><h4 id="单独删除"><a href="#单独删除" class="headerlink" title="单独删除"></a>单独删除</h4><p>可以使用 <code>docker rm</code> 来删除一个处于终止状态的容器 .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker rm [container ID or NAMES]
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果要删除一个运行中的容器,可以添加 <code>-f</code> 参数 .Docker 会发送 <code>SIGKILL</code> 信号给容器 .</p>
<h4 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h4><p>用  <code>docker ps -a</code>  命令可以查看所有已创建的包括终止状态的容器,如果想批量删除多个容器的话(当然是终止状态的容器) ,可以用这个命令</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker rm $(docker ps -a -q)
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>*注意：这个命令其实会试图删除所有的包括还在运行中的容器,不过就像上面提过的 docker rm 默认并不会删除运行中的容器 .</p>
<h2 id="访问仓库"><a href="#访问仓库" class="headerlink" title="访问仓库"></a>访问仓库</h2><p>仓库（Repository）是集中存放镜像的地方 .</p>
<p>一个容易混淆的概念是注册服务器（Registry） .实际上注册服务器是管理仓库的具体服务器,每个服务器上可以有多个仓库,而每个仓库下面有多个镜像 .从这方面来说,仓库可以被认为是一个具体的项目或目录 .例如对于仓库地址dl.dockerpool.com/ubuntu 来说, dl.dockerpool.com 是注册服务器地址, ubuntu 是仓库名 .</p>
<p>大部分时候,并不需要严格区分这两者的概念 .</p>
<h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/explore/" target="_blank" rel="external">Docker Hub</a>,   但是开始把阵地移到 <a href="https://store.docker.com/" target="_blank" rel="external">Docker Store</a> 这个平台上,其上能找到几乎所有的能想得到的容器, 不可小觑 .</p>
<h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>可以通过执行 docker login 命令来输入用户名、密码和邮箱来完成注册和登录 . 注册成功后,本地用户目录的.dockercfg 中将保存用户的认证信息 .</p>
<h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><p>用户无需登录即可通过 <code>docker search</code> 命令来查找官方仓库中的镜像, 并利用 <code>docker pull</code> 命令来将它下载到本地 .</p>
<p>以搜索 mongo 为关键字搜索:</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker search mongo
NAME                           DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mongo                          MongoDB document databases provide high av...   3427      [OK]
mongo-express                  Web-based MongoDB admin interface, written...   168       [OK]
mvertes/alpine-mongo           light MongoDB container                         51                               [OK]
mongoclient/mongoclient        Official docker image for Mongoclient, fea...   29                               [OK]
torusware/speedus-mongo        Always updated official MongoDB docker ima...   9                                [OK]
mongooseim/mongooseim-docker   MongooseIM server the latest stable version     9                                [OK]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​搜索结果可以看到很多包含关键字的镜像,其中包括镜像名字、描述、星数（表示该镜像的受欢迎程度）、是否官方创建、是否自动创建 . 官方的镜像说明是官方项目组创建和维护的,automated 资源允许用户验证镜像的来源和内容 .</p>
<p>​根据是否为官方提供, 镜像资源可分为两类 . 一类是累类似 mongo这样的基础镜像 . 这些镜像由 Docker 的用户创建、验证、支持、提供  . 这样的镜像往往是使用单个单词作为名字  . </p>
<p>另一种类型,比如<code>mvertes/alpine-mongo</code> 镜像,它是由 Docker 的用户创建并维护的,往往带有用户名称前缀  . 可以通过前缀 <code>user_name/</code> 来指定使用某个用户提供的镜像  .</p>
<p>另外,在查找的时候通过 <code>-s N</code> 参数可以指定仅显示星数为 N 以上的镜像 （新版本的 Docker 推荐使用 <code>--flter=stars=N</code> 参数） .</p>
<p>下载镜像到本地</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo docker pull centos
Pulling repository centos
0b443ba03958: Download complete
539c0211cd76: Download complete
511136ea3c5a: Download complete
7064731afe90: Download complete
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用户也可以登录之后通过 <code>docker push</code> 命令来讲镜像推送到 Docker Hub  .</p>
<h4 id="自动创建"><a href="#自动创建" class="headerlink" title="自动创建"></a>自动创建</h4><p>​自动创建（automated builds）功能对于需要经常升级镜像内程序来说,十分方便 .有时候,用户创建了镜像安装了某个软件,如果软件发布新版本则需要手动更新镜像 . .而自动创建允许用户通过 Docker Hub 指定跟踪一个目标网站（目前支持 GitHub或 BitBucket）上的项目,一旦项目发生新的提交,则自动执行创建 .</p>
<p>要配置自动创建,包括如下的步骤：</p>
<ul>
<li>创建并登录 Docker Hub,以及目标网站；</li>
<li>在目标网站中连接帐户到 Docker Hub；</li>
<li>在 Docker Hub 中 配置一个自动创建；</li>
<li>选取一个目标网站中的项目（需要含 Dockerfile）和分支；</li>
<li>指定 Dockerfile 的位置,并提交创建 .</li>
</ul>
<p>之后,可以 在Docker Hub 的 自动创建页面 中跟踪每次创建的状态 .</p>
<h3 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h3><p>有时候使用 Docker Hub 这样的公共仓库由于网络等原因可能不方便,用户可以创建一个本地仓库供私人使用 .</p>
<p>需要用到 <code>docker-registry</code> 工具 .</p>
<p><code>docker-registry</code> 是官方提供的工具,可以用于构建私有的镜像仓库  .</p>
<h4 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h4><h5 id="容器运行"><a href="#容器运行" class="headerlink" title="容器运行"></a>容器运行</h5><p>在安装了 Docker 后,可以通过获取官方 registry 镜像来运行  .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker run -d -p 5000:5000 registry
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这将使用官方的 registry 镜像来启动本地的私有仓库 .用户可以通过制定参数来配置私有仓库位置,例如配置镜像存储到 Amazon S3 服务  .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo docker run \
-e SETTINGS_FLAVOR=s3 \
-e AWS_BUCKET=acme-docker \
-e STORAGE_PATH=/registry \
-e AWS_KEY=AKIAHSHB43HS3J92MXZ \
-e AWS_SECRET=xdDowwlK7TJajV1Y7EoOZrmuPEJlHYcNP2k4j49T
\
-e SEARCH_BACKEND=sqlalchemy \
-p 5000:5000 \
registry
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此外,还可以指定本地路径（如<code>/home/user/registry-conf</code> ）下的配置文件  .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo docker run -d -p 5000:5000 -v /home/user/registry-conf:/r
egistry-conf -e DOCKER_REGISTRY_CONFIG=/registry-conf/config.yml
registry
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p> 默认情况下,仓库会被创建在容器的 <code>/var/lib/registry</code> 下 .可以通过 <code>-v</code>  参数来将镜像文件存放在本地的指定路径  . 例如下面的例子将上传的镜像放到 <code>/opt/data/registy</code> 目录  .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo docker run -d -p 5000:5000 -v /opt/data/registry:/var/lib
/registry registry
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h4><p>对于 Ubuntu 或 CentOS 等发行版,可以直接安装  .</p>
<ul>
<li>Ubuntu</li>
</ul>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo apt-get install -y build-essential python-dev libevent-dev python-pip liblzma-dev
$ sudo pip install docker-registry
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>CentOS</li>
</ul>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo yum install -y python-devel libevent-devel python-pip gcc xz-devel
$ sudo python-pip install docker-registry
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>也可以从 docker-registry 项目下载源码进行安装  .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo apt-get install build-essential python-dev libevent-dev python-pip libssl-dev liblzma-dev libffi-dev
$ git clone https://github.com/docker/docker-registry.git
$ cd docker-registry
$ sudo python setup.py install
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后修改配置文件,主要修改 dev 模板段的 <code>storage_path</code> 到本地的存储仓库的路径  .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ cp config/config_sample.yml config/config.yml
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>之后启动 web 服务  .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo gunicorn -c contrib/gunicorn.py docker_registry.wsgi:application
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者 </p>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo gunicorn --access-logfile - --error-logfile - -k gevent -b 0.0.0.0:5000 -w 4 --max-requests 100 docker_registry.wsgi:application
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此时使用 crul 访问本地的 5000 端口,看到输出 docker-registry 的版本信息说明运行成功  .</p>
<p>*注 ： <code>config/config_sample.yml</code> 文件时示例配置文件</p>
<h4 id="在私有仓库上传、下载、搜索镜像"><a href="#在私有仓库上传、下载、搜索镜像" class="headerlink" title="在私有仓库上传、下载、搜索镜像"></a>在私有仓库上传、下载、搜索镜像</h4><p>创建好私有仓库之后,就可以使用 <code>docker tag</code> 来标记一个镜像,然后推送它到仓库,别的机器上就可以下载了 .如 私有仓库地址为 <code>1192.168.7.26:5000</code></p>
<p>先在本机上查看已有的镜像  .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker images
REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE
node                    latest              f93ba6280cbd        3 weeks ago         667MB
cockroachdb/cockroach   latest              404f7ee26d38        4 weeks ago         163MB
postgres                latest              ca3a55649cfc        7 weeks ago         269MB
tomcat                  latest              0785a1d16826        7 weeks ago         367MB
owncloud                latest              2327c8d59618        8 weeks ago         572MB
mysql                   latest              e799c7f9ae9c        2 months ago        407MB
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>docker tag</code> 将 <code>tomcat</code>  这个镜像标记为 <code>192.168.7.26：5000/test</code></pre>
<pre class="line-numbers language-shell"><code class="language-shell">[root@vultr ~]# docker tag tomcat 192.168.7.26:5000/test
[root@vultr ~]# docker images
REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE
node                     latest              f93ba6280cbd        3 weeks ago         667MB
cockroachdb/cockroach    latest              404f7ee26d38        4 weeks ago         163MB
postgres                 latest              ca3a55649cfc        7 weeks ago         269MB
192.168.7.26:5000/test   latest              0785a1d16826        7 weeks ago         367MB
tomcat                   latest              0785a1d16826        7 weeks ago         367MB
owncloud                 latest              2327c8d59618        8 weeks ago         572MB
mysql                    latest              e799c7f9ae9c        2 months ago        407MB
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用 <code>docker push</code>  上传标记的镜像  .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker push 192.168.7.26:5000/test
The push refers to a repository [192.168.7.26:5000/test] (len: 1)
Sending image list
Pushing repository 192.168.7.26:5000/test (1 tags)
Image 511136ea3c5a already pushed, skipping
Image 9bad880da3d2 already pushed, skipping
Image 25f11f5fb0cb already pushed, skipping
Image ebc34468f71d already pushed, skipping
Image 2318d26665ef already pushed, skipping
Image ba5877dc9bec already pushed, skipping
Pushing tag for rev [ba5877dc9bec] on {http://192.168.7.26:5000/
v1/repositories/test/tags/latest}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用 <code>curl</code> 查看仓库中的镜像</p>
<pre class="line-numbers language-shell"><code class="language-shell">curl http://192.168.7.26:5000/v1/search
{"num_results": 7, "query": "", "results": [{"description": "","name": "library/miaxis_j2ee"}, {"description": "", "name": "library/tomcat"}, {"description": "", "name": "library/ubuntu"}, {"description": "", "name": "library/ubuntu_office"}, {"description": "", "name": "library/desktop_ubu"}, {"description": "", "name": "dockerfile/ubuntu"}, {"description": "", "name": "library/test"}]}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这里可以看到 <code>{&quot;description&quot;: &quot;&quot;, &quot;name&quot;: &quot;library/test&quot;}</code> ,表面镜像已经上传成功了  .</p>
<p>下载可以用另一台机器去下载这个镜像  .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker pull 192.168.7.26:5000/test
Pulling repository 192.168.7.26:5000/test
ba5877dc9bec: Download complete
511136ea3c5a: Download complete
9bad880da3d2: Download complete
25f11f5fb0cb: Download complete
ebc34468f71d: Download complete
2318d26665ef: Download complete
$ docker images
REPOSITORY         TAG         IMAGE ID
CREATED         VIRTUAL SIZE
192.168.7.26:5000/test latest ba5877dc9bec 
6 weeks ago         192.7 MB
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="仓库配置文件"><a href="#仓库配置文件" class="headerlink" title="仓库配置文件"></a>仓库配置文件</h3><p>Docker 的 registry 利用配置文件提供 了一些仓库的模板（flavor）,用户可以直接使用它们来进行开发或身产环境  .</p>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>在 <code>config_sample.yml</code> 文件中,可以看到一些现成的模板段：</p>
<ul>
<li><code>common</code> ：基础配置</li>
<li><code>local</code> ：存储数据到本地文件系统</li>
<li><code>s3</code> ：存储数据到 AWS S3 中</li>
<li><code>dev</code> ：使用 local 模板的基本配置</li>
<li><code>test</code> ：单元测试使用</li>
<li><code>prod</code> ：生产环境配置（基本上跟s3配置类似）</li>
<li><code>gcs</code> ：存储数据到 Google 的云存储</li>
<li><code>swift</code> ：存储数据到 OpenStack Swift 服务</li>
<li><code>glance</code> ：存储数据到 OpenStack Glance 服务,本地文件系统为后备</li>
<li><code>glance-swift</code>：存储数据到 OpenStack Glance 服务,Swift 为后备</li>
<li><code>elliptics</code> ：存储数据到 Elliptics key/value 存储</li>
</ul>
<p>用户可以添加自定义的模板段  .</p>
<p>默认情况下使用的模板是 <code>dev</code> ,要是使用某个模板作为默认值,可以添加 <code>SETTING-FLAVOR</code> 到环境变量中去,</p>
<pre class="line-numbers language-shell"><code class="language-shell">export SETTING_FLAVOR=dev
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>另外,配置文件中支持从环境变量中加载,语法格式为</p>
<pre class="line-numbers language-shell"><code class="language-shell">_env:VARIABLENAME[:DEFAULT]
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="line-numbers language-shell"><code class="language-shell">common:
loglevel: info
search_backend: "_env:SEARCH_BACKEND:"
sqlalchemy_index_database:
"_env:SQLALCHEMY_INDEX_DATABASE:sqlite:////tmp/docker-re
gistry.db"
prod:
loglevel: warn
storage: s3
s3_access_key: _env:AWS_S3_ACCESS_KEY
s3_secret_key: _env:AWS_S3_SECRET_KEY
s3_bucket: _env:AWS_S3_BUCKET
boto_bucket: _env:AWS_S3_BUCKET
storage_path: /srv/docker
smtp_host: localhost
from_addr: docker@myself.com
to_addr: my@myself.com
dev:
loglevel: debug
storage: local
storage_path: /home/myself/docker
test:
storage: local
storage_path: /tmp/tmpdockertmp
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Docker-数据管理"><a href="#Docker-数据管理" class="headerlink" title="Docker 数据管理"></a>Docker 数据管理</h2><p>在容器管理中数据主要有两种方式：</p>
<ul>
<li>数据卷 （Data volumes）</li>
<li>数据卷容器 （Data volume containers）</li>
</ul>
<h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>数据卷是一个可提供一个或多个容器使用的特殊目录,它绕过 UFS, 可以提供很多有用的特征：</p>
<ul>
<li>数据卷可以再荣期间共享和重用</li>
<li>对数据卷的修改立马生效</li>
<li>对数据及的更新,不会影响镜像</li>
<li>数据卷默认会一直存在,即使容器被删除</li>
</ul>
<p><em>注：数据卷的使用,类似于Linux 下对目录或文件进行 mount, 镜像中的被指定为挂载点的目录中的文件会隐藏掉,能显示看的是挂载的数据卷</em></p>
<h4 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h4><p>​在使用 <code>docker run</code> 命令的时候,使用 <code>-v</code> 参数来创建一个数据卷并挂载到容器里 .在一次 run 中可以挂载多个数据卷  .</p>
<p>下面创建一个名为 web 的容器,并加载一个数据卷到容器的 <code>/webapp</code> 目录  .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker run -d -p --name web -v /webapp training/webapp python app.py
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><em>注：也可以在 Docker 中使用 <code>volume</code> 来添加一个或多个新的卷到有该镜像创建的任意容器  .</em></p>
<h4 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h4><p>数据卷是被设计用来持久化数据的,它的生命周期独立于容器,Docker 不会在容器被删除后自动删除数据卷,并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷 .日光需要在删除容器的同时移除数据卷,可以再删除容器的时候使用 <code>docker rm -v</code> 这个命令 .</p>
<h4 id="挂载一个主句目录作为数据卷"><a href="#挂载一个主句目录作为数据卷" class="headerlink" title="挂载一个主句目录作为数据卷"></a>挂载一个主句目录作为数据卷</h4><p>使用 <code>-v</code> 参数也可以指定挂载一个本地主机的目录到容器中去  .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/opt/webapp</code> 目录 .这个功能在进行测试的时候十分方便,比如用户可以放置一些程序到本地目录中,来查看容器是否正常工作 .本地目录的路径必须是绝对路径,如果目录不存在 Docker会自动为你创建它 .</p>
<p><em>注：Dockerfile 中不支持这种用法,因为 Dockerfile 是为了移植和分享用的  . 然而,不同的操作系统的路径格式不一样,所以目前还不支持</em> </p>
<p>Docker 挂载数据卷的默认权限是读写, 用户也可以通过 <code>:ro</code> 指定为只读</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>加了 <code>:ro</code> 之后,就挂载为只读了 .</p>
<h4 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h4><p>在主机里使用以下命令可以查看指定容器的信息</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker inspect web
...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在输出的内容中找到其中和数据卷相关的部分,可以看到所有的数据卷都是创建在主句的 <code>/var/lib/docker/volumes/</code> 下面的</p>
<pre class="line-numbers language-shell"><code class="language-shell">"Volumes": {
"/webapp": "/var/lib/docker/volumes/fac362...80535"
},
"VolumesRW": {
"/webapp": true
}
...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>注：从 Docker 1.8.0 起,数据卷配置在 “Mounts” Key 下面, 可以看到所有的数据卷都是创建在主机的 <code>/mnt/sda1/var/lib/docker/volumes/...</code> 下面了  .</em></p>
<pre class="line-numbers language-json"><code class="language-json"><span class="token property">"Mounts"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
<span class="token punctuation">{</span>
<span class="token property">"Name"</span><span class="token operator">:</span> <span class="token string">"b53ebd40054dae599faf7c9666acfe205c3e922
fc3e8bc3f2fd178ed788f1c29"</span><span class="token punctuation">,</span>
<span class="token property">"Source"</span><span class="token operator">:</span> <span class="token string">"/mnt/sda1/var/lib/docker/volumes/b53e
bd40054dae599faf7c9666acfe205c3e922fc3e8bc3f2fd178ed788f1c29/_data"</span><span class="token punctuation">,</span>
<span class="token property">"Destination"</span><span class="token operator">:</span> <span class="token string">"/webapp"</span><span class="token punctuation">,</span>
<span class="token property">"Driver"</span><span class="token operator">:</span> <span class="token string">"local"</span><span class="token punctuation">,</span>
<span class="token property">"Mode"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>
<span class="token property">"RW"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token property">"Propagation"</span><span class="token operator">:</span> <span class="token string">""</span>
<span class="token punctuation">}</span>
<span class="token punctuation">]</span>
...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h4><p><code>-v</code> 参数也可以从主机挂载单个文件到文件到容器中</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样就可以记录在容器输入过得命令了  .</p>
<h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p>如果你有一些持续更新的数据需要在容器之间共享,最好创建数据卷容器  .</p>
<p>数据卷容器,其实就是一个正常的容器,专门用来提供数据卷供其他容器挂载的  .</p>
<p>首先,创建一个名为 dbdata 的数据卷容器：</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo docker run -d -v /dbdata --name dbdata training/postgres echo Data-only container for postgres
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后,在其他容器中使用 <code>--volumes-from</code> 来挂载 dbdata 容器中的数据卷  .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo docker run -d --volumes-form dbdata --name db1 training/postgres
$ sudo docker run -d --volumes-form dbdata --name db2 training/postgres
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以使用超过一个的<code>--volumes-from</code> 参数来指定从多个容器挂载不同的数据卷  . 也可以从其他已经挂载了数据卷的容器来级联挂载数据卷  .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker run -d --name db3 --volumes-from db1 training/postgres
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><em>注：使用 <code>--volumes-from</code>  参数所挂载数据卷的容器自己并不需要保持运行状态</em> </p>
<p>如果删除了挂载的容器（包括 dbdata、db1 和 db2 ）,数据卷并不会被自动删除 .如果删除一个数据卷,必须在删除最后一个还挂着它的容器时使用 <code>docker rm -v</code> 命令来指定同时删除关联的容器 .这可以让用户在容器之间升级和移到数据卷 .</p>
<h4 id="利用数据卷容器来备份、恢复、迁移数据卷"><a href="#利用数据卷容器来备份、恢复、迁移数据卷" class="headerlink" title="利用数据卷容器来备份、恢复、迁移数据卷"></a>利用数据卷容器来备份、恢复、迁移数据卷</h4><p>可以利用数据卷对其中的数据进行备份、恢复和迁移 .</p>
<h5 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h5><p>首先使用 <code>--volumes-from</code> 标记来创建一个加载 dbdata 数据卷的容器,并从主机挂载当前目录到容器的 /backup 目录 .命令如下：</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo docker run --volumes-from dbdata -v$(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>容器启动后,使用了 <code>tar</code> 命令来将 dbdata 卷备份为容器中 /backup/backup.tar 文件,也就是主机当前目录下的名为 backup.tar 的文件  .</p>
<h5 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h5><p>如果要恢复数据到一个容器,首先创建一个带有空数据卷的容器 dbdata2  .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker run -v /dbdata --name dbdata2 ubuntu /bin/bash
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后创建另一个容器,挂载 dbdata2 容器卷中的数据卷,并使用 <code>untar</code>  解压备份文件到挂载的容器卷中 .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo docker run --volumes-form dbdata2 -v $(pwd):/backup busybox tar xvf
/backup/backup.tar
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>为了查看/验证恢复的数据,可以再启动一个容器挂载同样的容器卷来查看</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker run --volumes-from dbdata2 busybox /bin/ls dbdata
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h5 id="迁移数据卷"><a href="#迁移数据卷" class="headerlink" title="迁移数据卷"></a>迁移数据卷</h5><p>代写 . . .</p>
<h1 id="Docker-中的网络"><a href="#Docker-中的网络" class="headerlink" title="Docker 中的网络"></a>Docker 中的网络</h1><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务  .</p>
<h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>容器中可以与运行一些网络应用,要让外部也可以访问这些应用,可以通过 <code>-P</code>  或 <code>-p</code> 参数来指定端口映射 .</p>
<p>当使用 <code>-P</code> 参数时,Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口 .</p>
<p>使用 <code>docker ps</code> 可以看到,本地主机的49155 被映射到了容器的5000 端口  .</p>
<p>此时访问本机的49155 端口即可访问容器内 web 应用提供的界面 .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo docker run -d -P training/webapp python app.py
$ sudo docker ps -l
CONTAINER ID         IMAGE                     COMMAND         CREATED
STATUS             PORTS                     NAMES
bc533791f3f5         training/webapp:latest     python app.py     5 seconds ag
o Up 2 seconds     0.0.0.0:49155->5000/tcp nostalgic_morse
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>-P</code> （小写）则可以指定要映射的端口,并且在一个指定端口上只可以绑定一个容器 .支持的格式有</p>
<ul>
<li><code>ip:HostPort:containerPort</code></li>
<li><code>ip::containerPort</code></li>
<li><code>hostPort:containerPort</code></li>
</ul>
<h3 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h3><p>使用 <code>hostPort ：containerPort</code> 格式本地的5000端口映射到容器的5000端口,可以执行</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker run -d -p 5000:5000 training/webapp python app.py
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此时默认会绑定本地所有接口上的所有接口 .</p>
<h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h3><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址,比如 localhost 地址 127.0.0.1</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><p>使用 <code>docker port</code> 来查看当前映射的端口配置,也可以查看到绑定的地址</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker port gogs
22/tcp -> 0.0.0.0:10022
3000/tcp -> 0.0.0.0:10080
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以看到 <code>gogs</code> 有两个容器内的端口 22, 3000 分别映射主机的10022,10080 端口  .</p>
<p><em>注： -p 可以多次使用来绑定多个端口,也就是说一条命令可以有多个 -p ,如：上面👆的 gogs 容器就绑定了俩端口</em></p>
<h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p>容器的连接（linking）系统是除了端口映射外,另一种跟容器中应用交互的方式 .该系统会在源和接受容器之间创建一个通道,接受容器可以看到源容器指定的信息 .</p>
<h3 id="自定义容器命名"><a href="#自定义容器命名" class="headerlink" title="自定义容器命名"></a>自定义容器命名</h3><p>连接系统依据容器的名称来执行 .因此,首先需要自定义一个好记的容器命名 .</p>
<p>虽然创建容器的时候,系统默认会分配给一个名字 .但是自定义命名容器的话,第一,好记,第二,可以作为有用的参考的 .</p>
<p>使用 <code>--name</code> 参数可以为容器自定义命名 .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker run -d -p 8181:4040 --name own-cloud owncloud
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用 <code>docker ps</code> 来查看正运行的容器</p>
<pre class="line-numbers language-shell"><code class="language-shell">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                            NAMES
2c2e766e86fd        owncloud            "/entrypoint.sh ap..."   23 hours ago        Up 23 hours         80/tcp, 0.0.0.0:8181->4040/tcp                   own-cloud
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>使用 <code>docker inspect</code> 命令来查看容器名字</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ docker inspect -f "{{.Name}}" 2c2e766e86fd
/own-cloud
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>注：容器的名称是唯一的 .如果已经命名了一个叫 own-cloud 的容器,当你再次使用这个名词的时候,需要先把之前的的同名容器删除</em></p>
<p><em>tips：在执行  <code>docker run</code>  的时候可以添加  <code>—rm</code>  参数,这样容器在终止后立刻删除 .注意,<code>—rm</code> 和  <code>-d</code> 参数不能同时使用  .</em></p>
<h3 id="容器互联-1"><a href="#容器互联-1" class="headerlink" title="容器互联"></a>容器互联</h3><p>使用 <code>--link</code> 参数可以让容器之间安全的进行交互 .</p>
<p>下面是,运行 <code>Nginx</code> 容器的时候把 <code>gogs</code> 这个容器连接上</p>
<pre class="line-numbers language-shell"><code class="language-shell">docker run -d --name my_nginx --link gogs:app --link own-cloud:app2 -p 80:80 -v /root/nginx/config:/etc/nginx/conf.d nginx
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此时,gogs 容器和 my_nginx 容器建立互联关系</p>
<p><code>--link</code> 参数的格式为 <code>--link name:alias</code> ,其中 name 是要连接的容器名称, alias 是这个连接的别名  .</p>
<p>可以通过 <code>docker inspect</code> 命令查看 my_nginx 容器信息,就会发现有这么一段信息</p>
<pre class="line-numbers language-shell"><code class="language-shell">"Links": [
                "/gogs:/trusting_brown/app",
                "/own-cloud:/trusting_brown/app2"
            ],
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>表面此容器已经连上两个容器, gogs 和 own-cloud,trusting_brown 是系统分配给 Nginx 的名称,连接名称分别是 app 和 app2  .</p>
<p>Docker 在两个互联的容器之间创建了一个安全的隧道,而且不用映射到它们的端口到主机上 .在启动被连接的容器的时候不用添加 -p 或 -P 参数,从而避免暴露端口到外部网络上 .</p>
<p>连接之后,在 Nginx 容器里,就会发生两个变化  .</p>
<p>一是环境变量 .在 Nginx 容器中会出现6个新增的环境变量,这些环境变量的名称分贝时由被连接的服务别名、端口等拼接而成的 .</p>
<p><em>由于起得 gogs 容器有两个端口,所以其中 APP_PORT、APP_NAME、APP_ENV_GOGS_CUSTOM 是公用的,其它8个变量每四个的分别对应22, 3000 端口</em></p>
<pre class="line-numbers language-shell"><code class="language-shell"># env | grep APP
APP_PORT_3000_TCP=tcp://172.17.0.2:3000
APP_PORT_22_TCP_PROTO=tcp
APP_ENV_GOGS_CUSTOM=/data/gogs
APP_PORT_3000_TCP_ADDR=172.17.0.2
APP_PORT_3000_TCP_PROTO=tcp
APP_PORT_22_TCP_PORT=22
APP_PORT_3000_TCP_PORT=3000
APP_PORT=tcp://172.17.0.2:22
APP_NAME=/my_nginx/app
APP_PORT_22_TCP=tcp://172.17.0.2:22
APP_PORT_22_TCP_ADDR=172.17.0.2
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>二是 hosts 文件 .在 Nginx 容器的 hosts 文件看到下面的记录 .这就是说,一切访问 连接别名（app）、容器 ID（ac4c0cf35adf）和容器名（gogs）的请求都会被重新导向到实时实际的 app 的 ip 地址上 .</p>
<pre class="line-numbers language-shell"><code class="language-shell"># cat /etc/hosts | grep app
172.17.0.2    app ac4c0cf35adf gogs
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="高级网络配置"><a href="#高级网络配置" class="headerlink" title="高级网络配置"></a>高级网络配置</h2><p>当 Docker 启动时,会自动的主机上创建一个 <code>docker0</code> 虚拟网桥,实际上是 Linux 的一个 bridge,可以理解为一个软件交换机 .它会挂载到它的网口之间进行转发 .</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ ip addr | grep docker0
docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP
    link/ether 02:42:23:c6:3f:1c brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:23ff:fec6:3f1c/64 scope link
       valid_lft forever preferred_lft forever
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同时,Docker 随机分一个本地未占用的私有网段（在 <a href="https://tools.ietf.org/html/rfc1918" target="_blank" rel="external">RFC1919</a> 中定义）中的一个地址给 <code>docker0</code> 接口 .比如我的主机上的 docker0 ip 为 <code>172.17.0.1</code> ,掩码为 <code>255.255.0.0</code>  .此后启动的容器内的网口也会自动分配有个一个同一网段（<code>172.17.0.0/16</code>）的地址 .</p>
<p>当创建一个 Docker 容器的时候,同时会创建一对 <code>vath pair</code> 接口（当数据包发送到一个接口,另一个接口也可以收到相同的数据包） .这对接口一段在容器内,即 <code>eth0</code> ；另一端在本地并挂载到 docker0 网桥,名称以 <code>veth</code> 开头  .通过这种方式,主机可以跟容器通信,容器之间也可以相互通信 . Docker 就创建了在主机和所有容器之间一个虚拟共享网络 .</p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/network.png" alt="Docker 网络"></p>
<p>​                                            图 i.i docker 网络</p>
<p>接下来部分将介绍在一些场景中,Docker 所有的网络定制配置 .以及通过 Linux 命令来调整、补充、甚至替换 Docker 默认的网络配置 .</p>
<h3 id="快速配置"><a href="#快速配置" class="headerlink" title="快速配置"></a>快速配置</h3><p>下面是一个跟 Docker 网络相关的命令列表 .</p>
<p>其中有些命令选项只有在 Docker 服务启动的时候才能配置,而且不能马上生效 .</p>
<ul>
<li><code>-b BRIDGE or --bridge==BRIDGE</code> –指定容器挂载的网桥</li>
<li><code>--bip=CIDR</code> — 定制 docker0 的掩码</li>
<li><code>-H SOCKET... or --host=SOCKET…</code> —Docker 服务端接受命令的通道</li>
<li><code>--icc=true|false</code> –是否支持容器之间进行通信</li>
<li><code>--ip-forward=true|false</code> —容器是否能访问外网（详细解析请看下文的容器通信）</li>
<li><code>--iptables=true|false</code> –是否允许 Docker 添加 iptables 规则</li>
<li><code>--mtu=BYTES</code> —容器网络中的 MTU</li>
</ul>
<p>下面的两个命令既可以在服务启动时指定,也可以 Docker 容器启动（docker run ）时候指定 .</p>
<p>在 Docker 服务启动的时候指定则会成为默认值,后面执行<code>docker run</code>时可以覆盖设置的默认值 .</p>
<ul>
<li><code>--dns=IP_ADDRESS…</code> —使用指定的 DNS 服务器</li>
<li><code>--dns-search=DOMAIN...</code> 指定 DNS 搜索域</li>
</ul>
<p>最后这些选项只有在 docker run 执行时使用,因为它是针对容器的特性内容 .</p>
<ul>
<li><code>-h HOSTNAME or --hostname=HOSTNAME</code> –配置容器主机名</li>
<li><code>--link=CONRATAINER_NAME:ALIAS</code> —添加到另一个容器的连接</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; docker 的基本操作和使用。。。&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yusank.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yusank.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>docker-portainer</title>
    <link href="http://yusank.github.io/portainer.html/"/>
    <id>http://yusank.github.io/portainer.html/</id>
    <published>2017-07-08T04:18:00.000Z</published>
    <updated>2017-07-08T05:27:01.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><p>安利一款很好用的工具</p>
<a id="more"></a>
<h1 id="管理-docker"><a href="#管理-docker" class="headerlink" title="管理 docker"></a>管理 docker</h1><h2 id="为什么管理"><a href="#为什么管理" class="headerlink" title="为什么管理"></a>为什么管理</h2><p>随着用的 docker 镜像种类增多，在一台机器上起得 docker 容器数量有时候会非常的多，管理起来也比较困难，而且有时候一些 docker 命令一时半会想不起来，更不用说命令行的枯燥性，所以有没有一直简单一点办法去管理 docker 镜像和容器呢？</p>
<p>今天主角该登场了！</p>
<p><code>Portainer</code></p>
<p>这也是一个 docker 镜像，是可视化管理 docker 镜像和容器的镜像。</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>说的比较绕，不说废话，先上图：</p>
<p><strong>Dashboard:</strong></p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/Screen%20Shot%202017-08-15%20at%202.33.19%20PM.png" alt="首页"></p>
<p>其前端是网页，容器启动以后，在浏览器输入主机名:端口号后，第一打开此页面需要设置管理员密码，设置完毕之后，登录进入后，会看到上面的页面。</p>
<p>左边是选择菜单，右半部是显示你主机的基本信息和 docker 的基本信息，有多少个镜像，运行着几个容器等。</p>
<p>下面，从上到下一个个点击左边的菜单。</p>
<p><strong>App Templates</strong></p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/Screen%20Shot%202017-08-15%20at%202.33.51%20PM.png" alt="镜像店"></p>
<p>可以搜索查看并能一键下载（pull）镜像</p>
<p><strong>Containers</strong></p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/Screen%20Shot%202017-08-15%20at%202.34.09%20PM.png" alt="容器"></p>
<p>显示所有的容器，并支持多个容器同时启动、停止、重启、删除，容器添加等操作。是所有的容器都可以点开查看更详细的信息。</p>
<p><strong>Images</strong></p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/Screen%20Shot%202017-08-15%20at%202.34.31%20PM.png" alt="镜像"></p>
<p>可以查看本机所有的镜像。支持批量删除镜像，根据名字下载镜像，选择镜像仓库。点击任意镜像，可以查看进行详细信息。</p>
<p><strong>Networks</strong></p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/Screen%20Shot%202017-08-15%20at%202.34.39%20PM.png" alt="网络"></p>
<p>查看 docker 内部网络情况。支持添加和删除网络连接。</p>
<p><strong>Volums</strong></p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/Screen%20Shot%202017-08-15%20at%202.34.43%20PM.png" alt="数据"></p>
<p>数据卷。支持查看所有的数据卷，批量删除，添加新数据卷，查看详细信息。</p>
<p><strong>Events</strong></p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/Screen%20Shot%202017-08-15%20at%202.34.58%20PM.png" alt="事件"></p>
<p>事件。这是类似于日志系统，记录容器和镜像的启动、停止删除等操作。</p>
<p><strong>Docker</strong></p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/Screen%20Shot%202017-08-15%20at%202.35.03%20PM.png" alt="docker"></p>
<p>查看 docker 有关的详细信息，类似于命令行上的 <code>docker info</code>命令的结果。</p>
<p><strong>EndPoint</strong></p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/Screen%20Shot%202017-08-15%20at%202.35.11%20PM.png" alt="节点"></p>
<p>查看管理的节点。可以添加多个节点，从而可以同时管理多个机器上的 docker。通过左上角的下拉框，选择要管理的 docker 节点即可。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先通过 docker 命令 pull 此镜像：</p>
<pre class="line-numbers language-sh"><code class="language-sh">docker pull portainer/portainer
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>下载完成之后，通过以下名可以启动容器了：</p>
<pre class="line-numbers language-shell"><code class="language-shell">docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><em>注：-v 选项只对 Linux 环境有效</em></p>
<p>现在你可以在浏览器输入 <code>localhost:9000</code> 就能访问 portainer 去管理你的 docker了。</p>
<p>关于如何远程管理 docker，请看官方文档，在这儿不做详述。</p>
<p>portaner github：<a href="https://github.com/portainer/portainer" target="_blank" rel="external">https://github.com/portainer/portainer</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安利一款很好用的工具&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yusank.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yusank.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>GO interface</title>
    <link href="http://yusank.github.io/Go_interface.html/"/>
    <id>http://yusank.github.io/Go_interface.html/</id>
    <published>2017-06-08T07:07:00.000Z</published>
    <updated>2017-06-08T07:07:01.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><h1 id="Go-interface"><a href="#Go-interface" class="headerlink" title="Go interface"></a>Go interface</h1><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p>在 Golang 中 interface 是一个很重要的概念和特性。</p>
<h3 id="什么是-interface？"><a href="#什么是-interface？" class="headerlink" title="什么是 interface？"></a>什么是 interface？</h3><blockquote>
<p>In <a href="https://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank" rel="external">object-oriented programming</a>, a <strong>protocol</strong> or <strong>interface</strong> is a common means for unrelated <a href="https://en.wikipedia.org/wiki/Object_(computer_science" target="_blank" rel="external">objects</a>) to communicate with each other. These are definitions of <a href="https://en.wikipedia.org/wiki/Method_(computer_science" target="_blank" rel="external">methods</a>) and values which the objects agree upon in order to co-operate. — wikipedia</p>
</blockquote>
<p>这是 wikipedia 关于 protocal 的定义，将 interface 类比如 protocal 是一种非常助于理解的方式。protocol，中文一般叫做协议，比如网络传输中的 TCP 协议。protocol 可以认为是一种双方为了交流而做出的约定，interface 可以类比如此。</p>
<p>在 Golang 中，interface 是一种抽象类型，相对于抽象类型的是具体类型（concrete type）：int，string。如下是 io 包里面的例子。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Writer is the interface that wraps the basic Write method.</span>
<span class="token comment" spellcheck="true">//</span>
<span class="token comment" spellcheck="true">// Write writes len(p) bytes from p to the underlying data stream.</span>
<span class="token comment" spellcheck="true">// It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))</span>
<span class="token comment" spellcheck="true">// and any error encountered that caused the write to stop early.</span>
<span class="token comment" spellcheck="true">// Write must return a non-nil error if it returns n &lt; len(p).</span>
<span class="token comment" spellcheck="true">// Write must not modify the slice data, even temporarily.</span>
<span class="token comment" spellcheck="true">//</span>
<span class="token comment" spellcheck="true">// Implementations must not retain p.</span>
<span class="token keyword">type</span> Writer <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Write</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Closer is the interface that wraps the basic Close method.</span>
<span class="token comment" spellcheck="true">//</span>
<span class="token comment" spellcheck="true">// The behavior of Close after the first call is undefined.</span>
<span class="token comment" spellcheck="true">// Specific implementations may document their own behavior.</span>
<span class="token keyword">type</span> Closer <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 Golang 中，interface 是一组 method 的集合，是 <a href="https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B" target="_blank" rel="external">duck-type programming</a> (鸭子类型)的一种体现。不关心属性（数据），只关心行为（方法）。具体使用中你可以自定义自己的 struct，并提供特定的 interface 里面的 method 就可以把它当成 interface 来使用。下面是一种 interface 的典型用法，定义函数的时候参数定义成 interface，调用函数的时候就可以做到非常的灵活。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> MyInterface <span class="token keyword">interface</span><span class="token punctuation">{</span>
    <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">TestFunc</span><span class="token punctuation">(</span>x MyInterface<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">type</span> MyStruct <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>me MyStruct<span class="token punctuation">)</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> me MyStruct
    <span class="token function">TestFunc</span><span class="token punctuation">(</span>me<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="为什么-interface"><a href="#为什么-interface" class="headerlink" title="为什么 interface"></a>为什么 interface</h3><p>Gopher China 上给出了下面的三个理由：</p>
<ul>
<li>writing generic algorithm （泛型编程）</li>
<li>hiding implementation detail （隐藏具体实现）</li>
<li>providing interception points （提供监听点/拦截点？）</li>
</ul>
<h4 id="write-generic-algorithm"><a href="#write-generic-algorithm" class="headerlink" title="write generic algorithm"></a>write generic algorithm</h4><p>严格来说，在 Golang 中并不支持泛型编程。在 C++ 等高级语言中使用泛型编程非常的简单，所以泛型编程一直是 Golang 诟病最多的地方。但是使用 interface 我们可以实现泛型编程，我这里简单说一下，具体可以参考我前面给出来的那篇文章。比如我们现在要写一个泛型算法，形参定义采用 interface 就可以了，以标准库的 sort 为例。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> sort

<span class="token comment" spellcheck="true">// A type, typically a collection, that satisfies sort.Interface can be</span>
<span class="token comment" spellcheck="true">// sorted by the routines in this package.  The methods require that the</span>
<span class="token comment" spellcheck="true">// elements of the collection be enumerated by an integer index.</span>
<span class="token keyword">type</span> Interface <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Len is the number of elements in the collection.</span>
    <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
    <span class="token comment" spellcheck="true">// Less reports whether the element with</span>
    <span class="token comment" spellcheck="true">// index i should sort before the element with index j.</span>
    <span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>
    <span class="token comment" spellcheck="true">// Swap swaps the elements with indexes i and j.</span>
    <span class="token function">Swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token operator">...</span>

<span class="token comment" spellcheck="true">// Sort sorts data.</span>
<span class="token comment" spellcheck="true">// It makes one call to data.Len to determine n, and O(n*log(n)) calls to</span>
<span class="token comment" spellcheck="true">// data.Less and data.Swap. The sort is not guaranteed to be stable.</span>
<span class="token keyword">func</span> <span class="token function">Sort</span><span class="token punctuation">(</span>data Interface<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.</span>
    n <span class="token operator">:=</span> data<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    maxDepth <span class="token operator">:=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> n<span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">>>=</span> <span class="token number">1</span> <span class="token punctuation">{</span>
        maxDepth<span class="token operator">++</span>
    <span class="token punctuation">}</span>
    maxDepth <span class="token operator">*=</span> <span class="token number">2</span>
    <span class="token function">quickSort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> maxDepth<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Sort 函数的形参是一个 interface，包含了三个方法：<code>Len()</code>，<code>Less(i,j int)</code>，<code>Swap(i, j int)</code>。使用的时候不管数组的元素类型是什么类型（int, float, string…），只要我们实现了这三个方法就可以使用 Sort 函数，这样就实现了“泛型编程”。有一点比较麻烦的是，我们需要将数组自定义一下。下面是一个例子。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Name <span class="token builtin">string</span>
    Age  <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p Person<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s: %d"</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> p<span class="token punctuation">.</span>Age<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// ByAge implements sort.Interface for []Person based on</span>
<span class="token comment" spellcheck="true">// the Age field.</span>
<span class="token keyword">type</span> ByAge <span class="token punctuation">[</span><span class="token punctuation">]</span>Person <span class="token comment" spellcheck="true">//自定义</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>a ByAge<span class="token punctuation">)</span> <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>           <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>a ByAge<span class="token punctuation">)</span> <span class="token function">Swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>a ByAge<span class="token punctuation">)</span> <span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Age <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>Age <span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    people <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>Person<span class="token punctuation">{</span>
        <span class="token punctuation">{</span><span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"Michael"</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"Jenny"</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>

    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>people<span class="token punctuation">)</span>
    sort<span class="token punctuation">.</span><span class="token function">Sort</span><span class="token punctuation">(</span><span class="token function">ByAge</span><span class="token punctuation">(</span>people<span class="token punctuation">)</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>people<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外 Gopher China 上还提到了一个比较有趣的东西和大家分享一下。在我们设计函数的时候，下面是一个比较好的准则。</p>
<blockquote>
<p>Be <strong>conservative</strong> in what you send, be <strong>liberal</strong> in what you accept. — Robustness Principle</p>
</blockquote>
<p>对应到 Golang 就是：</p>
<blockquote>
<p>Return <strong>concrete types</strong>, receive <strong>interfaces</strong> as parameter. — Robustness Principle applied to Go</p>
</blockquote>
<p>话说这么说，但是当我们翻阅 Golang 源码的时候，有些函数的返回值也是 interface。</p>
<h4 id="hiding-implement-detail"><a href="#hiding-implement-detail" class="headerlink" title="hiding implement detail"></a>hiding implement detail</h4><p>隐藏具体实现，这个很好理解。比如我设计一个函数给你返回一个 interface，那么你只能通过 interface 里面的方法来做一些操作，但是内部的具体实现是完全不知道的。Francesc 举了个 context 的例子。 context 最先由 google 提供，现在已经纳入了标准库，而且在原有 context 的基础上增加了：cancelCtx，timerCtx，valueCtx。语言的表达有时候略显苍白无力，看一下 context 包的代码吧。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">WithCancel</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>ctx Context<span class="token punctuation">,</span> cancel CancelFunc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    c <span class="token operator">:=</span> <span class="token function">newCancelCtx</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
    <span class="token function">propagateCancel</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>c<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> Canceled<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>表明上 WithCancel 函数返回的还是一个 Context interface，但是这个 interface 的具体实现是 cancelCtx struct。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// newCancelCtx returns an initialized cancelCtx.</span>
<span class="token keyword">func</span> <span class="token function">newCancelCtx</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">)</span> cancelCtx <span class="token punctuation">{</span>
    <span class="token keyword">return</span> cancelCtx<span class="token punctuation">{</span>
        Context<span class="token punctuation">:</span> parent<span class="token punctuation">,</span>
        done<span class="token punctuation">:</span>    <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// A cancelCtx can be canceled. When canceled, it also cancels any children</span>
<span class="token comment" spellcheck="true">// that implement canceler.</span>
<span class="token keyword">type</span> cancelCtx <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Context     <span class="token comment" spellcheck="true">//注意一下这个地方</span>

    done <span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// closed by the first cancel call.</span>
    mu       sync<span class="token punctuation">.</span>Mutex
    children <span class="token keyword">map</span><span class="token punctuation">[</span>canceler<span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// set to nil by the first cancel call</span>
    err      <span class="token builtin">error</span>                 <span class="token comment" spellcheck="true">// set to non-nil by the first cancel call</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>cancelCtx<span class="token punctuation">)</span> <span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> c<span class="token punctuation">.</span>done
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>cancelCtx<span class="token punctuation">)</span> <span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
    c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">defer</span> c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> c<span class="token punctuation">.</span>err
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>cancelCtx<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%v.WithCancel"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>Context<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>尽管内部实现上下面三个函数返回的具体 struct （都实现了 Context interface）不同，但是对于使用者来说是完全无感知的。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">WithCancel</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>ctx Context<span class="token punctuation">,</span> cancel CancelFunc<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//返回 cancelCtx</span>
<span class="token keyword">func</span> <span class="token function">WithDeadline</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> <span class="token punctuation">(</span>Context<span class="token punctuation">,</span> CancelFunc<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//返回 timerCtx</span>
<span class="token keyword">func</span> <span class="token function">WithValue</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> Context    <span class="token comment" spellcheck="true">//返回 valueCtx</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="providing-interception-points"><a href="#providing-interception-points" class="headerlink" title="providing interception points"></a>providing interception points</h4><p>这里的 interception 想表达的意思应该是 wrapper 或者装饰器，他给出了一个例子如下：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> header <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    rt  http<span class="token punctuation">.</span>RoundTripper
    v   <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>h header<span class="token punctuation">)</span> <span class="token function">RoundTrip</span><span class="token punctuation">(</span>r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token operator">*</span>http<span class="token punctuation">.</span>Response <span class="token punctuation">{</span>
    <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> h<span class="token punctuation">.</span>v <span class="token punctuation">{</span>
        r<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> h<span class="token punctuation">.</span>rt<span class="token punctuation">.</span><span class="token function">RoundTrip</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过 interface，我们可以通过类似这种方式实现动态分配 (dynamic dispatch)。</p>
<h3 id="非侵入式"><a href="#非侵入式" class="headerlink" title="非侵入式"></a>非侵入式</h3><p>什么是侵入式呢？比如 Java 的 interface 实现需要显示的声明。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyWriter</span> <span class="token keyword">implements</span> <span class="token class-name">io<span class="token punctuation">.</span>Writer</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样就意味着如果要实现多个 interface 需要显示地写很多遍，同时 package 的依赖还需要进行管理。Dependency is evil。比如我要实现 io 包里面的 Reader，Writer，ReadWriter 接口，代码可以像下面这样写。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> MyIO <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>io <span class="token operator">*</span>MyIO<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>io <span class="token operator">*</span>MyIO<span class="token punctuation">)</span> <span class="token function">Write</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// io package</span>
<span class="token keyword">type</span> Reader <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Writer <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Write</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> ReadWriter <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    Reader
    Writer
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种写法真的很方便，而且不用去显示的 import io package，interface 底层实现的时候会动态的检测。这样也会引入一些问题：</p>
<ol>
<li>性能下降。使用 interface 作为函数参数，runtime 的时候会动态的确定行为。而使用 struct 作为参数，编译期间就可以确定了。</li>
<li>不知道 struct 实现哪些 interface。这个问题可以使用 guru 工具来解决。</li>
</ol>
<p>综上，Golang interface 的这种非侵入实现真的很难说它是好，还是坏。但是可以肯定的一点是，对开发人员来说代码写起来更简单了。</p>
<h3 id="interface-type-assertion"><a href="#interface-type-assertion" class="headerlink" title="interface type assertion"></a>interface type assertion</h3><p>interface 像其他类型转换的时候一般我们称作断言，举个例子。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">do</span><span class="token punctuation">(</span>v <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    n <span class="token operator">:=</span> v<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// might panic</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这样写的坏处在于：一旦断言失败，程序将会 panic。一种避免 panic 的写法是使用 type assertion。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">do</span><span class="token punctuation">(</span>v <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    n<span class="token punctuation">,</span> ok <span class="token operator">:=</span> v<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 断言失败处理</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于 interface 的操作可以使用 reflect 包来处理，关于 reflect 包的原理和使用可以参考我的文章。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>interface 是 Golang 的一种重要的特性，但是这是以 runtime 为代价的，也就意味着性能的损失（关于 interface 的底层实现之后有时间再写）。抛开性能不谈，interface 对于如何设计我们的代码确实给了一个很好的思考。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://legendtkl.com/2015/11/25/go-generic-programming/" target="_blank" rel="external">Golang “泛型编程”</a></li>
<li><a href="http://legendtkl.com/2015/11/28/go-interface-reflect/" target="_blank" rel="external">谈一谈 Golang 的 interface 和 reflect</a></li>
<li><a href="https://www.youtube.com/watch?v=F4wUrj6pmSI&amp;t=2319s" target="_blank" rel="external">understanding golang interface(Gopher China) — youtube</a></li>
<li><a href="https://github.com/gopherchina/conference/blob/master/2017/1.4%20interface.presented.pdf" target="_blank" rel="external">understanding golang interface(Gopher China) — slide</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Go-interface&quot;&gt;&lt;a href=&quot;#Go-inter
    
    </summary>
    
      <category term="GO" scheme="http://yusank.github.io/categories/GO/"/>
    
    
      <category term="GO" scheme="http://yusank.github.io/tags/GO/"/>
    
  </entry>
  
  <entry>
    <title>Go Format</title>
    <link href="http://yusank.github.io/GO-format.html/"/>
    <id>http://yusank.github.io/GO-format.html/</id>
    <published>2017-06-04T09:59:00.000Z</published>
    <updated>2017-08-23T14:18:17.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><p>go 代码的一些规范和命名规则……<br><a id="more"></a></p>
<h1 id="Golang-代码规范"><a href="#Golang-代码规范" class="headerlink" title="Golang 代码规范"></a>Golang 代码规范</h1><h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><pre class="line-numbers language-sh"><code class="language-sh">PROJECT_NAME
├── README.md 介绍软件及文档入口
├── bin 编译好的二进制文件,执行./build.sh自动生成，该目录也用于程序打包
├── build.sh 自动编译的脚本
├── doc 该项目的文档
├── pack 打包后的程序放在此处
├── pack.sh 自动打包的脚本，生成类似xxxx.20170713_14:45:35.tar.gz的文件，放在pack文件下
└── src 该项目的源代码
    ├── main 项目主函数
    ├── model 项目代码
    ├── research 在实现该项目中探究的一些程序
    └── vendor 存放go的库
        ├── github.com/xxx 第三方库
        └── xxx.com/obc 公司内部的公共库
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>项目的目录结构尽量做到简明、层次明确。</p>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><h3 id="文件名命名规范"><a href="#文件名命名规范" class="headerlink" title="文件名命名规范"></a>文件名命名规范</h3><p>用小写，尽量见名思义，看见文件名就可以知道这个文件下的大概内容，对于源代码里的文件，文件名要很好的代表了一个模块实现的功能。</p>
<h3 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h3><p>包名用小写，使用短命名，尽量不要和标准库冲突。</p>
<h3 id="接口名"><a href="#接口名" class="headerlink" title="接口名"></a>接口名</h3><p>单个函数的接口以 <code>er</code> 作为后缀，如 Reader， Writer</p>
<p>接口的实现则去掉后缀</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Reader <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>两个函数的接口名综合两个函数名</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> WriteFlusher <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
    <span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>三个以上函数的接口名，类似于结构体名</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Car <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> 
    <span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
    <span class="token function">Recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>全局变量：采用驼峰命名法，仅限在包内的全局变量，包外引用需要写接口，提供调用；</p>
<p>局部变量：驼峰式，第一个单词的首字母小写，如有两个以上单词组成的变量名，第二个单词开始首字母大写。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>全局：驼峰命名，每个单词的首字母大写</p>
<p>局部：与变量的风格一样</p>
<h2 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h2><p>函数名采用驼峰命名法，不要使用下划线。</p>
<h2 id="import-规范"><a href="#import-规范" class="headerlink" title="import 规范"></a>import 规范</h2><p>import在多行的情况下，goimports 会自动帮你格式化，在一个文件里面引入了一个package，建议采用如下格式：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">{</span>
    <span class="token string">"net"</span>
    <span class="token string">"strings"</span>

    <span class="token string">"github.com/astaxie/beego"</span>
    <span class="token string">"gopkg.in/mgo.v2"</span>

    <span class="token string">"myproject/models"</span>
    <span class="token string">"myproject/utils"</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>项目中最好不要使用相对路径导入包：</p>
<p>// 这是不好的导入</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">import</span> “<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>net”
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>// 这是正确的做法</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">import</span> “xxxx<span class="token punctuation">.</span>com<span class="token operator">/</span>proj<span class="token operator">/</span>net”
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>error作为函数的值返回,必须尽快对error进行处理</p>
<p>采用独立的错误流进行处理</p>
<p>不要采用这种方式</p>
<pre class="line-numbers language-go"><code class="language-go">    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// error handling</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// normal code</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而采用以下方式</p>
<pre class="line-numbers language-go"><code class="language-go"> <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// error handling</span>
        <span class="token keyword">return</span> <span class="token comment" spellcheck="true">// or continue, etc.</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// normal code</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果返回值需要初始化，则采用以下方式</p>
<pre class="line-numbers language-go"><code class="language-go">x<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// error handling</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// use x</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><p>在逻辑处理中禁用panic</p>
<p>在 main 包中只有当实在不可运行的情况采用 panic，例如文件无法打开，数据库无法连接导致程序无法 正常运行，但是对于其他的 package 对外的接口不能有 panic，只能在包内采用。 建议在 main 包中使用 log.Fatal 来记录错误，这样就可以由 log 来结束程序。</p>
<h2 id="Recover"><a href="#Recover" class="headerlink" title="Recover"></a>Recover</h2><p>recover 用于捕获 runtime 的异常，禁止滥用 recover，在开发测试阶段尽量不要用 recover，recover 一般放在你认为会有不可预期的异常的地方。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">server</span><span class="token punctuation">(</span>workChan <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token operator">*</span>Work<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> work <span class="token operator">:=</span> <span class="token keyword">range</span> workChan <span class="token punctuation">{</span>
        <span class="token keyword">go</span> <span class="token function">safelyDo</span><span class="token punctuation">(</span>work<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">safelyDo</span><span class="token punctuation">(</span>work <span class="token operator">*</span>Work<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"work failed:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// do 函数可能会有不可预期的异常</span>
    <span class="token function">do</span><span class="token punctuation">(</span>work<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h2><p>defer 在函数 return 之前执行，对于一些资源的回收用 defer 是好的，但也禁止滥用 defer，defer 是需要消耗性能的,所以频繁调用的函数尽量不要使用 defer。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Contents returns the file's contents as a string.</span>
<span class="token keyword">func</span> <span class="token function">Contents</span><span class="token punctuation">(</span>filename <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err
    <span class="token punctuation">}</span>
    <span class="token keyword">defer</span> f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// f.Close will run when we're finished.</span>

    <span class="token keyword">var</span> result <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
    buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        n<span class="token punctuation">,</span> err <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        result <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// append is discussed later.</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>
                <span class="token keyword">break</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err  <span class="token comment" spellcheck="true">// f will be closed if we return here.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span> <span class="token comment" spellcheck="true">// f will be closed if we return here.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>if接受初始化语句，约定如下方式建立局部变量</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">if</span> err <span class="token operator">:=</span> file<span class="token punctuation">.</span><span class="token function">Chmod</span><span class="token punctuation">(</span><span class="token number">0664</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> err
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>采用短声明建立局部变量</p>
<pre class="line-numbers language-go"><code class="language-go">sum <span class="token operator">:=</span> <span class="token number">0</span>
<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
    sum <span class="token operator">+=</span> i
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>如果只需要第一项（key），就丢弃第二个：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">for</span> key <span class="token operator">:=</span> <span class="token keyword">range</span> m <span class="token punctuation">{</span>
    <span class="token keyword">if</span> key<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">delete</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果只需要第二项，则把第一项置为下划线</p>
<pre class="line-numbers language-go"><code class="language-go">sum <span class="token operator">:=</span> <span class="token number">0</span>
<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> array <span class="token punctuation">{</span>
    sum <span class="token operator">+=</span> value
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>尽早return：一旦有错误发生，马上返回</p>
<pre class="line-numbers language-go"><code class="language-go">f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> err
<span class="token punctuation">}</span>
d<span class="token punctuation">,</span> err <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">Stat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> err
<span class="token punctuation">}</span>
<span class="token function">codeUsing</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> d<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="方法接收器"><a href="#方法接收器" class="headerlink" title="方法接收器"></a>方法接收器</h2><p>名称一般采用 struct 的第一个字母且为小写， 而不是 this，me 或 self</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Transfer <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">func</span><span class="token punctuation">(</span>t <span class="token operator">*</span>Transfer<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果接收者是 map， slice 或者 chan，不要用指针传递</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">//Map</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> mp <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>m mp<span class="token punctuation">)</span> <span class="token function">Set</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    m<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> v
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>
    m<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"k"</span><span class="token punctuation">,</span> <span class="token string">"v"</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">//Channel</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> ch <span class="token keyword">chan</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c ch<span class="token punctuation">)</span> <span class="token function">Push</span><span class="token punctuation">(</span>i <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    c <span class="token operator">&lt;-</span> i
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c ch<span class="token punctuation">)</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;-</span>c
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    c<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token string">"i"</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果需要对 slice 进行修改，通过返回值的方式重新复制</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">//Slice</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> slice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    s <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span>slice<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">addOne</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>s slice<span class="token punctuation">)</span> <span class="token function">addOne</span><span class="token punctuation">(</span>b <span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果接收者是含有 sync.Mutex 或者类似同步字段的结构体，必须使用指针传递避免复制</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"sync"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> T <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    m sync<span class="token punctuation">.</span>Mutex
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>T<span class="token punctuation">)</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    t<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/*
Wrong !!!
func (t T) lock() {
    t.m.Lock()
}
*/</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    t <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span>
    t<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果接收者是大的结构体或者数组，使用指针传递会更有效率。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> T <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    data <span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>T<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">byte</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    t <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="一键代码规范"><a href="#一键代码规范" class="headerlink" title="一键代码规范"></a>一键代码规范</h2><p>使用 JetBrain 系列 IDE 的同学，可以按快捷键或者鼠标右键来一键使用 go 提供的 <code>format</code> 命令;</p>
<p>快捷键：</p>
<p>cmd + option + shift + f 对当前文件进行 format</p>
<p>cmd + option + shift + p 对当前项目所有 go 文件进行 format</p>
<p>鼠标右键：</p>
<p>在 IDE 内点击鼠标右键，选择 <code>Go Tools</code>,然后可以选择对单个文件或项目进行 format。</p>
<p>用 vscode 的同学，在设置里面加上以下语句即可以保存文件后自动进行 format</p>
<pre class="line-numbers language-json"><code class="language-json"><span class="token property">"go.formatOnSave"</span><span class="token operator">:</span> <span class="token boolean">true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码风格和代码规范是体现一个程序员的基本素质的一项指标，也是对自己的代码和他人的一个最基本的尊重。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go 代码的一些规范和命名规则……&lt;br&gt;
    
    </summary>
    
      <category term="GO" scheme="http://yusank.github.io/categories/GO/"/>
    
    
      <category term="GO" scheme="http://yusank.github.io/tags/GO/"/>
    
      <category term="代码规范" scheme="http://yusank.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>GO test</title>
    <link href="http://yusank.github.io/go-test.html/"/>
    <id>http://yusank.github.io/go-test.html/</id>
    <published>2017-06-01T07:07:00.000Z</published>
    <updated>2017-06-01T07:07:01.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><h1 id="Go-测试用例"><a href="#Go-测试用例" class="headerlink" title="Go 测试用例"></a>Go 测试用例</h1><p>开发程序其中很重要的一点是测试，我们如何保证代码的质量，如何保证每个函数是可运行，运行结果是正确的，又如何保证写出来的代码性能是好的，我们知道单元测试的重点在于发现程序设计或实现的逻辑错误，使问题及早暴露，便于问题的定位解决，而性能测试的重点在于发现程序设计上的一些问题，让线上的程序能够在高并发的情况下还能保持稳定。本小节将带着这一连串的问题来讲解Go语言中如何来实现单元测试和性能测试。</p>
<p>Go语言中自带有一个轻量级的测试框架<code>testing</code>和自带的<code>go test</code>命令来实现单元测试和性能测试，<code>testing</code>框架和其他语言中的测试框架类似，你可以基于这个框架写针对相应函数的测试用例，也可以基于该框架写相应的压力测试用例，那么接下来让我们一一来看一下怎么写。</p>
<p>另外建议安装<a href="https://github.com/cweill/gotests" target="_blank" rel="external">gotests</a>插件自动生成测试代码:</p>
<pre class="line-numbers language-shell"><code class="language-shell">go get -u -v github.com/cweill/gotests/...
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="如何编写测试用例"><a href="#如何编写测试用例" class="headerlink" title="如何编写测试用例"></a>如何编写测试用例</h2><p>由于<code>go test</code>命令只能在一个相应的目录下执行所有文件，所以我们接下来新建一个项目目录<code>gotest</code>,这样我们所有的代码和测试代码都在这个目录下。</p>
<p>接下来我们在该目录下面创建两个文件：gotest.go和gotest_test.go</p>
<ol>
<li>gotest.go:这个文件里面我们是创建了一个包，里面有一个函数实现了除法运算:</li>
</ol>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> gotest

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"errors"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">Division</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">float64</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">float64</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> b <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"除数不能为0"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>gotest_test.go:这是我们的单元测试文件，但是记住下面的这些原则：</li>
</ol>
<ul>
<li>文件名必须是<code>_test.go</code>结尾的，这样在执行<code>go test</code>的时候才会执行到相应的代码</li>
<li>你必须import <code>testing</code>这个包</li>
<li>所有的测试用例函数必须是<code>Test</code>开头</li>
<li>测试用例会按照源代码中写的顺序依次执行</li>
<li>测试函数<code>TestXxx()</code>的参数是<code>testing.T</code>，我们可以使用该类型来记录错误或者是测试状态</li>
<li>测试格式：<code>func TestXxx (t *testing.T)</code>,<code>Xxx</code>部分可以为任意的字母数字的组合，但是首字母不能是小写字母[a-z]，例如<code>Testintdiv</code>是错误的函数名。</li>
<li><p>函数中通过调用<code>testing.T</code>的<code>Error</code>, <code>Errorf</code>, <code>FailNow</code>, <code>Fatal</code>, <code>FatalIf</code>方法，说明测试不通过，调用<code>Log</code>方法用来记录测试的信息。</p>
<p>下面是我们的测试用例的代码：</p>
</li>
</ul>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> gotest

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"testing"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">Test_Division_1</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> i<span class="token punctuation">,</span> e <span class="token operator">:=</span> <span class="token function">Division</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token number">3</span> <span class="token operator">||</span> e <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//try a unit test on function</span>
        t<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">"除法函数测试没通过"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 如果不是如预期的那么就报错</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        t<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"第一个测试通过了"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//记录一些你期望记录的信息</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">Test_Division_2</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    t<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">"就是不通过"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们在项目目录下面执行<code>go test</code>,就会显示如下信息：</p>
<pre class="line-numbers language-shell"><code class="language-shell">--- FAIL: Test_Division_2 (0.00 seconds)
    gotest_test.go:16: 就是不通过
    FAIL
    exit status 1
    FAIL    gotest    0.013s
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从这个结果显示测试没有通过，因为在第二个测试函数中我们写死了测试不通过的代码<code>t.Error</code>，那么我们的第一个函数执行的情况怎么样呢？默认情况下执行<code>go test</code>是不会显示测试通过的信息的，我们需要带上参数<code>go test -v</code>，这样就会显示如下信息：</p>
<pre class="line-numbers language-shell"><code class="language-shell">=== RUN Test_Division_1
--- PASS: Test_Division_1 (0.00 seconds)
    gotest_test.go:11: 第一个测试通过了
=== RUN Test_Division_2
--- FAIL: Test_Division_2 (0.00 seconds)
    gotest_test.go:16: 就是不通过
FAIL
exit status 1
FAIL    gotest    0.012s
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的输出详细的展示了这个测试的过程，我们看到测试函数1<code>Test_Division_1</code>测试通过，而测试函数2<code>Test_Division_2</code>测试失败了，最后得出结论测试不通过。接下来我们把测试函数2修改成如下代码：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Test_Division_2</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> e <span class="token operator">:=</span> <span class="token function">Division</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> e <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//try a unit test on function</span>
        t<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">"Division did not work as expected."</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 如果不是如预期的那么就报错</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        t<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"one test passed."</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//记录一些你期望记录的信息</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后我们执行<code>go test -v</code>，就显示如下信息，测试通过了：</p>
<pre><code>=== RUN Test_Division_1
--- PASS: Test_Division_1 (0.00 seconds)
    gotest_test.go:11: 第一个测试通过了
=== RUN Test_Division_2
--- PASS: Test_Division_2 (0.00 seconds)
    gotest_test.go:20: one test passed. 除数不能为0
PASS
ok  gotest    0.013s
</code></pre><h2 id="如何编写压力测试"><a href="#如何编写压力测试" class="headerlink" title="如何编写压力测试"></a>如何编写压力测试</h2><p>压力测试用来检测函数(方法）的性能，和编写单元功能测试的方法类似,此处不再赘述，但需要注意以下几点：</p>
<ul>
<li>压力测试用例必须遵循如下格式，其中XXX可以是任意字母数字的组合，但是首字母不能是小写字母</li>
</ul>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">BenchmarkXXX</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>go test</code>不会默认执行压力测试的函数，如果要执行压力测试需要带上参数<code>-test.bench</code>，语法:<code>-test.bench=&quot;test_name_regex&quot;</code>,例如<code>go test -test.bench=&quot;.*&quot;</code>表示测试全部的压力测试函数</li>
<li>在压力测试用例中,请记得在循环体内使用<code>testing.B.N</code>,以使测试可以正常的运行</li>
<li>文件名也必须以<code>_test.go</code>结尾</li>
</ul>
<p>下面我们新建一个压力测试文件webbench_test.go，代码如下所示：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> gotest

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"testing"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">Benchmark_Division</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//use b.N for looping </span>
        <span class="token function">Division</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">Benchmark_TimeConsumingFunction</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    b<span class="token punctuation">.</span><span class="token function">StopTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//调用该函数停止压力测试的时间计数</span>

    <span class="token comment" spellcheck="true">//做一些初始化的工作,例如读取文件数据,数据库连接之类的,</span>
    <span class="token comment" spellcheck="true">//这样这些时间不影响我们测试函数本身的性能</span>

    b<span class="token punctuation">.</span><span class="token function">StartTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//重新开始时间</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        <span class="token function">Division</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们执行命令<code>go test -file webbench_test.go -test.bench=&quot;.*&quot;</code>，可以看到如下结果：</p>
<pre><code>PASS
Benchmark_Division    500000000             7.76 ns/op
Benchmark_TimeConsumingFunction    500000000             7.80 ns/op
ok      gotest    9.364s
</code></pre><p>上面的结果显示我们没有执行任何<code>TestXXX</code>的单元测试函数，显示的结果只执行了压力测试函数，第一条显示了<code>Benchmark_Division</code>执行了500000000次，每次的执行平均时间是7.76纳秒，第二条显示了<code>Benchmark_TimeConsumingFunction</code>执行了500000000，每次的平均执行时间是7.80纳秒。最后一条显示总共的执行时间。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过上面对单元测试和压力测试的学习，我们可以看到<code>testing</code>包很轻量，编写单元测试和压力测试用例非常简单，配合内置的<code>go test</code>命令就可以非常方便的进行测试，这样在我们每次修改完代码,执行一下go test就可以简单的完成回归测试了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Go-测试用例&quot;&gt;&lt;a href=&quot;#Go-测试用例&quot; clas
    
    </summary>
    
      <category term="GO" scheme="http://yusank.github.io/categories/GO/"/>
    
    
      <category term="GO" scheme="http://yusank.github.io/tags/GO/"/>
    
  </entry>
  
  <entry>
    <title>Go File</title>
    <link href="http://yusank.github.io/go_file.html/"/>
    <id>http://yusank.github.io/go_file.html/</id>
    <published>2017-05-22T04:20:00.000Z</published>
    <updated>2017-09-01T09:11:25.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><p>go 的文件操作和校验<br><a id="more"></a></p>
<h1 id="GO-文件操作"><a href="#GO-文件操作" class="headerlink" title="GO 文件操作"></a>GO 文件操作</h1><p>在任何计算机设备中，文件是都是必须的对象，而在Web编程中,文件的操作一直是Web程序员经常遇到的问题,文件操作在Web应用中是必须的,非常有用的,我们经常遇到生成文件目录,文件(夹)编辑等操作,现在我们来看看 go 对文件是怎么操作的。</p>
<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><p>文件操作的大多数函数都是在os包里面，下面列举了几个目录操作的：</p>
<ul>
<li><code>func Mkdir(name string, perm FileMode) error</code></li>
</ul>
<p>创建名称为name的目录，权限设置是perm，例如0777</p>
<ul>
<li><code>func MkdirAll(path string, perm FileMode) error</code></li>
</ul>
<p>根据path创建多级子目录，例如 test/test1/test2。</p>
<ul>
<li><code>func Remove(name string) error</code></li>
</ul>
<p>删除名称为name的目录，当目录下有文件或者其他目录时会出错</p>
<ul>
<li><code>func RemoveAll(path string) error</code></li>
</ul>
<p>根据path删除多级子目录，如果path是单个名称，那么该目录下的子目录全部删除。</p>
<p>以下是简单的使用：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"os"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    os<span class="token punctuation">.</span><span class="token function">Mkdir</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token number">0777</span><span class="token punctuation">)</span>
    os<span class="token punctuation">.</span><span class="token function">MkdirAll</span><span class="token punctuation">(</span><span class="token string">"test/test1/test2"</span><span class="token punctuation">,</span> <span class="token number">0777</span><span class="token punctuation">)</span>
    err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"crash with error %v \n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    os<span class="token punctuation">.</span><span class="token function">RemoveAll</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="建立与打开文件"><a href="#建立与打开文件" class="headerlink" title="建立与打开文件"></a>建立与打开文件</h3><p>新建文件可以通过如下两个方法</p>
<ul>
<li><code>func Create(name string) (file *File, err Error)</code></li>
</ul>
<p>根据提供的文件名创建新的文件，返回一个文件对象，默认权限是0666的文件，返回的文件对象是可读写的。</p>
<ul>
<li><code>func NewFile(fd uintptr, name string) *File</code></li>
</ul>
<p>根据文件描述符创建相应的文件，返回一个文件对象</p>
<p>通过如下两个方法来打开文件：</p>
<ul>
<li><code>func Open(name string) (file *File, err Error)</code></li>
</ul>
<p>该方法打开一个名称为name的文件，但是是只读方式，内部实现其实调用了OpenFile。</p>
<ul>
<li><code>func OpenFile(name string, flag int, perm uint32) (file *File, err Error)</code></li>
</ul>
<p>打开名称为name的文件，flag是打开的方式，只读、读写等，perm是权限</p>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>写文件函数：</p>
<ul>
<li><code>func (file *File) Write(b []byte) (n int, err Error)</code></li>
</ul>
<p>写入byte类型的信息到文件</p>
<ul>
<li><code>func (file *File) WriteAt(b []byte, off int64) (n int, err Error)</code></li>
</ul>
<p>在指定位置开始写入byte类型的信息</p>
<ul>
<li><code>func (file *File) WriteString(s string) (ret int, err Error)</code></li>
</ul>
<p>写入string信息到文件</p>
<p>写文件的示例代码</p>
<pre class="line-numbers language-go"><code class="language-go">
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"os"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    userFile <span class="token operator">:=</span> <span class="token string">"yusank.txt"</span>
    fout<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>userFile<span class="token punctuation">)</span>        
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>userFile<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">defer</span> fout<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        fout<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span><span class="token string">"Just a test!\r\n"</span><span class="token punctuation">)</span>
        fout<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"Just a test!\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>读文件函数：</p>
<ul>
<li><code>func (file *File) Read(b []byte) (n int, err Error)</code></li>
</ul>
<p>读取数据到b中</p>
<ul>
<li><code>func (file *File) ReadAt(b []byte, off int64) (n int, err Error)</code></li>
</ul>
<p>从 off 开始读取数据到 b 中</p>
<p>读文件的示例代码:</p>
<pre class="line-numbers language-go"><code class="language-go">
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"os"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    userFile <span class="token operator">:=</span> <span class="token string">"yusank.txt"</span>
    fl<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>userFile<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>userFile<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">defer</span> fl<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        n<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> fl<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">==</span> n <span class="token punctuation">{</span>
            <span class="token keyword">break</span>
        <span class="token punctuation">}</span>
        os<span class="token punctuation">.</span>Stdout<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>Go语言里面删除文件和删除文件夹是同一个函数</p>
<ul>
<li><code>func Remove(name string) Error</code></li>
</ul>
<p>调用该函数就可以删除文件名为name的文件</p>
<h3 id="计算文件哈希值"><a href="#计算文件哈希值" class="headerlink" title="计算文件哈希值"></a>计算文件哈希值</h3><p>在网络上传输文件完成后，往往都会有一步文件的校验。需要确认传过来的文件是否是损坏的。</p>
<h4 id="小文件"><a href="#小文件" class="headerlink" title="小文件"></a>小文件</h4><p>代码：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"crypto/md5"</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"io"</span>
    <span class="token string">"os"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    testFile <span class="token operator">:=</span> <span class="token string">"/path/to/file"</span>
    file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>testFile<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 以上是为了获的 os.File 对象</span>

    md5h <span class="token operator">:=</span> md5<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    io<span class="token punctuation">.</span><span class="token function">Copy</span><span class="token punctuation">(</span>md5h<span class="token punctuation">,</span> file<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%x"</span><span class="token punctuation">,</span> md5h<span class="token punctuation">.</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 打印出来的是 MD5 算法下的哈希结果</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="大文件"><a href="#大文件" class="headerlink" title="大文件"></a>大文件</h4><p>代码：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"crypto/md5"</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"io"</span>
    <span class="token string">"math"</span>
    <span class="token string">"os"</span>
<span class="token punctuation">)</span>

<span class="token keyword">const</span> filechunk <span class="token operator">=</span> <span class="token number">8192</span> <span class="token comment" spellcheck="true">// 假定 8KB 以上为大文件</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"utf8.txt"</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">// 计算大小</span>
    info<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> file<span class="token punctuation">.</span><span class="token function">Stat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    filesize <span class="token operator">:=</span> info<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    blocks <span class="token operator">:=</span> <span class="token function">uint64</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Ceil</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>filesize<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">float64</span><span class="token punctuation">(</span>filechunk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    hash <span class="token operator">:=</span> md5<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">uint64</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> blocks<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        blocksize <span class="token operator">:=</span> <span class="token function">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Min</span><span class="token punctuation">(</span>filechunk<span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>filesize<span class="token operator">-</span><span class="token function">int64</span><span class="token punctuation">(</span>i<span class="token operator">*</span>filechunk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> blocksize<span class="token punctuation">)</span>

        file<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
        io<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// append into the hash</span>
    <span class="token punctuation">}</span>

    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s checksum is %x\n"</span><span class="token punctuation">,</span> file<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hash<span class="token punctuation">.</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码内容是打开本地文件分块读取进行哈希计算，在网络传输中，可以每次传入一包的文件，先用 io.WriteString() 方法添加到哈希并在最后进行 hash.Sum() 操作</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go 的文件操作和校验&lt;br&gt;
    
    </summary>
    
      <category term="GO" scheme="http://yusank.github.io/categories/GO/"/>
    
    
      <category term="GO" scheme="http://yusank.github.io/tags/GO/"/>
    
  </entry>
  
  <entry>
    <title>Unix 网络编程</title>
    <link href="http://yusank.github.io/Unix-Network.html/"/>
    <id>http://yusank.github.io/Unix-Network.html/</id>
    <published>2017-04-22T08:52:00.000Z</published>
    <updated>2017-04-22T08:52:01.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><h1 id="Unix-网络编程"><a href="#Unix-网络编程" class="headerlink" title="Unix 网络编程"></a>Unix 网络编程</h1><p>​                                                                        <strong>卷II - 进程间通信</strong></p>
<p>IPC是进程间通信（interprocess communication）的简称。传统上该术语描述的是运行在某个操作系统之上的不同进程间各种消息传递（<em>message passing</em>）的方式。</p>
<p>进程间的通信一般是一下四种形式：</p>
<ul>
<li>消息传递（管道、FIFO和消息队列）；</li>
<li>同步（互斥量、条件变量、读写锁、文件和记录锁、信号量）；</li>
<li>共享内存（匿名的和具名的）；</li>
<li>远程过程调用（Solaris 门和 Sun RPC）。</li>
</ul>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p><strong>消息传递：</strong></p>
<ul>
<li>管道和FIFO；</li>
<li>Posix 消息队列；</li>
<li>System V消息队列。</li>
</ul>
<h2 id="管道和FIFO"><a href="#管道和FIFO" class="headerlink" title="管道和FIFO"></a>管道和FIFO</h2><p>管道是最初的Unix IPC 形式。由于管道没有名字，所以它只能用于有亲缘关系的进程间的通信。</p>
<p><strong>实现机制：</strong></p>
<p>管道是由内核管理的一个缓冲区，相当于我们放入内存中的一个纸条。管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它<strong>被设计成为环形的数据结构</strong>，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>

<span class="token keyword">int</span> <span class="token function">pipe</span> <span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true">//返回：若成功返回0，若出错返回-1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>该函数返回两个文件描述符：fd[0] 和 fd[1]。前者打开来读，后者打开来写。</p>
<p>管道尽管是单个进程创建，但是管道的典型用途是为两个不同的进程（一个父进程，一个子进程）提供进程间的通信手段。</p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/Screen%20Shot%202017-02-22%20at%2011.49.01%20AM.png" alt="Screen Shot 2017-02-22 at 11.49.01 AM"></p>
<p>​                                             数据流 &gt;&gt;&gt;&gt;&gt;&gt;</p>
<p>首先是，由一个进程（它将成为父进程）创建一个 pipe 后调用 fork 派生一个自身的副本，接着关闭着个 pipe 的读成端，子进程关闭同一个 pipe 的写入端。这就是进程间提供了一个单向数据流，如下图。</p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/Screen%20Shot%202017-02-22%20at%2011.56.11%20AM.png" alt="Screen Shot 2017-02-22 at 11.56.11 AM"></p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    pid_t pid<span class="token punctuation">;</span>
    <span class="token keyword">char</span> line<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">// 先建立管道得到一对文件描述符</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 父进程把文件描述符复制给子进程</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 父进程写 </span>
        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 关闭读描述符</span>
        <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"\nhello world\n"</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span><span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">// 子进程读</span>
        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 关闭写端</span>
        n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> line<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">write</span><span class="token punctuation">(</span>STDOUT_FILENO<span class="token punctuation">,</span> line<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>technically，自从可以在进程间传递描述符后，管道也能用于无亲缘关系的进程间，而现实中管道通常用于具有共同祖先的进程间。</em></p>
<p><strong>FIFO：命名管道(named PIPE)</strong></p>
<p>管道尽管对很多操作来说是很有用的，但是它的根本局限性在于没有名字，从而只能由亲缘关系的进程（父子进程）使用。为了解决这一问题，Linux提供了FIFO方式连接进程。有了FIFO之后这一缺点得以改正。FIFO有时也称之为有名管道（named pipe）。FIFO除了有管道的功能外，它还允许无亲缘关系的进程的通信。pipe 和 FIFO 都是使用通常的 read 和 write 函数访问的。</p>
<p>FIFO (First in, First out)为一种特殊的文件类型，它在文件系统中有对应的路径。当一个进程以读(r)的方式打开该文件，而另一个进程以写(w)的方式打开该文件，那么内核就会在这两个进程之间建立管道，所以FIFO实际上也由内核管理，不与硬盘打交道。之所以叫FIFO，是因为管道本质上是一个先进先出的队列数据结构，最早放入的数据被最先读出来，从而保证信息交流的顺序。FIFO只是借用了文件系统(file system,命名管道是一种特殊类型的文件，因为Linux中所有事物都是文件，它在文件系统中以文件名的形式存在。)来为管道命名。写模式的进程向FIFO文件中写入，而读模式的进程从FIFO文件中读出。当删除FIFO文件时，管道连接也随之消失。<strong>FIFO的好处在于我们可以通过文件的路径来识别管道，从而让没有亲缘关系的进程之间建立连接</strong></p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span>

<span class="token keyword">int</span> <span class="token function">mkfifo</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回： 成功返回0，出错返回 -1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 <em>pathname</em> 是一个普通的 Unix 路径名，它是该 FIFO 的名字。</p>
<p>mkfifo 函数中参数 <em>mode</em> 指定 FIFO 的读写权限。</p>
<p>mkfifo 函数是要么创建一个新的 FIFO ，要么返回一个 EEXIST 错误（如果该 FIFO 已存在），如果不希望创建一个新的 FIFO 那就用 open 函数就可以。</p>
<p>FIFO 不能打开既写又读。</p>
<p>如果一个 FIFO 只读不写，只写不读都会形成阻塞。</p>
<p>下边是一个简单地例子：</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>  </span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span>  </span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span>  </span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span>  </span>

<span class="token macro property"># <span class="token directive keyword">define</span> FIFO1  "/tmp/my_fifo"</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">mkfifo</span><span class="token punctuation">(</span><span class="token string">"/tmp/my_fifo"</span><span class="token punctuation">,</span> <span class="token number">0777</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"FIFO created/n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
  <span class="token comment" spellcheck="true">// 打开FIFO</span>
  <span class="token comment" spellcheck="true">//writefd = Open(FIFO1, O_WRONLY | O_NONBLOCK, 0)    </span>
  <span class="token comment" spellcheck="true">//readfd = Open(FIFO1, O_RDONLY, 0)</span>
     <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>open</em> 第二个参数中的选项O_NONBLOCK，选项O_NONBLOCK表示非阻塞，加上这个选项后，表示open调用是非阻塞的，如果没有这个选项，则表示open调用是阻塞的。</p>
<ul>
<li>对于以只读方式（O_RDONLY）打开的FIFO文件，如果open调用是阻塞的（即第二个参数为O_RDONLY），除非有一个进程以写方式打开同一个FIFO，否则它不会返回；如果open调用是非阻塞的的（即第二个参数为O_RDONLY|O_NONBLOCK），则即使没有其他进程以写方式打开同一个FIFO文件，open调用将成功并立即返回。</li>
<li>对于以只写方式（O_WRONLY）打开的FIFO文件，如果open调用是阻塞的（即第二个参数为O_WRONLY），open调用将被阻塞，直到有一个进程以只读方式打开同一个FIFO文件为止；如果open调用是非阻塞的（即第二个参数为O_WRONLY|O_NONBLOCK），open总会立即返回，但如果没有其他进程以只读方式打开同一个FIFO文件，open调用将返回-1，并且FIFO也不会被打开。</li>
</ul>
<p>关于管道或 FIFO 的读写的若干规则：</p>
<ul>
<li>如果请求读出的数据量多于管道或 FIFO 中当前的可用数据量，那么只会返回这些可用的数据。</li>
<li>如果请求你写入的数据的字节数小于或等于 PIPE_BUF (可原子地写入往一个管道或 FIFO 的最大数据量， Posix 要求至少为512)，那么 write 操作保证是原子的。这意味着，如果两个进程差不多同时往同一个管道或 FIFO 写，那么不管是先写入来自第一个进程的所有数据再写第二个，还是顺序颠倒过来。系统都不会相互混杂来自两个进程的数据。然而如果数据的字节数大于 PIPE_BUF ，那么 write 操作不能保证是原子的。</li>
<li>不止以上这些。。。</li>
</ul>
<p><strong>小结</strong>： FIFO 与管道类似，但是它用 mkfifo 创建，之后需要open 打开。打开管道必须小心，因为许多规则（read 只写管道、write 只读管道、从空的管道或FIFO read 等的情况的返回结果。）制约着 open 的阻塞与否。</p>
<h2 id="Posix-IPC"><a href="#Posix-IPC" class="headerlink" title="Posix IPC"></a>Posix IPC</h2><p>Posix–可移植性操作系统接口（Protable operating system interface）</p>
<p>有关Unix标准化的大多数活动是由 Posix 和 Open Group 做的。</p>
<p>Posix 不是单一的标准，是一系列的标准。</p>
<p>以下三种类型的IPC合成为“Posix IPC”</p>
<ul>
<li>Posix 消息队列</li>
<li>Posix 信号量</li>
<li>Posix 共享内存区</li>
</ul>
<h2 id="Posix-消息队列"><a href="#Posix-消息队列" class="headerlink" title="Posix 消息队列"></a>Posix 消息队列</h2><p>消息队列可认为是个消息链表。有足够写权限的进程可往队列放置信息，有足够读权限的进程可从队列读取信息。每一个信息都是一条记录，它是由发送者赋予一个优先级。在某个进程往一个队列写入消息之前，并不需要另一个进程在该队列上等待消息的到达。这根管道和 FIFO 是相反的。</p>
<p>一个进程可以往某些队列写入一些信息，然后终止，再让另外一个进程在以后的某个时刻读取这些信息。</p>
<p>Posix 消息队列和下面讲的System V 消息队列有许多的相似性。以下是主要的差别：</p>
<ul>
<li>对 Posix 消息队列的读总是返回最高优先级的最早消息，对 System V 消息队列的读则可以返回任意指定优先级的消息；</li>
<li>当往一个空队列放置一个信息时，Posix 消息队列允许产生一个信号或启动一个线程，System V消息队列则是不提供类似的机制。</li>
</ul>
<p>队列中的每一个消息都有如下属性：</p>
<ul>
<li>一个无符号整数优先级（Posix）或 一个长整数类型（system V）；</li>
<li>消息的数据部分长度（可以为0）；</li>
<li>数据本身（如果长度大于0）。</li>
</ul>
<p>一个消息队列的可能布局。</p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/unix%20%E7%BD%91%E7%BB%9C.png" alt="unix 网络"></p>
<p>我们所设想的是一个链表，该链表的有中含有当前队列的两个属性：队列中允许的最大开销数以及每一个消息的最大大小。</p>
<p><strong>mq_open ,mq_close 和 mq_unlink 函数 </strong>：</p>
<p>mq_open 函数创建一个新的消息队列或打开一个已存在的消息队列。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;mqueue.h></span></span>
mqd_t <span class="token function">mq_open</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">int</span> oflag<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
              <span class="token comment" spellcheck="true">/* mode_t mode, struct mq_attr *attr  */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token comment" spellcheck="true">//返回： 成功返回消息对列描述符，出错返回-1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 <em>name</em> 有自己的一套命名规则，因为 Posix IPC 使用“Posix IPC 名字”进行标识。为方便于移植起见，Posix IPC 名字必须以斜杠符开头并且不能再包含任何斜杠符。</p>
<p><em>oflag</em> 是O_RDONLY、O_WRONLY 或     O_RDWR 之一， 可能按位或上O_CREATE(若不存在则创建)、O_EXCL(与O_CREATE一起，若已存在返回EEXIST 错误)或 O_NONBLOCK（非阻塞标识符）。</p>
<p>当实际操作创建一个新的消息队列时（指定O_CREATE标志，且请求的队列不存在），<em>mode</em> 和 <em>attr</em> 参数是需要的。mode上面介绍过。attr参数用于给新队列指定某些属性。</p>
<p>mq_open 返回值称为<strong>消息队列描述符（message queue descriptor）</strong>，这个值用作其他消息队列函数的第一参数。</p>
<p>已打开的消息队列是由 mq_close 关闭的。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mqueue.h></span></span>

<span class="token keyword">int</span> <span class="token function">mq_close</span><span class="token punctuation">(</span>mqd_t mqdes<span class="token punctuation">)</span>                       <span class="token comment" spellcheck="true">//返回： 成功返回0，出错返回-1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>关闭之后调用进程不再使用该描述符，但其消息队列并不从系统中删除。一个进程终止时，它打开着的消息队列都关闭，就像调用mq_close 一样。</p>
<p>要从系统中删除消息队列则用mq_unlink 函数，其第一参数为 mq_open 的第一参数 <em>name</em>。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;mqueue.h></span></span>

<span class="token keyword">int</span> <span class="token function">mq_unlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">//返回： 成功返回0，出错返回-1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>mq_getattr 和 mq_setattr 函数</strong></p>
<p>消息队列有四个属性，这两个函数是获取和修改这些属性。</p>
<pre class="line-numbers language-c"><code class="language-c">mq_flags        <span class="token comment" spellcheck="true">//队列阻塞标志位</span>
mq_maxmsg        <span class="token comment" spellcheck="true">//队列最大允许消息数</span>
mq_msgsize        <span class="token comment" spellcheck="true">//队列消息最大字节数</span>
mq_curmsgs        <span class="token comment" spellcheck="true">//队列当前消息条数</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mqueue.h></span></span>

<span class="token keyword">int</span> <span class="token function">mq_getattr</span><span class="token punctuation">(</span>mqd_t mqdes<span class="token punctuation">,</span><span class="token keyword">struct</span> mq_attr <span class="token operator">*</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">mq_setattr</span><span class="token punctuation">(</span>mqd_t mqdes<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">struct</span> mq_attr <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">struct</span> mq_attr <span class="token operator">*</span>oattr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//返回：均成功返回0，出错返回-1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>mq_send 和 mq_receive 函数</strong></p>
<p>​    这两个函数分别往一个队列放置一个信息和从一个队列取走一个消息。每一个消息都有优先级，它是一个小于MQ_PRIO_MAX 的无符号整数。Posix要求这个上限至少为32.</p>
<p>​    mq_receive 总是返回所指定队列中优先级最高的的最早消息，而且该优先级能随该消息的内容及其长度一同返回。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mqueue.h></span></span>

<span class="token keyword">int</span> <span class="token function">mq_send</span><span class="token punctuation">(</span>mqd_t mqdes<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prio<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//返回： 成功返回0，出错返回-1</span>
ssize_t <span class="token function">mq_reccevie</span><span class="token punctuation">(</span>mqd_t mqdes<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span>priop<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//返回： 成功返回消息中的字节数，出错返回-1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>mq_receive 的 <em>len</em> 参数的值不能小于能加到所指定队列中的最大大小（该队列 mq_attr 结构的 mq_msgsize ）。要是 <em>len</em> 小于该值， mq_receive立即返回 EMSGSIZE 错误。</p>
<p>mq_send 的 <em>prio</em> 参数是待发信息的优先级，其值必须小于 MQ_PRIO_MAX 。如果 mq_receive 的 <em>priop</em> 参数是一个非空指针，所返回消息的优先级就通过该指针存放。如果应用不必使用优先级不同的消息，那就给mq_send 指针值为0的优先级，给 mq_receive 指定一个空指针作为其最后一个参数。</p>
<p>往某个队列中增加一个消息</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mqueue.h></span></span>

<span class="token keyword">int</span>
<span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  mqd_t        mqd<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//描述符</span>
  <span class="token keyword">void</span>        <span class="token operator">*</span>ptr<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//指向缓冲区的指针</span>
  size_t    len<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//长度</span>
  uint_t    prio<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//优先度</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">4</span><span class="token punctuation">)</span>
    <span class="token function">err_quit</span><span class="token punctuation">(</span><span class="token string">"usage: mqsend &lt;name> &lt;#bytes> &lt;priority>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  len <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  prio <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  mqd <span class="token operator">=</span> <span class="token function">Mq_open</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> O_WRONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建一个消息队列</span>

  ptr <span class="token operator">=</span> <span class="token function">Calloc</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 所用的缓冲区用colloc分配，该函数会把该缓冲区初始化为0</span>
  <span class="token function">Mq_send</span><span class="token punctuation">(</span>mqd<span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> len<span class="token punctuation">,</span> prio<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>待发消息的大小和优先级必须作为命令行参数指定。</p>
<p>从某队列读出下一个信息</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"unpipc.h"</span></span>

<span class="token keyword">int</span>
<span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span>         c<span class="token punctuation">,</span>flags<span class="token punctuation">;</span>
  mqd_t        maq<span class="token punctuation">;</span>
  ssize_t    n<span class="token punctuation">;</span>
  uint_t    prio<span class="token punctuation">;</span>
  <span class="token keyword">void</span>        <span class="token operator">*</span>buff<span class="token punctuation">;</span>
  <span class="token keyword">struct</span>    mq_attr    attr<span class="token punctuation">;</span>

  flags <span class="token operator">=</span> O_RDONLY<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token function">Getopt</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">'n'</span><span class="token punctuation">:</span>
        flags <span class="token operator">|</span><span class="token operator">=</span> O_NONBLOCK<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>optind <span class="token operator">!=</span> argc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token function">err_quit</span><span class="token punctuation">(</span><span class="token string">"usage: mqreceive [-n] &lt;name>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  mqd <span class="token operator">=</span><span class="token function">Mq_open</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>optind<span class="token punctuation">]</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">Mq_getattr</span><span class="token punctuation">(</span>mqd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>

  buff <span class="token operator">=</span> <span class="token function">Malloc</span><span class="token punctuation">(</span>attr<span class="token punctuation">.</span>mq_msgsize<span class="token punctuation">)</span><span class="token punctuation">;</span>

  n <span class="token operator">=</span> <span class="token function">Mq_receive</span><span class="token punctuation">(</span>mqd<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> attr<span class="token punctuation">.</span>mq_msgsize<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prio<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read %ld bytes, priority = %u\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> n<span class="token punctuation">,</span> prio<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>命令行选项 -n 指定非阻塞属性，这样如果所指定的队列中没有消息， 则返回一个错误。</p>
<p>调用 mq_getattr 打开队列并取得属性。需要确定最大消息大小，因为必须为调用的 mq_receive 分配一个这样大小的缓冲区。最后输出所读出消息的大小及其属性。</p>
<pre class="line-numbers language-shell"><code class="language-shell">solaris %mqcreate /test1                            创建并获取属性
solaris %mqgetattr /test1
max

solaris % mqsend /test1 100 9999                    以无效的优先级发送
mq_send error: Invalid argument

solaris % mqsend /test1 100 6                        100字节，优先级6 
solaris % mqsend /test1 50 18                         50字节，优先级18
solaris % mqsend /test1 33 18                         33字节，优先级18

solaris % mqreceive /test1
read 50 bytes, priority = 18                        返回优先级最高的最早消息
solaris % mqreceive /test1
read 33 bytes, priority = 18
solaris % mqreceive /test1
read 100 bytes, priority = 6
solaris % mqreceive /test1                            指定非阻塞属性，队列为空
mq_recevie error: Resource temporarily unavalibale
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>消息队列限制：</p>
<ul>
<li>mq_mqxmsg            队列的最大消息数</li>
<li>mq_msgsize                  给定消息的最大字节数</li>
<li>MQ_OPEN_MAX            一个进程能够同时拥有的打开着消息队列的组大数目（Posix要求至少为8）</li>
<li>MQ_PRIO_MAX             任意消息的最大优先级值加1（Posix要求至少为32）</li>
</ul>
<p><strong>mq_notify 函数</strong></p>
<p>Posix 消息队列允许异步事件通知（ <em>asynchronous event notifiction</em>），以告知何时有一个消息放置到了某个空消息队列中。</p>
<h2 id="System-V-消息队列"><a href="#System-V-消息队列" class="headerlink" title="System V 消息队列"></a>System V 消息队列</h2><p>以下三种类型的IPC称为 System V IPC：</p>
<ul>
<li>System V 消息队列；</li>
<li>System V 信号量；</li>
<li>System V 共享内存区。</li>
</ul>
<p>这个称为作为这三个IPC机制的通称是因为它们源自 System V Unix 。这三种IPC最先出现在AT&amp;T System v UNIX上面，并遵循XSI标准，有时候也被称为XSI IPC。</p>
<p>System V 消息队列使用<em>消息队列标识符（message queue identifier）</em> 标识。有足够权限的任何进程可往队列放置信息，有足够权限的任何进程可从队列读取信息。跟 Posix 一样，在某个进程往一个队列写入消息之前，不求另外某个进程正在等待该队列上一个消息的到达。</p>
<p>对于系统的每个消息队列，内核维护一个定义在 <code>&lt;sys/msg.h&gt;</code>  头文件中的信息结构.</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> msqid_ds <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> ipc_perm     msg_perm   <span class="token comment" spellcheck="true">//operation permission structure</span>
    <span class="token keyword">struct</span> msg            <span class="token operator">*</span>msg_frist <span class="token comment" spellcheck="true">//ptr to frist message on queue</span>
    <span class="token keyword">struct</span> msg            <span class="token operator">*</span>msg_last  <span class="token comment" spellcheck="true">//ptr to last message on queue</span>
    msglen_t            msg_cbytes <span class="token comment" spellcheck="true">//current #bytes on queue</span>
    msgqnum_t           msg_qnum   <span class="token comment" spellcheck="true">//number of messages currently on queue</span>
    msglen_t            msg_qbytes <span class="token comment" spellcheck="true">//maximum number of bytes allowed on queue</span>
    pid_t               msg_lspid  <span class="token comment" spellcheck="true">//process ID of last msgsnd()</span>
    pid_t               msg_lrpid  <span class="token comment" spellcheck="true">//process ID of last msgrcv()</span>
    time_t              msg_stime  <span class="token comment" spellcheck="true">//time of last msgsnd()</span>
    time_t              msg_rtime  <span class="token comment" spellcheck="true">//time of last msgrcv()</span>
    time_t              msg_ctime  <span class="token comment" spellcheck="true">//time of last change</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>Unix 98 不要求有 msg_frist、msg_last 和 msg_cbytes 成员。然而普通的源自 <a href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/sysmsg.h.html" target="_blank" rel="external">System V</a> 的实现中可以找到这三个成员。就算提供了这两个指针，那么它们指向的是内核内存空间，对于应用来说基本没有作用的。</em></p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/unix%20%E7%BD%91%E7%BB%9C%20%281%29.png" alt="unix 网络 (1)"></p>
<p>我们可以将内核中某个特定的消息队列画为一个消息链表，如图。</p>
<p><strong>msgget 函数</strong></p>
<p>msgget 函数用于创建一个新的消息队列或访问一个已存在的消息队列。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h></span></span>
<span class="token keyword">int</span> <span class="token function">msgget</span> <span class="token punctuation">(</span>key_t key<span class="token punctuation">,</span> <span class="token keyword">int</span> oflag<span class="token punctuation">)</span>    
                                              <span class="token comment" spellcheck="true">//返回： 成功返回非负标识符，出错返回-1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>返回值是一个整数标识符，其他三个msg函数就用它来指代该队列。</p>
<p>oflag是读写权限的组合。（稍微复杂。。。）</p>
<p>当创建一个新的消息队列的时，msqid_ds 结构的如下成员被初始化。</p>
<ul>
<li><p>msg_perm 结构的 uid 和 cuid 成员被设置成当前进程的有效用户ID，gid 和 cgid 成员被设置成当前的进程的有效组ID。</p>
</li>
<li><p>oflag 中的读写权限位存放在msg_perm.mode 中。</p>
</li>
<li><p>msg_qnum、msg_lspid，msg_lrpid、msg_stime 和 msg_rtime 被设置为0.</p>
</li>
<li><p>msg_ctime 被设置为当前时间。</p>
</li>
<li><p>msg_qbytes 被设置成系统限制值。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> ipc_perm
<span class="token punctuation">{</span>
key_t                key<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/*调用shmget()时给出的关键字*/</span>
uid_t               uid<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/*共享内存所有者的有效用户ID */</span>
gid_t                  gid<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* 共享内存所有者所属组的有效组ID*/</span> 
uid_t                  cuid<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/* 共享内存创建 者的有效用户ID*/</span>
gid_t                 cgid<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/* 共享内存创建者所属组的有效组ID*/</span>
mode_t                   mode<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* Permissions + SHM_DEST和SHM_LOCKED标志*/</span>
ulong_t                seq<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/* 序列号*/</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​</p>
</li>
</ul>
<p><strong>msgsnd 函数</strong></p>
<p>使用 msgget 函数打开一个消息队列后，使用 msgsnd 函数往其上放置一个消息。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h></span></span>
<span class="token keyword">int</span> <span class="token function">msgsnd</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span>size_t length<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其中msqid 是由msgget 函数返回的标识符。ptr 是一个结构指针，该结构具有如下的模板：</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> msgbuf <span class="token punctuation">{</span>
     <span class="token keyword">long</span>     mtype<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// message type ,must be > 0</span>
     <span class="token keyword">char</span>    mtext<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">// message data</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>消息类型必须大于0，因为对于 msgrcv 函数来说，非正的消息类型用作特殊的指示器。</em></p>
<p><em>mtext虽然起名是 text ，但是消息类型并不局限于文本。任何形式的数据都是允许的。内核根本不解释消                      息数据的内容。ptr 所指向的是一个含有消息类型的长整数，消息本身则紧跟着它之后。</em></p>
<p>msgsnd 的 <em>length</em> 参数以字节为单位指定待发送消息的长度。是用户自定义的，可以是0.</p>
<p><em>flag</em> 参数既可以是0，也可以是IPC_NOWAIT 。IPC_NOWAIT 标志使得 msgsnd 调用非阻塞：如果没有存放新消息的可用空间，该函数马上返回。这个条件可能发生的情况包括：</p>
<ul>
<li>在指定的队列中已有太多的字节（对应 该队列的msqid_ds 结构中的msg_qbytes 值）；</li>
<li>在系统范围存在太多的消息。</li>
</ul>
<p>如果两个条件一个存在，而且IPC_NOWAIT标志已指定，msgsnd 就返回一个EAGAIN 错误。如果两个条件一个存在，标志未指定，那么调用线程就被投入睡眠，直到：</p>
<ul>
<li>具备存放新消息的空间；</li>
<li>由 msqgid 标识的消息队列从系统中删除（这个情况下回返回一个EIDRM 错误）；</li>
<li>调用线程被某个捕获的信息所中断。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Unix-网络编程&quot;&gt;&lt;a href=&quot;#Unix-网络编程&quot; 
    
    </summary>
    
      <category term="Unix" scheme="http://yusank.github.io/categories/Unix/"/>
    
    
      <category term="网络编程" scheme="http://yusank.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Unix" scheme="http://yusank.github.io/tags/Unix/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 添加歌单</title>
    <link href="http://yusank.github.io/testlist.html/"/>
    <id>http://yusank.github.io/testlist.html/</id>
    <published>2017-04-09T07:13:11.000Z</published>
    <updated>2017-04-09T07:13:11.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><p>测试添加歌单。。。。<br><a id="more"></a></p>
<h1 id="测试歌单"><a href="#测试歌单" class="headerlink" title="测试歌单"></a>测试歌单</h1>
			<div id="aplayer2" class="aplayer" style="margin-bottom: 20px;"></div>
			<script>
				var options = {"narrow":false,"autoplay":false,"showlrc":1,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"匆匆那年","author":"王菲","url":"http://oid1xlj7h.bkt.clouddn.com/%E7%8E%8B%E8%8F%B2%20-%20%E5%8C%86%E5%8C%86%E9%82%A3%E5%B9%B4.mp3","lrc":"http://oid1xlj7h.bkt.clouddn.com/ccnn.txt"},{"title":"Toca Toca","author":"Fly project","url":"http://oid1xlj7h.bkt.clouddn.com/Fly%20Project%20-%20Toca%20Toca.mp3"},{"title":"Danzo Kuduro","author":"Don Omar","url":"http://oid1xlj7h.bkt.clouddn.com/Don%20Omar,Lucenzo%20-%20Danza%20Kuduro%20-%20Album%20Version.mp3"},{"title":"难忘的一天","author":"许巍","url":"http://oid1xlj7h.bkt.clouddn.com/%E8%AE%B8%E5%B7%8D%20-%20%E9%9A%BE%E5%BF%98%E7%9A%84%E4%B8%80%E5%A4%A9.mp3","lrc":"http://oid1xlj7h.bkt.clouddn.com/nwdyt.txt"},{"title":"Counting Stars","author":"OneRepublic","url":"http://oid1xlj7h.bkt.clouddn.com/OneRepublic%20-%20Counting%20Stars.mp3"},{"title":"Zoobi Doobi","author":"Sonu Nigam,Shreya Ghoshal","url":"http://oid1xlj7h.bkt.clouddn.com/Sonu%20Nigam,Shreya%20Ghoshal%20-%20Zoobi%20Doobi.mp3","lrc":"http://oid1xlj7h.bkt.clouddn.com/tidoit.txt"}]};
				options.element = document.getElementById("aplayer2");
				new APlayer(options);
			</script>

		]]></content>
    
    <summary type="html">
    
      &lt;p&gt;测试添加歌单。。。。&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://yusank.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yusank.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客添加视频和音乐</title>
    <link href="http://yusank.github.io/HexoMedia.html/"/>
    <id>http://yusank.github.io/HexoMedia.html/</id>
    <published>2017-04-09T05:13:11.000Z</published>
    <updated>2017-04-09T05:13:11.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><p>找到一个炒鸡流弊的东西。。。</p>
<a id="more"></a>
<h1 id="Hexo-博客中插入视频-音乐"><a href="#Hexo-博客中插入视频-音乐" class="headerlink" title="Hexo 博客中插入视频/音乐"></a>Hexo 博客中插入视频/音乐</h1><p>博客中插入音乐/视频，可以让博客的逼格瞬间提高。作为优秀的静态博客，Hexo 当然也少不了这些高大上的功能。</p>
<h2 id="Markdown-通用音乐-视频插入方法"><a href="#Markdown-通用音乐-视频插入方法" class="headerlink" title="Markdown 通用音乐/视频插入方法"></a>Markdown 通用音乐/视频插入方法</h2><p>Markdown 作为轻量级的标记语言，兼容 html 语法，所以可以直接在 Markdown 文档中使用 html 语法。</p>
<p><code>vedio</code> 标签</p>
<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>480<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>320<span class="token punctuation">"</span></span> <span class="token attr-name">controls</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>movie.mp4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>video</span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>其中在 <code>src</code> 后面需要替换自己的音乐/视频链接</p>
<p>效果:</p>
<p>​    <video width="480" height="320" controls><br>​    <source src="http://oid1xlj7h.bkt.clouddn.com/WeChatSight72.mp4"><br>​    </video></p>
<h3 id="embed标签"><a href="#embed标签" class="headerlink" title="embed标签"></a><code>embed</code>标签</h3><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>embed</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://player.youku.com/player.php/Type/Folder/Fid/27690810/Ob/1/sid/XMTY1MTI3NjMyNA<span class="token punctuation">=</span><span class="token punctuation">=</span>/v.swf<span class="token punctuation">"</span></span> <span class="token attr-name">quality</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>high<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>480<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>400<span class="token punctuation">"</span></span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>middle<span class="token punctuation">"</span></span> <span class="token attr-name">allowScriptAccess</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>always<span class="token punctuation">"</span></span> <span class="token attr-name">allowFullScreen</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">mode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>transparent<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>application/x-shockwave-flash<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>embed</span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="ifreame标签"><a href="#ifreame标签" class="headerlink" title="ifreame标签"></a><code>ifreame</code>标签</h3><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span>498</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span>510</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://player.youku.com/embed/XMTY1MTI3NjMyNA<span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">"</span></span> <span class="token attr-name">frameborder</span><span class="token attr-value"><span class="token punctuation">=</span>0</span> <span class="token attr-name">allowfullscreen</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>网易云音乐网页版提供生成 iframe 标签。</p>
<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.xiami.com/widget/player-single?uid<span class="token punctuation">=</span>32329501&amp;sid<span class="token punctuation">=</span>1776238762&amp;mode<span class="token punctuation">=</span>js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>除了 <code>vedio</code> 标签外，大部分音乐/视频网站都可以直接生成播放代码，直接粘贴在 Markdown 文档即可。</p>
<p>不过有些标签不支持 HTTPS。</p>
<h2 id="通过-Hexo-插件插入音频-视频"><a href="#通过-Hexo-插件插入音频-视频" class="headerlink" title="通过 Hexo 插件插入音频/视频"></a>通过 Hexo 插件插入音频/视频</h2><p>这里需要两个播放器插件</p>
<pre class="line-numbers language-shell"><code class="language-shell">hexo-tag-aplayer:https://github.com/grzhan/hexo-tag-aplayer#upstream-issue

hexo-tag-dplayer:https://github.com/NextMoe/hexo-tag-dplayer
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这两款插件基于 DIYgod 编写的 html5 播放器 APlayer 和 DPlayer 开发。</p>
<p>首先安装两款插件</p>
<p>打开 shell，切换到 Hexo 目录下，运行两条目录</p>
<pre class="line-numbers language-shell"><code class="language-shell">npm install hexo-tag-dplayer --save
npm install hexo-tag-aplayer --save
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>安装成功后，在 Markdown 文档中添加 APlayer 和 DPlayer 标签即可。</p>
<pre class="line-numbers language-html"><code class="language-html">{% aplayer "Caffeine" "Jeff Williams" "http://7xq131.com1.z0.glb.clouddn.com/Preparation.mp3" "autoplay" %}
{% dplayer "url=http://devtest.qiniudn.com/若能绽放光芒.mp4" "api=http://dplayer.daoapp.io" "pic=http://devtest.qiniudn.com/若能绽放光芒.png" "id=9E2E3368B56CDBB4" "loop=yes" "theme=#FADFA3" "autoplay=false" "token=tokendemo" %}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>APlayer 和 DPlayer 具体参数设置可以到 GitHub 项目主页，不过默认参数足够了。</p>
<div id="aplayer0" class="aplayer" style="margin-bottom: 20px;">
				<pre class="aplayer-lrc-content">'[00:00.00]Zoobi Doobi
[00:00.38]Sonu Nigam & Shreya Ghoshal
[00:00.53]LRC：Meselson (QQ 445942376)
[00:01.18]
[00:03.50]Gungunati hain yeh hawayein 
[00:12.73]Gungunata hai gagan
[00:19.91]Gaa raha hai yeh saara aalam
[00:26.90]Zoobi do… param pum… 
[00:37.35]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum
[00:42.67]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann 
[00:47.99]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum
[00:53.30]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann 
[00:58.34]Shaakhon pe pattey gaa rahe hain Phoolon pe bhanvre gaa rahe
[01:03.69]Deewani kirine gaa rahi hain Yeh panchhi gaa rahe
[01:08.38]Ohhh Bagiya mein do phoolon ki Ho rahi hai guft-gu 
[01:14.02]Jaisa filmon mein hota hai Ho raha hai hu-bahoo
[01:19.18]I iiii iii.. 
[01:20.11]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum
[01:25.21]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann
[01:30.52]
[01:30.81]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum
[01:35.98]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann
[01:40.68]
[02:02.67]Rimjhim rimjhim rimjhim San san san san hawaa
[02:07.63]Tip tip tip tip boondein Gurrati bijliyaan
[02:13.00]Bheegi bheegi saree mein Yun thumke lagati tu
[02:18.24]Ho raha hai hu bahoo
[02:23.58]I iiii iii.. 
[02:24.23]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum
[02:29.16]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann
[02:32.50]
[02:34.30]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum
[02:39.58]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann
[02:45.70]
[03:06.55]Amber ka chand zameen par Itra ke gaa raha
[03:12.02]Ek tim tim toota tara Ithla ka gaa raha
[03:17.29]Hai raat akeli tanha Mujhe choo le aake tu
[03:22.47]Jaisa filmon mein hota hai Ho raha hai hubahoo
[03:27.24]I iiii iii.. 
[03:27.78]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum
[03:33.28]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann
[03:38.57]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum
[03:43.79]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann
[03:48.58]LRC：Meselson (QQ 445942376)
[03:50.47]THE END
</pre>
			</div>
			<script>
				new APlayer({
					element: document.getElementById("aplayer0"),
					narrow: false,
					autoplay: 1,
					showlrc: 2,
					music: {
						title: "Zoobi Doobi",
						author: "Three ediot",
						url: "http://oid1xlj7h.bkt.clouddn.com/Sonu%20Nigam,Shreya%20Ghoshal%20-%20Zoobi%20Doobi.mp3",
						pic: "http://oid1xlj7h.bkt.clouddn.com/3_idiots_wallpaper.jpg",
					}
				});
			</script>    
<div id="dplayer0" class="dplayer" style="margin-bottom: 20px;"></div><script>var dplayer0 = new DPlayer({"element":document.getElementById("dplayer0"),"autoplay":false,"theme":"#FADFA3","loop":true,"video":{"url":"http://oid1xlj7h.bkt.clouddn.com/WeChatSight72.mp4"},"danmaku":{"api":"http://dplayer.daoapp.io","id":"9E2E3368B56CDBB4","token":"tokendemo"}});</script>
<p>APlayer 和 DPlayer 均支持 HTTPS。</p>
<p>上述两种方法都有优缺点，选择一种适合自己的方法，打造自己专属的博客吧。</p>
<p>转载：【login926】login926.github.io</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;找到一个炒鸡流弊的东西。。。&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://yusank.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yusank.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Vim 快捷键</title>
    <link href="http://yusank.github.io/Vimkyboard.html/"/>
    <id>http://yusank.github.io/Vimkyboard.html/</id>
    <published>2017-04-07T07:07:00.000Z</published>
    <updated>2017-04-07T07:07:01.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><h1 id="Vim-快捷键"><a href="#Vim-快捷键" class="headerlink" title="Vim 快捷键"></a>Vim 快捷键</h1><h2 id="一-移动："><a href="#一-移动：" class="headerlink" title="一. 移动："></a>一. 移动：</h2><pre><code>h,j,k,l: 左，下，上，右。
w: 下一个词的词首。
e:下一个词的词尾。
</code></pre><p>​    b:上一个词的词首。</p>
<pre><code>&lt;&gt;: v 模式选中后进行缩进。
</code></pre><a id="more"></a>
<div id="aplayer1" class="aplayer" style="margin-bottom: 20px;"></div>
		<script>
			new APlayer({
				element: document.getElementById("aplayer1"),
				narrow: false,
				autoplay: true,
				showlrc: 0,
				music: {
					title: "Wadilar Keni",
					author: "from nobody",
					url: "http://oid1xlj7h.bkt.clouddn.com/elyarr%20-%20wadilar%C2%A0keni%EF%BC%88%E5%90%AC%E4%BA%86%E5%B0%B1%E6%B2%A1%E9%94%99%EF%BC%89.mp3",
					pic: "",
				}
			});
		</script>
<h2 id="二-跳转："><a href="#二-跳转：" class="headerlink" title="二. 跳转："></a>二. 跳转：</h2><pre><code>%: 可以匹配{},&quot;&quot;,(),[]之间跳转。
H、M、L：直接跳转到当前屏幕的顶部、中部、底部。
</code></pre><p>“#H”：跳转到当前屏的第#行。            <em>// 由于markdown语法原因，加上了双引号，实际用的时候没有双引号的</em>, 以下所有加引号的雷同。</p>
<p>“#L”：跳转到当前屏的倒数第#行。</p>
<pre><code>zt: 当前编辑行置为屏顶。
zz: 当前编辑行置为屏中。
zb: 当前编辑行置为屏底。
G：直接跳转到文件的底部。
gg: 跳转到文件首。
():跳转到当前的行首、行尾。
{}：向上、向下跳转到最近的空行。
[{：跳转到目前区块开头。
]}：跳转到目前区块结尾。
0: 跳转到行首。
$: 跳转到行尾。
2$: 跳转到下一行的行尾。
</code></pre><p>“#”：跳转到该行的第#个位置。</p>
<p>“#G”: 15G,跳转到15行。</p>
<pre><code>:#：跳转到#行。
f&#39;n&#39;：跳转到下一个&quot;n&quot;字母后。
ctrl+b: 向后翻一页。
ctrl+f：向前翻一页。
ctrl+u: 向后翻半页。
ctrl+d: 向前翻半页。
ctry+e: 下滚一行。
</code></pre><h2 id="三-选择："><a href="#三-选择：" class="headerlink" title="三. 选择："></a>三. 选择：</h2><pre><code>1.V: 选择一行。
2.^V: 矩形选择。
3.v3w: 选择三个字符。  
</code></pre><h2 id="四-编辑："><a href="#四-编辑：" class="headerlink" title="四. 编辑："></a>四. 编辑：</h2><ol>
<li><p>新增：<br>i: 光标前插入。</p>
<pre><code>    I: 在当前行首插入。
    a: 光标后插入。
    A: 当前行尾插入。
    O: 在当前行之前插入新行。
    o: 在当前行之后插入新行。
</code></pre></li>
<li><p>修改 c(change) 为主：<br>   r: 替换光标所在处的字符。</p>
<pre><code>       R：替换光标所到之处的字符。
       cw: 更改光标所在处的字到字尾处。
       c#w: c3w 修改3个字符。
       C：修改到行尾。
       ci&#39;：修改配对标点符号中的文本内容。
       di&#39;：删除配对标点符号中的文本内容。
       yi&#39;：复制配对标点符号中的文本内容。
       vi&#39;：选中配对标点符号中的文本内容。
       s：替换当前一个光标所处字符。
</code></pre><p>   ​    “#S”：删除 # 行，并以新文本代替。</p>
</li>
</ol>
<ol>
<li><p>删除 d(delete) 为主：<br>D：删除到行尾。</p>
<pre><code>    X: 每按一次，删除光标所在位置的前面一个字符。
    x: 每按一次，删除光标所在位置的后面一个字符。
</code></pre><p>​    “#x”: 删除光标所在位置后面6个字符。</p>
<pre><code>    d^: 删至行首。
    d$: 删至行尾。
    dd:(剪切)删除光标所在行。        
    dw: 删除一个单词/光标之后的单词剩余部分。
    d4w: 删除4个word。
</code></pre><p>​”#dd”: 从光标所在行开始删除#行。</p>
<p>  daB: 删除{}及其内的内容。<br>  diB: 删除{}中的内容。<br>  n1,n2 d：将n1,n2行之间的内容删除。</p>
</li>
<li><p>查找：<br>/： 输入关键字，发现不是要找的，直接在按n，向后查找直到找到为止。</p>
<pre><code>    ?： 输入关键字，发现不是要找的，直接在按n，向前查找直到找到为止。
    *: 在当前页向后查找同一字。
</code></pre><p>​    “#”: 在当前页向前查找同一字。</p>
</li>
<li><p>复制 y(yank)为主：<br>   yw: 将光标所在之处到字尾的字符复制到缓冲区中。</p>
<p>   “#yw”: 复制#个字到缓冲区。</p>
<pre><code> Y：相当于yy, 复制整行。
</code></pre></li>
</ol>
<p>​    “#yy”:表示复制从光标所在的该行往下数#行文字。</p>
<pre><code>    p: 粘贴。所有与y相关的操作必用p来结合粘贴。
    n1,n2 co n3：复制第n1行到第n2行之间的内容到第n3行后面。
    6. 大小写转换：
      gUU: 将当前行的字母改为大写。
              guu: 将当前行的字母改为小写。
              gUw: 将当前光标下的单词改为大写。
              guw: 将当前光标下的单词改为小写。
              a. 整篇大写:
              ggguG
              gg: 光标到文件第一个字符。
              gu: 把选择范围全部小写。
              G: 到文件结束。
              b. 整篇小写：gggUG
    7. 其它：
      J：当前行和下一行合并成一行。
    8. 移动：
      n1,n2 m n3：将n1行到n2行之间的内容移至n3行下。
</code></pre><h2 id="五-退出："><a href="#五-退出：" class="headerlink" title="五.退出："></a>五.退出：</h2><pre><code>      1. w filename: 保存正在编辑的文件filename
      2. wq filename: 保存后退出正在编辑的文件filename
      3. q：退出不保存。
</code></pre><h2 id="六-窗口操作："><a href="#六-窗口操作：" class="headerlink" title="六.窗口操作："></a>六.窗口操作：</h2><pre><code>      1. ctrl+w p: 在两个分割窗口之间来回切换。
      2. ctrl+w j: 跳到下面的分割窗
      3. ctrl+w h: 跳到左边的分割窗。
      4. ctrl+w k: 跳到上面的分割窗。
      5. ctrl+w l: 跳到右边的分割窗。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Vim-快捷键&quot;&gt;&lt;a href=&quot;#Vim-快捷键&quot; class=&quot;headerlink&quot; title=&quot;Vim 快捷键&quot;&gt;&lt;/a&gt;Vim 快捷键&lt;/h1&gt;&lt;h2 id=&quot;一-移动：&quot;&gt;&lt;a href=&quot;#一-移动：&quot; class=&quot;headerlink&quot; title=&quot;一. 移动：&quot;&gt;&lt;/a&gt;一. 移动：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;h,j,k,l: 左，下，上，右。
w: 下一个词的词首。
e:下一个词的词尾。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;​    b:上一个词的词首。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;&amp;gt;: v 模式选中后进行缩进。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Vim" scheme="http://yusank.github.io/categories/Vim/"/>
    
    
      <category term="vim" scheme="http://yusank.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Go Channel</title>
    <link href="http://yusank.github.io/Go%20Channel.html/"/>
    <id>http://yusank.github.io/Go Channel.html/</id>
    <published>2017-04-07T04:20:00.000Z</published>
    <updated>2017-08-19T07:09:31.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><p>讲解 Golang 的 channel（通道），学 go 语言的有必要看一下。以下正文。。。</p>
<hr>
<h1 id="Go-Channel-详解"><a href="#Go-Channel-详解" class="headerlink" title="Go Channel 详解"></a>Go Channel 详解</h1><p>Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)。</p>
<p>它的操作符是箭头 <strong>&lt;-</strong> 。</p>
<pre class="line-numbers language-go"><code class="language-go">ch <span class="token operator">&lt;-</span> v    
v <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>(箭头的指向就是数据的流向)</p>
<p>就像 map 和 slice 数据类型一样, channel必须先创建再使用:</p>
<pre class="line-numbers language-go"><code class="language-go">ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="Channel-类型"><a href="#Channel-类型" class="headerlink" title="Channel 类型"></a>Channel 类型</h2><p>Channel类型的定义格式如下：</p>
<pre class="line-numbers language-go"><code class="language-go">ChannelType <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token string">"chan"</span> <span class="token operator">|</span> <span class="token string">"chan"</span> <span class="token string">"&lt;-"</span> <span class="token operator">|</span> <span class="token string">"&lt;-"</span> <span class="token string">"chan"</span> <span class="token punctuation">)</span> ElementType <span class="token punctuation">.</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>它包括三种类型的定义。可选的<code>&lt;-</code>代表channel的方向。如果没有指定方向，那么Channel就是双向的，既可以接收数据，也可以发送数据。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">chan</span> T          <span class="token comment" spellcheck="true">// 可以接收和发送类型为 T 的数据</span>
<span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">float64</span>  <span class="token comment" spellcheck="true">// 只可以用来发送 float64 类型的数据</span>
<span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span>      <span class="token comment" spellcheck="true">// 只可以用来接收 int 类型的数据</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>&lt;-</code>总是优先和最左边的类型结合。(The &lt;- operator associates with the leftmost chan possible)</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token keyword">chan</span> <span class="token builtin">int</span>    <span class="token comment" spellcheck="true">// 等价 chan&lt;- (chan int)</span>
<span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span>  <span class="token comment" spellcheck="true">// 等价 chan&lt;- (&lt;-chan int)</span>
<span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span>  <span class="token comment" spellcheck="true">// 等价 &lt;-chan (&lt;-chan int)</span>
<span class="token keyword">chan</span> <span class="token punctuation">(</span><span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用<code>make</code>初始化Channel,并且可以设置容量:</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>容量(capacity)代表Channel容纳的最多的元素的数量，代表Channel的缓存的大小。<br>如果没有设置容量，或者容量设置为0, 说明Channel没有缓存，只有sender和receiver都准备好了后它们的通讯(communication)才会发生(Blocking)。如果设置了缓存，就有可能不发生阻塞， 只有buffer满了后 send才会阻塞， 而只有缓存空了后receive才会阻塞。一个nil channel不会通信。</p>
<p>可以通过内建的<code>close</code>方法可以关闭Channel。</p>
<p>你可以在多个goroutine从/往 一个channel 中 receive/send 数据, 不必考虑额外的同步措施。</p>
<p>Channel可以作为一个先入先出(FIFO)的队列，接收的数据和发送的数据的顺序是一致的。</p>
<p>channel的 receive支持 <em>multi-valued assignment</em>，如</p>
<pre class="line-numbers language-go"><code class="language-go">v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>它可以用来检查Channel是否已经被关闭了。</p>
<ol>
<li><strong>send语句</strong><br>send语句用来往Channel中发送数据， 如<code>ch &lt;- 3</code>。<br>它的定义如下:</li>
</ol>
<pre class="line-numbers language-go"><code class="language-go">SendStmt <span class="token operator">=</span> Channel <span class="token string">"&lt;-"</span> Expression <span class="token punctuation">.</span>
Channel  <span class="token operator">=</span> Expression <span class="token punctuation">.</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在通讯(communication)开始前channel和expression必选先求值出来(evaluated)，比如下面的(3+4)先计算出7然后再发送给channel。</p>
<pre class="line-numbers language-go"><code class="language-go">c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
<span class="token keyword">defer</span> <span class="token function">close</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c <span class="token operator">&lt;-</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
i <span class="token operator">:=</span> <span class="token operator">&lt;-</span>c
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>send被执行前(proceed)通讯(communication)一直被阻塞着。如前所言，无缓存的channel只有在receiver准备好后send才被执行。如果有缓存，并且缓存未满，则send会被执行。</p>
<p>往一个已经被close的channel中继续发送数据会导致<strong>run-time panic</strong>。</p>
<p>往nil channel中发送数据会一致被阻塞着。</p>
<ol>
<li>receive 操作符<br><code>&lt;-ch</code>用来从channel ch中接收数据，这个表达式会一直被block,直到有数据可以接收。</li>
</ol>
<p>从一个nil channel中接收数据会一直被block。</p>
<p>从一个被close的channel中接收数据不会被阻塞，而是立即返回，接收完已发送的数据后会返回元素类型的零值(zero value)。</p>
<p>如前所述，你可以使用一个额外的返回参数来检查channel是否关闭。</p>
<pre class="line-numbers language-go"><code class="language-go">x<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch
x<span class="token punctuation">,</span> ok <span class="token operator">=</span> <span class="token operator">&lt;-</span>ch
<span class="token keyword">var</span> x<span class="token punctuation">,</span> ok <span class="token operator">=</span> <span class="token operator">&lt;-</span>ch
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="blocking"><a href="#blocking" class="headerlink" title="blocking"></a>blocking</h2><p>缺省情况下，发送和接收会一直阻塞着，知道另一方准备好。这种方式可以用来在gororutine中进行同步，而不必使用显示的锁或者条件变量。</p>
<p>如官方的例子中<code>x, y := &lt;-c, &lt;-c</code>这句会一直等待计算结果发送到channel中。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"fmt"</span>
<span class="token keyword">func</span> <span class="token function">sum</span><span class="token punctuation">(</span>s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> c <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sum <span class="token operator">:=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> s <span class="token punctuation">{</span>
        sum <span class="token operator">+=</span> v
    <span class="token punctuation">}</span>
    c <span class="token operator">&lt;-</span> sum 
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span>
    c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
    <span class="token keyword">go</span> <span class="token function">sum</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span>
    <span class="token keyword">go</span> <span class="token function">sum</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span>
    x<span class="token punctuation">,</span> y <span class="token operator">:=</span> <span class="token operator">&lt;-</span>c<span class="token punctuation">,</span> <span class="token operator">&lt;-</span>c <span class="token comment" spellcheck="true">// receive from c</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> x<span class="token operator">+</span>y<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h2><p>make的第二个参数指定缓存的大小：<code>ch := make(chan int, 100)</code>。</p>
<p>通过缓存的使用，可以尽量避免阻塞，提供应用的性能。</p>
<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p><code>for …… range</code>语句可以处理Channel。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Hour<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">{</span>
            c <span class="token operator">&lt;-</span> i
        <span class="token punctuation">}</span>
        <span class="token function">close</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> c <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Finished"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>range c</code>产生的迭代值为Channel中发送的值，它会一直迭代知道channel被关闭。上面的例子中如果把<code>close(c)</code>注释掉，程序会一直阻塞在<code>for …… range</code>那一行。</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p><code>select</code>语句选择一组可能的send操作和receive操作去处理。它类似<code>switch</code>,但是只是用来处理通讯(communication)操作。<br>它的<code>case</code>可以是send语句，也可以是receive语句，亦或者<code>default</code>。</p>
<p><code>receive</code>语句可以将值赋值给一个或者两个变量。它必须是一个receive操作。</p>
<p>最多允许有一个<code>default case</code>,它可以放在case列表的任何位置，尽管我们大部分会将它放在最后。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"fmt"</span>
<span class="token keyword">func</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> quit <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">,</span> y <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>
    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        <span class="token keyword">select</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> c <span class="token operator">&lt;-</span> x<span class="token punctuation">:</span>
            x<span class="token punctuation">,</span> y <span class="token operator">=</span> y<span class="token punctuation">,</span> x<span class="token operator">+</span>y
        <span class="token keyword">case</span> <span class="token operator">&lt;-</span>quit<span class="token punctuation">:</span>
            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"quit"</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
    quit <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>c<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        quit <span class="token operator">&lt;-</span> <span class="token number">0</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">fibonacci</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> quit<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果有同时多个case去处理,比如同时有多个channel可以接收数据，那么Go会伪随机的选择一个case处理(pseudo-random)。如果没有case需要处理，则会选择<code>default</code>去处理，如果<code>default case</code>存在的情况下。如果没有<code>default case</code>，则<code>select</code>语句会阻塞，直到某个case需要处理。</p>
<p>需要注意的是，nil channel上的操作会一直被阻塞，如果没有default case,只有nil channel的select会一直被阻塞。</p>
<p><code>select</code>语句和<code>switch</code>语句一样，它不是循环，它只会选择一个case来处理，如果想一直处理channel，你可以在外面加一个无限的for循环：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">for</span> <span class="token punctuation">{</span>
    <span class="token keyword">select</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> c <span class="token operator">&lt;-</span> x<span class="token punctuation">:</span>
        x<span class="token punctuation">,</span> y <span class="token operator">=</span> y<span class="token punctuation">,</span> x<span class="token operator">+</span>y
    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>quit<span class="token punctuation">:</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"quit"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p><code>select</code>有很重要的一个应用就是超时处理。 因为上面我们提到，如果没有case需要处理，select语句就会一直阻塞着。这时候我们可能就需要一个超时操作，用来处理超时的情况。<br>下面这个例子我们会在2秒后往channel c1中发送一个数据，但是<code>select</code>设置为1秒超时,因此我们会打印出<code>timeout 1</code>,而不是<code>result 1</code>。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"time"</span>
<span class="token keyword">import</span> <span class="token string">"fmt"</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    c1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
        c1 <span class="token operator">&lt;-</span> <span class="token string">"result 1"</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">select</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> res <span class="token operator">:=</span> <span class="token operator">&lt;-</span>c1<span class="token punctuation">:</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"timeout 1"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其实它利用的是<code>time.After</code>方法，它返回一个类型为<code>&lt;-chan Time</code>的单向的channel，在指定的时间发送一个当前时间给返回的channel中。</p>
<h2 id="Timer-和-Ticker"><a href="#Timer-和-Ticker" class="headerlink" title="Timer 和 Ticker"></a>Timer 和 Ticker</h2><p>我们看一下关于时间的两个Channel。<br>timer是一个定时器，代表未来的一个单一事件，你可以告诉timer你要等待多长时间，它提供一个Channel，在将来的那个时间那个Channel提供了一个时间值。下面的例子中第二行会阻塞2秒钟左右的时间，直到时间到了才会继续执行。</p>
<pre class="line-numbers language-go"><code class="language-go">timer1 <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTimer</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">&lt;-</span>timer1<span class="token punctuation">.</span>C
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Timer 1 expired"</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>当然如果你只是想单纯的等待的话，可以使用<code>time.Sleep</code>来实现。</p>
<p>你还可以使用<code>timer.Stop</code>来停止计时器。</p>
<pre class="line-numbers language-go"><code class="language-go">timer2 <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTimer</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">&lt;-</span>timer2<span class="token punctuation">.</span>C
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Timer 2 expired"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
stop2 <span class="token operator">:=</span> timer2<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> stop2 <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Timer 2 stopped"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>ticker</code>是一个定时触发的计时器，它会以一个间隔(interval)往Channel发送一个事件(当前时间)，而Channel的接收者可以以固定的时间间隔从Channel中读取事件。下面的例子中ticker每500毫秒触发一次，你可以观察输出的时间。</p>
<pre class="line-numbers language-go"><code class="language-go">ticker <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTicker</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> <span class="token number">500</span><span class="token punctuation">)</span>
<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> t <span class="token operator">:=</span> <span class="token keyword">range</span> ticker<span class="token punctuation">.</span>C <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Tick at"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>类似timer, ticker也可以通过<code>Stop</code>方法来停止。一旦它停止，接收者不再会从channel中接收数据了。</p>
<h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>内建的close方法可以用来关闭channel。</p>
<p>总结一下channel关闭后sender的receiver操作。<br>如果channel c已经被关闭,继续往它发送数据会导致<code>panic: send on closed channel</code>:</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"time"</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Hour<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
    c <span class="token operator">&lt;-</span> <span class="token number">1</span>
    c <span class="token operator">&lt;-</span> <span class="token number">2</span>
    <span class="token function">close</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
    c <span class="token operator">&lt;-</span> <span class="token number">3</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是从这个关闭的channel中不但可以读取出已发送的数据，还可以不断的读取零值:</p>
<pre class="line-numbers language-go"><code class="language-go">c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
c <span class="token operator">&lt;-</span> <span class="token number">1</span>
c <span class="token operator">&lt;-</span> <span class="token number">2</span>
<span class="token function">close</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>c<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//1</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>c<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//2</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>c<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//0</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>c<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是如果通过<code>range</code>读取，channel关闭后for循环会跳出：</p>
<pre class="line-numbers language-go"><code class="language-go">c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
c <span class="token operator">&lt;-</span> <span class="token number">1</span>
c <span class="token operator">&lt;-</span> <span class="token number">2</span>
<span class="token function">close</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> c <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过<code>i, ok := &lt;-c</code>可以查看Channel的状态，判断值是零值还是正常读取的值。</p>
<pre class="line-numbers language-go"><code class="language-go">c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token function">close</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>

i<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>c
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d, %t"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> ok<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//0, false</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>channel可以用在goroutine之间的同步。<br>下面的例子中main goroutine通过done channel等待worker完成任务。 worker做完任务后只需往channel发送一个数据就可以通知main goroutine任务完成。</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"time"</span>
<span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token function">worker</span><span class="token punctuation">(</span>done <span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 通知任务已完成</span>
    done <span class="token operator">&lt;-</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    done <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">go</span> <span class="token function">worker</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 等待任务完成</span>
    <span class="token operator">&lt;-</span>done
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>[参考资料]：</strong></p>
<ol>
<li><a href="https://gobyexample.com/channels" target="_blank" rel="external">https://gobyexample.com/channels</a></li>
<li><a href="https://tour.golang.org/concurrency/2" target="_blank" rel="external">https://tour.golang.org/concurrency/2</a></li>
<li><a href="https://golang.org/ref/spec#Select_statements" target="_blank" rel="external">https://golang.org/ref/spec#Select_statements</a></li>
<li><a href="https://github.com/a8m/go-lang-cheat-sheet" target="_blank" rel="external">https://github.com/a8m/go-lang-cheat-sheet</a></li>
<li><a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/" target="_blank" rel="external">http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;讲解 Golang 的 channel（通道），学 go 语言的有必要看一
    
    </summary>
    
      <category term="GO" scheme="http://yusank.github.io/categories/GO/"/>
    
    
      <category term="GO" scheme="http://yusank.github.io/tags/GO/"/>
    
  </entry>
  
  <entry>
    <title>跨域资源共享 CORS 详解</title>
    <link href="http://yusank.github.io/CORS.html/"/>
    <id>http://yusank.github.io/CORS.html/</id>
    <published>2017-01-30T07:07:00.000Z</published>
    <updated>2017-01-30T07:07:01.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><h1 id="跨域资源共享-CORS-详解"><a href="#跨域资源共享-CORS-详解" class="headerlink" title="跨域资源共享 CORS 详解"></a>跨域资源共享 CORS 详解</h1><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。<br>它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了AJAX只能<strong>同源</strong>使用的限制。<br>本文详细介绍CORS的内部机制。<br><a id="more"></a></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5110131&auto=1&height=66"></iframe>

<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h2 id="二、两种请求"><a href="#二、两种请求" class="headerlink" title="二、两种请求"></a>二、两种请求</h2><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要同时满足以下两大条件，就属于简单请求。</p>
<blockquote>
<p>1) 请求方法是以下三种方法之一：</p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>（2）HTTP的头信息不超出以下几种字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
</blockquote>
<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<h2 id="三、简单请求"><a href="#三、简单请求" class="headerlink" title="三、简单请求"></a>三、简单请求</h2><h3 id="3-1-基本流程"><a href="#3-1-基本流程" class="headerlink" title="3.1 基本流程"></a>3.1 基本流程</h3><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p>
<p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p>
<pre class="line-numbers language-http"><code class="language-http">GET /cors HTTP/1.1
<span class="token header-name keyword">Origin:</span> http://api.bob.com
<span class="token header-name keyword">Host:</span> api.alice.com
<span class="token header-name keyword">Accept-Language:</span> en-US
<span class="token header-name keyword">Connection:</span> keep-alive
<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<pre class="line-numbers language-http"><code class="language-http"><span class="token header-name keyword">Access-Control-Allow-Origin:</span> http://api.bob.com
<span class="token header-name keyword">Access-Control-Allow-Credentials:</span> true
<span class="token header-name keyword">Access-Control-Expose-Headers:</span> FooBar
<span class="token header-name keyword">Content-Type:</span> text/html; charset=utf-8
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头。</p>
<p><strong>（1）Access-Control-Allow-Origin</strong></p>
<p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<p><strong>（2）Access-Control-Allow-Credentials</strong></p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p><strong>（3）Access-Control-Expose-Headers</strong></p>
<p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p>
<h3 id="3-2-withCredentials-属性"><a href="#3-2-withCredentials-属性" class="headerlink" title="3.2 withCredentials 属性"></a>3.2 withCredentials 属性</h3><p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p>
<pre class="line-numbers language-http"><code class="language-http"><span class="token header-name keyword">Access-Control-Allow-Credentials:</span> true
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。</p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p>
<p>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭<code>withCredentials</code>。</p>
<pre class="line-numbers language-javascript"><code class="language-javascript">xhr<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>需要注意的是，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</p>
<h2 id="四、非简单请求"><a href="#四、非简单请求" class="headerlink" title="四、非简单请求"></a>四、非简单请求</h2><h3 id="4-1-预检请求"><a href="#4-1-预检请求" class="headerlink" title="4.1 预检请求"></a>4.1 预检请求</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>
<p>下面是一段浏览器的JavaScript脚本。</p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token string">'http://api.alice.com/cors'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'PUT'</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'X-Custom-Header'</span><span class="token punctuation">,</span> <span class="token string">'value'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面代码中，HTTP请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。</p>
<pre class="line-numbers language-http"><code class="language-http">OPTIONS /cors HTTP/1.1
<span class="token header-name keyword">Origin:</span> http://api.bob.com
<span class="token header-name keyword">Access-Control-Request-Method:</span> PUT
<span class="token header-name keyword">Access-Control-Request-Headers:</span> X-Custom-Header
<span class="token header-name keyword">Host:</span> api.alice.com
<span class="token header-name keyword">Accept-Language:</span> en-US
<span class="token header-name keyword">Connection:</span> keep-alive
<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>“预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p>
<p>除了<code>Origin</code>字段，”预检”请求的头信息包括两个特殊字段。</p>
<p><strong>（1）Access-Control-Request-Method</strong></p>
<p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code>。</p>
<p><strong>（2）Access-Control-Request-Headers</strong></p>
<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p>
<h3 id="4-2-预检请求的回应"><a href="#4-2-预检请求的回应" class="headerlink" title="4.2 预检请求的回应"></a>4.2 预检请求的回应</h3><p>服务器收到”预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p>
<pre class="line-numbers language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span>
<span class="token header-name keyword">Date:</span> Mon, 01 Dec 2008 01:15:39 GMT
<span class="token header-name keyword">Server:</span> Apache/2.0.61 (Unix)
<span class="token header-name keyword">Access-Control-Allow-Origin:</span> http://api.bob.com
<span class="token header-name keyword">Access-Control-Allow-Methods:</span> GET, POST, PUT
<span class="token header-name keyword">Access-Control-Allow-Headers:</span> X-Custom-Header
<span class="token header-name keyword">Content-Type:</span> text/html; charset=utf-8
<span class="token header-name keyword">Content-Encoding:</span> gzip
<span class="token header-name keyword">Content-Length:</span> 0
<span class="token header-name keyword">Keep-Alive:</span> timeout=2, max=100
<span class="token header-name keyword">Connection:</span> Keep-Alive
<span class="token header-name keyword">Content-Type:</span> text/plain
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的HTTP回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<pre class="line-numbers language-http"><code class="language-http"><span class="token header-name keyword">Access-Control-Allow-Origin:</span> *
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p>
<pre class="line-numbers language-http"><code class="language-http">XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>服务器回应的其他CORS相关字段如下。</p>
<pre class="line-numbers language-http"><code class="language-http"><span class="token header-name keyword">Access-Control-Allow-Methods:</span> GET, POST, PUT
<span class="token header-name keyword">Access-Control-Allow-Headers:</span> X-Custom-Header
<span class="token header-name keyword">Access-Control-Allow-Credentials:</span> true
<span class="token header-name keyword">Access-Control-Max-Age:</span> 1728000
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>（1）Access-Control-Allow-Methods</strong></p>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p>
<p><strong>（2）Access-Control-Allow-Headers</strong></p>
<p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p>
<p><strong>（3）Access-Control-Allow-Credentials</strong></p>
<p>该字段与简单请求时的含义相同。</p>
<p><strong>（4）Access-Control-Max-Age</strong></p>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
<h3 id="4-3-浏览器的正常请求和回应"><a href="#4-3-浏览器的正常请求和回应" class="headerlink" title="4.3 浏览器的正常请求和回应"></a>4.3 浏览器的正常请求和回应</h3><p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p>
<p>下面是”预检”请求之后，浏览器的正常CORS请求。</p>
<pre class="line-numbers language-http"><code class="language-http">PUT /cors HTTP/1.1
<span class="token header-name keyword">Origin:</span> http://api.bob.com
<span class="token header-name keyword">Host:</span> api.alice.com
<span class="token header-name keyword">X-Custom-Header:</span> value
<span class="token header-name keyword">Accept-Language:</span> en-US
<span class="token header-name keyword">Connection:</span> keep-alive
<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面头信息的<code>Origin</code>字段是浏览器自动添加的。</p>
<p>下面是服务器正常的回应。</p>
<pre class="line-numbers language-http"><code class="language-http"><span class="token header-name keyword">Access-Control-Allow-Origin:</span> http://api.bob.com
<span class="token header-name keyword">Content-Type:</span> text/html; charset=utf-8
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p>
<h2 id="五、与JSONP的比较"><a href="#五、与JSONP的比较" class="headerlink" title="五、与JSONP的比较"></a>五、与JSONP的比较</h2><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p>
<p>JSONP只支持<code>GET</code>请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<p>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;跨域资源共享-CORS-详解&quot;&gt;&lt;a href=&quot;#跨域资源共享-CORS-详解&quot; class=&quot;headerlink&quot; title=&quot;跨域资源共享 CORS 详解&quot;&gt;&lt;/a&gt;跨域资源共享 CORS 详解&lt;/h1&gt;&lt;p&gt;CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。&lt;br&gt;它允许浏览器向跨源服务器，发出&lt;code&gt;XMLHttpRequest&lt;/code&gt;请求，从而克服了AJAX只能&lt;strong&gt;同源&lt;/strong&gt;使用的限制。&lt;br&gt;本文详细介绍CORS的内部机制。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yusank.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CORS" scheme="http://yusank.github.io/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>Docker 进阶与实践（第一讲）</title>
    <link href="http://yusank.github.io/Docker.html/"/>
    <id>http://yusank.github.io/Docker.html/</id>
    <published>2017-01-03T10:11:00.000Z</published>
    <updated>2017-01-04T06:12:00.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><p>学习 Docker 技术，每看完一章或够写一篇文章的时候就上传一次. 这一篇讲容器技术。以下正文。。。<br><a id="more"></a></p>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h3 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h3><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=437292675&auto=1&height=66"></iframe>

<p>对于容器，目前并没有一个严格的定义，但是普遍被认可的说法是，它首先必须是一个相对独立的环境，在这一点上有点类似虚拟机，但是没有虚拟机那么彻底。另外，在一个容器环境中，应该最小化其对外界的影响，比如不能在容器中吧host上的资源耗尽，这就是资源的控制。</p>
<p>容器技术之所以受欢迎，一个重要的原因是它已经集成到了 Linux 内核中，已经被当作 Linux 内核原生提供的特征。当然其他平台也有相应的容器技术，但是我们讨论的以及Docker涉及的都是指 Linux 平台上的容器技术。</p>
<p>一般来说，容器技术主要包括Namespace和Cgroup两个内核特征。</p>
<ul>
<li>Namespace 命名空间，它主要做的是访问隔离。其原理是对一类资源进行抽象，并将其封装在一起提供给容器使用，对于这类资源，因为每个容器都有自己的抽象，而他们彼此之间是不可见的，所以就做到访问隔离。</li>
<li>Cgroup是 control group 的简称，又称为控制组，它主要是控制资源控制。其原理是将一组进程放在一个控制组里，通过给这个控制组分配指定的可用资源，达到控制这一组进程可用资源的目的。</li>
</ul>
<p>容器最核心技术是 Namespace+Cgroup，但是光有这两个抽象的技术概念是无法组成一个完整的容器的。<br>对于 linux 容器的最小组成，是由一下四个部分构成：</p>
<ul>
<li>Cgroup： 资源控制。</li>
<li>Namespace： 访问隔离。</li>
<li>rootfs： 系统文件隔离。</li>
<li>容器引擎： 生命周期控制。</li>
</ul>
<h2 id="容器的创建原理"><a href="#容器的创建原理" class="headerlink" title="容器的创建原理"></a>容器的创建原理</h2><p>代码一</p>
<pre class="line-numbers language-c"><code class="language-c">pid <span class="token operator">=</span> <span class="token function">clone</span><span class="token punctuation">(</span>fun<span class="token punctuation">,</span> stack<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> clone_arg<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span>flags<span class="token punctuation">:</span> CLONE_NEWPID <span class="token operator">|</span> CLONE_NEWNS <span class="token operator">|</span>
     CLONE_NEWUSER <span class="token operator">|</span> CLONE_NEWNET <span class="token operator">|</span>
     CLONE_NEWIPC <span class="token operator">|</span> CLONE_NEWUTS <span class="token operator">|</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>对于以上代码，通过clone系统调用，并传入各个Namespace对应的clone flag，创建了一个新的子进程，该进程拥有自己的Namespace。从上面的代码可以看出，该进程拥有自己的pid,mount,user,net,ipc,uts namespace 。</li>
</ul>
<p>代码二：</p>
<pre class="line-numbers language-sh"><code class="language-sh">echo $pid > /sys/fs/cgroup/cpu/tasks
echo $pid > /sys/fs/cgroup/cpuset/tasks
echo $pid > /sys/fs/cgroup/blkio/tasks
echo $pid > /sys/fs/cgroup/memory/tasks
echo $pid > /sys/fs/cgroup/devices/tasks
echo $pid > /sys/fs/cgroup/freezer/tasks
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>对于代码二，将代码一中的pid写入各个Cgroup子系统中，这样该进程就可以受到相应Cgroup子系统的控制。</li>
</ul>
<p>代码三：</p>
<pre class="line-numbers language-sh"><code class="language-sh">fun ()
{
    ...

    pivot_root("path_of_rootfs/", path);
    ...

    exec("/bin/bash");
    ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>对于代码三，该fun函数由上面生成的新进程执行，在fun函数中，通过<code>pivot_root</code>系统调用，使进程进入新的<code>rootfs</code>，之后通过<code>exec</code>系统调用，在新的<code>Namespace</code>,<code>Cgroup</code>,<code>rootfs</code>中执行<code>&quot;/bin/bash&quot;</code>程序。</li>
</ul>
<p>通过以上操作，成功在一个“容器”中运行了一个bash程序。对于Cgroup和Namespace的技术细节，我们下一节详细描述</p>
<h1 id="Cgroup"><a href="#Cgroup" class="headerlink" title="Cgroup"></a>Cgroup</h1><h2 id="Cgroup-是什么"><a href="#Cgroup-是什么" class="headerlink" title="Cgroup 是什么"></a>Cgroup 是什么</h2><p>Cgroup是control group 的简写，属于 Linux 内核提供的一个特性，用于限制和隔离一组进程对系统资源的使用。这些资源主要包括 CPU， 内存， block I/O（数据块 I/O） 和网络宽带。<br>Cgroup 从 2.6.24版本进入内核主线，目前各大发行版linux都默认打开了 Cgroup 特性</p>
<p>从实现的角度来看，Cgroup 实现了一个通用的进程分组的框架，而不同资源的具体管理则是由各个 Cgroup 子系统实现的。截止内核4.1版本，Cgroup 中实现的子系统的及其作用如下：</p>
<ul>
<li>devices： 设备权限控制</li>
<li>cpuset： 分配指定的CPU和内存节点</li>
<li>cpu： 控制 CPU 占用率</li>
<li>cpuacct： 统计 CPU 使用情况</li>
<li>memory： 限制内存的使用上限</li>
<li>freezer： 冻结（暂停）Cgroup 中的进程</li>
<li>net_cls： 配合tc（traffic controller）限制网络宽带</li>
<li>net_prio： 设置进程的网络流量优先级</li>
<li>huge_tlb： 限制HugeTLB（块表缓冲区）的使用</li>
<li>perf_event： 允许 Perf 工具基于Cgroup分组做性能测试</li>
</ul>
<h1 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h1><h2 id="Namespace-是什么"><a href="#Namespace-是什么" class="headerlink" title="Namespace 是什么"></a>Namespace 是什么</h2><p>Namespace 是将内核的全局资源做封装，使得每个Namespace都有有一份独立的资源，因此不同的进程各自的 Namespace 内对同一个资源的使用不会互相干扰。<br>举个例子，执行 sethostname 这个系统调用时，可以改变系统的主机名，这个主机名就是一个内核的全局资源。内核通过实现 UTS Namespace，可以将不同的进程分隔在不同的 UTS Namespace 中，在某个 Namespace 修改主机名时，另一个 Namespace 的主机名还是保持不变。</p>
<p>目前 Linux 内核总共实现了6种 Namespace：</p>
<ul>
<li>IPC： 隔离 System V IPC 和 POSIX 消息队列</li>
<li>Network： 隔离网络资源</li>
<li>Mount： 隔离文件系统挂载点</li>
<li>PID： 隔离进程 ID</li>
<li>UTS： 隔离主机名和域名</li>
<li>User： 隔离用户 ID 和 组 ID</li>
</ul>
<p>Namespace 和 Cgroup 的使用是灵活的，同时也有不少需要注意的地方，因此直接操作 Namespace 和 Cgroup 并不是很容易。正是因为这些原因，Docker 通过 Libcontainer 来处理这些底层的事情。这样一来，Docker 只需简单地调用 Libcontainer 的 API ，就能将完整的容器搭建起来。而作为 Docker 的用户，就更不用操心这些事情了。</p>
<h1 id="容器造就-Docker"><a href="#容器造就-Docker" class="headerlink" title="容器造就 Docker"></a>容器造就 Docker</h1><p>关于容器是否是 Docker 的技术核心技术，业界一直存在着争议。</p>
<p>在理解了容器，理解了容器的核心技术 Cgroup 和 Namespace，理解了容器技术如何巧妙且轻量地实现“容器”本身的资源控制和访问隔离之后，可以看到 Docker 和容器是一种完美的融合和辅助相成的关系，它们不是唯一的搭配，但一定是最完美的结合（目前来说）。与其说是容器造就了 Docker ， 不如说是它们造就了彼此，容器技术让 Docker 得到更多的应用和推广，Docker 也使得容器技术被更多人熟知。<br>[须知]：<b>转载请标明出处，请尊重笔者和作者的功劳，O(∩_∩)O谢谢！</b><br>[参考]:<b>Docker 进阶与实践  </b><i>华为Docker实践小组 著（机械工业出版社）</i></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习 Docker 技术，每看完一章或够写一篇文章的时候就上传一次. 这一篇讲容器技术。以下正文。。。&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yusank.github.io/categories/Docker/"/>
    
      <category term="读后笔记" scheme="http://yusank.github.io/categories/Docker/%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="http://yusank.github.io/tags/Docker/"/>
    
      <category term="读后笔记" scheme="http://yusank.github.io/tags/%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Goddbye 2016 and Hello 2017</title>
    <link href="http://yusank.github.io/%E5%86%8D%E8%A7%81%E4%BA%862016%EF%BC%8C%E4%BD%A0%E5%A5%BD2017.html/"/>
    <id>http://yusank.github.io/再见了2016，你好2017.html/</id>
    <published>2016-12-31T09:07:55.000Z</published>
    <updated>2016-12-31T09:07:56.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><p>突然想写一篇文章纪念一下我的2016，哪天看不顺眼的时候删。。。<br><a id="more"></a></p>
<h2 id="再见了2016，你好2017"><a href="#再见了2016，你好2017" class="headerlink" title="再见了2016，你好2017"></a>再见了2016，你好2017</h2><p>来点音乐吧，</p>
<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=186560&auto=0&height=66"></iframe><br>​    纵观过去的这一年，发生了很多我没有预料的到时事儿，不管是感情还是学习工作方面。</p>
<p>​    去年的今天我做了不少的计划，许了不少的愿，但是实现了几个没做到几个，现在我是真想不出来。从我现在的情况来看，2016过得并不是很糟糕，也许可以用过得还不错的这句话来形容。</p>
<p>​    寒假跟每年的寒假没有任何区别，玩儿吃喝，非要说有区别的话，我还是想不起来任何的区别【微笑】。3月份回学校，做了我人生第一次烫发，自我感觉还可以。生活还是一如既往，学习吃饭周末出去通宵。就这样，2016年也快一半了，6月初的出去旅游，给我们每个人一次难忘的回忆，那回忆如此的美好，甜蜜。然而好梦总是不长的，6月末，我听到了一个我最不想听的一个消息。以前一直以为如果真有这么一天，我会怎么怎么样。但是真的碰到了这个情况的时候，我不知道该干嘛了，不知道该为自己伤心还是为她开心，但是我不认为这就是最终结果。一个对我来说是一个不是很正常的暑假的开始了，除了一个月帮老爸跑腿开车以为，我脑子里只有一个人，也许这就是爱吧。但是我一直都只动嘴皮子不干实际性的，到目前我都很后悔这事儿。</p>
<p>​    暑假结束回到学校不到两个月，我遇到了思异，遇到了我的人生转折点。大学两年荒废过去的我终于见到一丁点曙光在远处向我招手，我不能再荒废下去了，我得努力，我得为以后找出路。就这样，我的几乎每一天都是要么在实习要么在去实习的路上度过，一直到现在，2016的最后一天。</p>
<p>​    这几个月，跟她关系越来越好，感觉已经离不开她了。每次见到到都是一种幸福满，遇到她是我大学生活发生的最幸运最幸福的事情，绝对没有之一。</p>
<p>​    时间总是过得很快，一年时间说长很长说短很短，依然记得去年的今天，但是又觉得是很久之前的事儿。再过几个小时，就得送2016了，在送它之前，我还是要好好的感谢2016，给我这么多的快乐的时光，给我了配家人配爱人的时间，谢谢你！！！</p>
<p>​    在这儿我不会许什么愿做什么计划，我只是静静的等2017的到来，静静地欢迎它，不管是到来的是哪一年，我只是希望陪我欢迎新一年的人，依然是她！</p>
<p>再见了2016，</p>
<p>​                你好2017.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;突然想写一篇文章纪念一下我的2016，哪天看不顺眼的时候删。。。&lt;br&gt;
    
    </summary>
    
      <category term="个人" scheme="http://yusank.github.io/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="乱写" scheme="http://yusank.github.io/tags/%E4%B9%B1%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>linux命令</title>
    <link href="http://yusank.github.io/linux%E5%91%BD%E4%BB%A4.html/"/>
    <id>http://yusank.github.io/linux命令.html/</id>
    <published>2016-12-28T05:13:13.000Z</published>
    <updated>2016-12-28T05:13:13.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><p>welcome to learn terminal command!!!<br><a id="more"></a></p>
<h1 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h1><h3 id="永！远！不！要！执！行！你！不！清！楚！在！干！啥！的！命！令！"><a href="#永！远！不！要！执！行！你！不！清！楚！在！干！啥！的！命！令！" class="headerlink" title="永！远！不！要！执！行！你！不！清！楚！在！干！啥！的！命！令！"></a>永！远！不！要！执！行！你！不！清！楚！在！干！啥！的！命！令！</h3><h2 id="实用性"><a href="#实用性" class="headerlink" title="实用性"></a>实用性</h2><pre class="line-numbers language-shell"><code class="language-shell">$ ls -l | sed '1d' | sort -n -k5 | awk '{printf "%15s %10s\n", $9,$5}'
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>按文件大小增序打印出当前目录下的文件名及其文件大小(单位字节）</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ history | awk '{print $2}' | sort | uniq -c | sort -rn | head -10
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>输出你最常用的十条命令</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ http POST http://localhost:4000/ < /<json文件路径>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>做测试的时候很有用的一个命令，需要下载http</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ brew install http
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-shell"><code class="language-shell">$ lsof -n -P -i TCP -s TCP:LISTEN

COMMAND  PID       USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
QQ       290 smartestee   33u  IPv4 0x2f3beaa58a62d73b      0t0  TCP 127.0.0.1:4300 (LISTEN)
QQ       290 smartestee   34u  IPv4 0x2f3beaa58c69673b      0t0  TCP 127.0.0.1:4301 (LISTEN)
idea    3257 smartestee  164u  IPv4 0x2f3beaa588d11e43      0t0  TCP 127.0.0.1:6942 (LISTEN)
idea    3257 smartestee  385u  IPv4 0x2f3beaa58c69316b      0t0  TCP 127.0.0.1:63342 (LISTEN)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看端口的使用情况</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ ps -ef
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看进程</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ kill  xxxx
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>端口冲突时，用此命令，关闭某个端口。用PID替换xxxx</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ history
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看历史命令记录</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ pwd
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当前位置</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ which xx
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>path位置，搭建环境的时候肯定会用得到</p>
<h3 id="Linux-文件系统命令"><a href="#Linux-文件系统命令" class="headerlink" title="Linux 文件系统命令"></a>Linux 文件系统命令</h3><p>修改问价拥有者</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ chgrp -R 组名 文件 / 目录
$ chown -R 账户名 文件 / 目录
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>修改文件权限</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ chmod
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>使用数字<ul>
<li>r：4, w：2, x：1</li>
<li>每种身份的权限的累加的。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-shell"><code class="language-shell">$ chmod 777 test
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><p>使用符号修改</p>
<ul>
<li><p>u: user, g: group, o: others, a: all</p>
</li>
<li><p>添加权限用+， 除去用-， 设置用=</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ chmod u=rwx, g=rw, o=r test
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-shell"><code class="language-shell">$ chmod a-x test
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-shell"><code class="language-shell">$ chmod go+r test
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​</p>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo !!
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>以root权限执行上一条命令（注意上一条命令的内容，以免发生意外）</p>
<p>例如：在Ubuntu 安装软件或插件的时候需要用到这个命令</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ sudo apt-get install nginx
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看和修改：</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ cat
$ more
$ less
$ head
$ tail

$ vi
$ vim

$ mkdir
$ touch
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><pre class="line-numbers language-shell"><code class="language-shell">$ git
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>先给出比较常用的</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ git add <一个或多个文件名(文件名之间是用空格，也可以是一个点，表示添加全部)>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-shell"><code class="language-shell">$ git commit -m "注释"
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>本地提交</p>
<pre class="line-numbers language-powershell"><code class="language-powershell">$ git checkout &lt;分支名或master>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>切换分支与master</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ git branch <分支名>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>新开一个分支</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ git merge <分支名>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>主分支与分支的合并</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ git push origin master
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>提交到github上</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ fuck
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>纠正命令行输入的错误，比手动改快，实用。</p>
<p>安装：</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ brew install thefuck
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h2><pre class="line-numbers language-shell"><code class="language-shell">$ cmatrix
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-shell"><code class="language-shell">$ telnet towel.blinkenlights.nl
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>telnet是基于Telnet协议的远程登录客户端程序,经常用来远程登录服务器.除此还可以用它来观看星球大战</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ fortune
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>随机输出名言或者笑话，</p>
<p>还有很多，有兴趣的可以通过这个链接去看：<a href="https://www.zhihu.com/question/20273259" target="_blank" rel="external">知乎</a></p>
<p>个人博客 <a href="http://aa.yusank.space/2016/12/28/linux%E5%91%BD%E4%BB%A4/" target="_blank" rel="external">yusank</a></p>
<p>比较牛逼的一个查找命令的网站：<a href="http://www.commandlinefu.com/commands/browse/sort-by-votes" target="_blank" rel="external">http://www.commandlinefu.com/commands/browse/sort-by-votes</a></p>
<p>每天都有更新各种命令组合</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;welcome to learn terminal command!!!&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yusank.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yusank.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Material 的配置</title>
    <link href="http://yusank.github.io/%20Material%20%E5%8E%9F%E8%B4%A8.html/"/>
    <id>http://yusank.github.io/ Material 原质.html/</id>
    <published>2016-12-18T06:14:14.000Z</published>
    <updated>2016-12-19T06:14:14.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script src="/assets/js/DPlayer.min.js"> </script><h1 id="Material-原质"><a href="#Material-原质" class="headerlink" title="Material 原质"></a>Material 原质</h1><p><a href="https://material.vss.im" target="_blank" rel="external">Material Theme</a></p>
<blockquote>
<p>Nature, Source</p>
<p>stay with light`s</p>
</blockquote>
<h2 id="Contents-目录"><a href="#Contents-目录" class="headerlink" title="Contents 目录"></a>Contents 目录</h2><ul>
<li><a href="#general-概括">General 概括</a></li>
<li><a href="#demo-演示">Demo 演示</a></li>
<li><a href="#quick-start-快速开始">Quick start 快速开始</a></li>
<li><a href="#docs-文档">Docs 文档</a></li>
<li><a href="#contributing-贡献">Contributing 贡献</a></li>
<li><a href="#license-许可证">License 许可证</a></li>
<li><a href="#render-渲染">Render 渲染</a></li>
<li><a href="https://material.vss.im/changelog/" target="_blank" rel="external">Changelog 开发日志</a></li>
</ul>
<h2 id="General-概括"><a href="#General-概括" class="headerlink" title="General 概括"></a>General 概括</h2><p><a href="https://viosey.com" target="_blank" rel="external"><img src="https://img.shields.io/badge/author-Viosey-blue.svg?style=flat-square" alt="Author"></a><br><a href=""><img src="https://img.shields.io/badge/version-1.2.4-green.svg?style=flat-square" alt="Version"></a><br><a href="https://hexo.io" target="_blank" rel="external"><img src="https://img.shields.io/badge/hexo-3.0+-green.svg?style=flat-square" alt="Hexo"></a><br><a href="https://travis-ci.org/viosey/hexo-theme-material" target="_blank" rel="external"><img src="https://img.shields.io/travis/viosey/hexo-theme-material.svg?style=flat-square" alt="Build Status"></a><br><a href="http://jq.qq.com/?_wv=1027&amp;k=40Vdy24" target="_blank" rel="external"><img src="https://img.shields.io/badge/QQ%20%E7%BE%A4-566308505-brightgreen.svg?style=flat-square" alt="QQ Group"></a></p>
<h2 id="Demo-演示"><a href="#Demo-演示" class="headerlink" title="Demo 演示"></a>Demo 演示</h2><p><a href="https://blog.viosey.com" target="_blank" rel="external">Viosey’s Blog</a></p>
<h2 id="Quick-start-快速开始"><a href="#Quick-start-快速开始" class="headerlink" title="Quick start 快速开始"></a>Quick start 快速开始</h2><p><a href="https://material.vss.im/en/start/#install-material" target="_blank" rel="external">Install Material</a>    </p>
<p><a href="https://material.vss.im/start/#install-material" target="_blank" rel="external">安装 Material</a></p>
<h2 id="Docs-文档"><a href="#Docs-文档" class="headerlink" title="Docs 文档"></a>Docs 文档</h2><p><a href="https://material.vss.im/en/" target="_blank" rel="external">Material Theme Docs</a></p>
<p><a href="https://material.vss.im" target="_blank" rel="external">Material 主题文档</a></p>
<blockquote>
<p><a href="https://github.com/viosey/material-theme-docs" target="_blank" rel="external">Docs Markdown Files</a></p>
</blockquote>
<h2 id="Contributing-贡献"><a href="#Contributing-贡献" class="headerlink" title="Contributing 贡献"></a>Contributing 贡献</h2><p>All kinds of contributions (enhancements, new features, documentation &amp; code improvements, issues &amp; bugs reporting) are welcome.</p>
<p>欢迎各种形式的贡献，包括但不限于优化，添加功能，文档 &amp; 代码的改进，问题和 bugs 的报告。期待您的 <code>Pull Request</code>。</p>
<h2 id="License-许可证"><a href="#License-许可证" class="headerlink" title="License 许可证"></a>License 许可证</h2><p><a href="https://github.com/viosey/hexo-theme-material/blob/master/LICENSE" target="_blank" rel="external"><img src="https://img.shields.io/github/license/viosey/hexo-theme-material.svg?style=flat-square" alt="license"></a></p>
<p>Open sourced under the GPL v3.0 license.</p>
<p>根据 GPL V3.0 许可证开源。</p>
<h2 id="Render-渲染"><a href="#Render-渲染" class="headerlink" title="Render 渲染"></a>Render 渲染</h2><p><img src="https://qiniu.viosey.com/img/Material-Phone-Render.png" alt=""></p>
<p><img src="https://qiniu.viosey.com/img/Materia-themel-overview-tiny.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Material-原质&quot;&gt;&lt;a href=&quot;#Material-
    
    </summary>
    
    
      <category term="Material" scheme="http://yusank.github.io/tags/Material/"/>
    
  </entry>
  
</feed>
