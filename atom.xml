<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><title type="text">Yusank`s Site</title><subtitle type="html">分享技术文章和个人博客。</subtitle><updated>2021-07-04T08:33:26+00:00</updated><id>https://yusank.github.io/</id><link rel="alternate" type="text/html" href="https://yusank.github.io/"/><link rel="self" type="application/atom+xml" href="https://yusank.github.io/atom.xml"/><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><generator uri="https://gohugo.io/" version="0.84.4">Hugo</generator><entry><title type="text">如何编写自己的第一个命令行工具</title><link rel="alternate" type="text/html" href="https://yusank.github.io/posts/go-cobra/"/><id>https://yusank.github.io/posts/go-cobra/</id><updated>2021-07-04T08:33:24+00:00</updated><published>2021-06-30T18:22:00+08:00</published><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><summary type="html">关于如何用 go 语言编写一个命令行工具。这里会基于 cobra 开源库进行开发。cobra 作为一个非常有名的命令行工具库，被很多开源项目……</summary><content type="html"><![CDATA[<p>关于如何用 go 语言编写一个命令行工具。这里会基于 <code>cobra</code> 开源库进行开发。<code>cobra</code> 作为一个非常有名的命令行工具库，被很多开源项目引入使用，很多命令行工具都能看到 <code>cobra</code> 的身影。<code>cobra</code> 提供一个完整的命令行的工具的所需的功能，包括命令定义、命令扩展、读取参数等。下面我们以开发一个命令行工具的流程一步步学习如何使用 <code>cobra</code> 开发一个自己的命令行工具。</p>
<h2 id="创建根命令">创建根命令</h2>
<p>我们项目暂且就叫 <code>myCmd</code>, 我们本地创建一个go项目就叫 <code>myCmd</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mkdir myCmd
$ <span class="nb">cd</span> myCmd
$ touch main.go
$ go mod init myCmd
</code></pre></td></tr></table>
</div>
</div><p>main.go</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>

	<span class="s">&#34;github.com/spf13/cobra&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
    <span class="c1">// 定义主命令
</span><span class="c1"></span>	<span class="nx">rootCmd</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">cobra</span><span class="p">.</span><span class="nx">Command</span><span class="p">{</span>
		<span class="nx">Use</span><span class="p">:</span>   <span class="s">&#34;myCmd&#34;</span><span class="p">,</span>
		<span class="nx">Short</span><span class="p">:</span> <span class="s">&#34;这里是对命令的简短介绍&#34;</span><span class="p">,</span>
		<span class="nx">Long</span><span class="p">:</span> <span class="s">`这里可以放对命令的详细介绍。
</span><span class="s">可以多行`</span><span class="p">,</span>
		<span class="nx">Example</span><span class="p">:</span> <span class="s">&#34;myCmd help&#34;</span><span class="p">,</span> <span class="c1">// 使用示例
</span><span class="c1"></span>        <span class="nx">Version</span><span class="p">:</span> <span class="s">&#34;v0.0.1&#34;</span><span class="p">,</span> <span class="c1">// 定义版本
</span><span class="c1"></span>
	<span class="p">}</span>

	<span class="nx">dirPath</span> <span class="kt">string</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 定义参数，即从命令行读取的参数变量
</span><span class="c1"></span>    <span class="c1">// 除了 PersistentFlags 外，也可以用 Flags()，区别是 前一个可以在其子命令也可以用，后一个不能。即PersistentFlags是一个全局的flag注册。
</span><span class="c1"></span>	<span class="nx">rootCmd</span><span class="p">.</span><span class="nf">PersistentFlags</span><span class="p">().</span><span class="nf">StringVarP</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dirPath</span><span class="p">,</span> <span class="s">&#34;dir&#34;</span><span class="p">,</span> <span class="s">&#34;d&#34;</span><span class="p">,</span> <span class="s">&#34;.&#34;</span><span class="p">,</span> <span class="s">&#34;文件路径&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rootCmd</span><span class="p">.</span><span class="nf">Execute</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这样我们就创建了一个属于的自己的命令，执行看一下效果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 直接执行,会打印 字段Long的值，</span>
➜./myCmd   
这里可以放对命令的详细介绍。
可以多行
<span class="c1"># 打印版本</span>
➜./myCmd -v
myCmd version v0.0.1
<span class="c1"># 输入未知 flag</span>
➜./myCmd -x
Error: unknown shorthand flag: <span class="s1">&#39;x&#39;</span> in -x
Usage:

Examples:
myCmd <span class="nb">help</span>

Flags:
  -d, --dir string   文件路径 <span class="o">(</span>default <span class="s2">&#34;.&#34;</span><span class="o">)</span>
  -h, --help         <span class="nb">help</span> <span class="k">for</span> myCmd
  -v, --version      version <span class="k">for</span> myCmd

2021/07/04 15:18:59 unknown shorthand flag: <span class="s1">&#39;x&#39;</span> in -x
</code></pre></td></tr></table>
</div>
</div><p>不难发现，版本处理，未知参数处理等情况 cobra已经做了相对完善的处理，我们不需要做太多的错误处理。</p>
<p>目前未知，我们的的命令只是定义了命令，并没有执行任何指令，下面我们添加一个简单的执行函数。<code>cobra.Command</code> 有很多参数可以定义执行函数的，我们以最常用的的 <code>Run</code>，<code>RunE</code> 为例，分别是不返回错误和返回错误的函数定义。</p>
<p>假如我们的主命令执行一个打印 d 参数传值的目录的信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// rootCmd
</span><span class="c1"></span><span class="nx">RunE</span><span class="p">:</span> <span class="nx">printDirInfo</span><span class="p">,</span>

<span class="cm">/*
</span><span class="cm">...
</span><span class="cm">*/</span> 

<span class="kd">func</span> <span class="nf">printDirInfo</span><span class="p">(</span><span class="nx">cmd</span> <span class="o">*</span><span class="nx">cobra</span><span class="p">.</span><span class="nx">Command</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">info</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Stat</span><span class="p">(</span><span class="nx">dirPath</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;name:%s, size:%d modTime:%v \n&#34;</span><span class="p">,</span> <span class="nx">info</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="nx">info</span><span class="p">.</span><span class="nf">Size</span><span class="p">(),</span> <span class="nx">info</span><span class="p">.</span><span class="nf">ModTime</span><span class="p">())</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>执行一下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 查看一下 main 文件的信息</span>
➜./myCmd -d main.go 
name:main.go, size:759 modTime:2021-07-04 15:26:43.311399368 +0800 CST 

<span class="c1"># 查看一个不存在的文件</span>
➜./myCmd -d main.go1
Error: stat main.go1: no such file or directory
Usage:
  myCmd <span class="o">[</span>flags<span class="o">]</span>

Examples:
myCmd <span class="nb">help</span>

Flags:
  -d, --dir string   命令执行目录 <span class="o">(</span>default <span class="s2">&#34;.&#34;</span><span class="o">)</span>
  -h, --help         <span class="nb">help</span> <span class="k">for</span> myCmd
  -v, --version      version <span class="k">for</span> myCmd

2021/07/04 15:30:01 stat main.go1: no such file or directory
<span class="c1"># 不仅打印出错误，如何使用命令也会同时打印出来</span>
</code></pre></td></tr></table>
</div>
</div><p>下面我们就添加我们的子命令。</p>
<h2 id="添加子命令">添加子命令</h2>
<p>我们现在添加一个子命令，这个子命令的功能是统计当前目录下的所有文件信息，我们就起名叫 <code>stat</code>。同时，为了方便全局变量的在不同包内读取，创建一个 <code>variable</code> 的目录，里面存放全局的一些变量，包内变量就放到各自包内。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">➜ mkdir stat
➜ mkdir variable
➜ touch stat/stat.go
➜ touch variable/variable.go
</code></pre></td></tr></table>
</div>
</div><p>下面是stat文件的内容。</p>
<p>stat.go</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">stat</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;myCmd/variable&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;path/filepath&#34;</span>

	<span class="s">&#34;github.com/spf13/cobra&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">StatCmd</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">cobra</span><span class="p">.</span><span class="nx">Command</span><span class="p">{</span>
		<span class="nx">Use</span><span class="p">:</span>   <span class="s">&#34;stat&#34;</span><span class="p">,</span>
		<span class="nx">Short</span><span class="p">:</span> <span class="s">&#34;统计目录&#34;</span><span class="p">,</span>
		<span class="nx">RunE</span><span class="p">:</span>  <span class="nx">statDir</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">isStatDir</span> <span class="kt">bool</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 这里使用 Flags 只在我这个命令内解析和读取
</span><span class="c1"></span>	<span class="nx">StatCmd</span><span class="p">.</span><span class="nf">Flags</span><span class="p">().</span><span class="nf">BoolVarP</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">isStatDir</span><span class="p">,</span> <span class="s">&#34;stat_dir&#34;</span><span class="p">,</span> <span class="s">&#34;s&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="s">&#34;是否统计目录信息&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">statDir</span><span class="p">(</span><span class="nx">cmd</span> <span class="o">*</span><span class="nx">cobra</span><span class="p">.</span><span class="nx">Command</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">filepath</span><span class="p">.</span><span class="nf">Walk</span><span class="p">(</span><span class="nx">variable</span><span class="p">.</span><span class="nx">DirPath</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">info</span> <span class="nx">os</span><span class="p">.</span><span class="nx">FileInfo</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">info</span><span class="p">.</span><span class="nf">IsDir</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">isStatDir</span> <span class="p">{</span>
			<span class="c1">// 不统计
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>

		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;path:%s, size:%d, modTime:%v&#34;</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">info</span><span class="p">.</span><span class="nf">Size</span><span class="p">(),</span> <span class="nx">info</span><span class="p">.</span><span class="nf">ModTime</span><span class="p">())</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">})</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后将该子命令注册的主命令下。</p>
<p>main.go</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;myCmd/stat&#34;</span>
	<span class="s">&#34;myCmd/variable&#34;</span>
	<span class="s">&#34;os&#34;</span>

	<span class="s">&#34;github.com/spf13/cobra&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">rootCmd</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">cobra</span><span class="p">.</span><span class="nx">Command</span><span class="p">{</span>
		<span class="nx">Use</span><span class="p">:</span>   <span class="s">&#34;myCmd&#34;</span><span class="p">,</span>
		<span class="nx">Short</span><span class="p">:</span> <span class="s">&#34;这里是对命令的简短介绍&#34;</span><span class="p">,</span>
		<span class="nx">Long</span><span class="p">:</span> <span class="s">`这里可以放对命令的详细介绍。
</span><span class="s">可以多行`</span><span class="p">,</span>
		<span class="nx">Example</span><span class="p">:</span> <span class="s">&#34;myCmd help&#34;</span><span class="p">,</span> <span class="c1">// 使用示例
</span><span class="c1"></span>		<span class="nx">Version</span><span class="p">:</span> <span class="nx">variable</span><span class="p">.</span><span class="nx">Version</span><span class="p">,</span> <span class="c1">// 全局变量常量都移到 variable 目录下
</span><span class="c1"></span>		<span class="nx">RunE</span><span class="p">:</span>    <span class="nx">printDirInfo</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">rootCmd</span><span class="p">.</span><span class="nf">PersistentFlags</span><span class="p">().</span><span class="nf">StringVarP</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">variable</span><span class="p">.</span><span class="nx">DirPath</span><span class="p">,</span> <span class="s">&#34;dir&#34;</span><span class="p">,</span> <span class="s">&#34;d&#34;</span><span class="p">,</span> <span class="s">&#34;.&#34;</span><span class="p">,</span> <span class="s">&#34;文件路径&#34;</span><span class="p">)</span>
    <span class="c1">// 注册命令
</span><span class="c1"></span>	<span class="nx">rootCmd</span><span class="p">.</span><span class="nf">AddCommand</span><span class="p">(</span><span class="nx">stat</span><span class="p">.</span><span class="nx">StatCmd</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">printDirInfo</span><span class="p">(</span><span class="nx">cmd</span> <span class="o">*</span><span class="nx">cobra</span><span class="p">.</span><span class="nx">Command</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">info</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Stat</span><span class="p">(</span><span class="nx">variable</span><span class="p">.</span><span class="nx">DirPath</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;name:%s, size:%d modTime:%v \n&#34;</span><span class="p">,</span> <span class="nx">info</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="nx">info</span><span class="p">.</span><span class="nf">Size</span><span class="p">(),</span> <span class="nx">info</span><span class="p">.</span><span class="nf">ModTime</span><span class="p">())</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rootCmd</span><span class="p">.</span><span class="nf">Execute</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>再次执行 <code>help</code> 查看我们的命令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">➜./myCmd -h
这里可以放对命令的详细介绍。
可以多行

Usage:
  myCmd <span class="o">[</span>flags<span class="o">]</span>
  myCmd <span class="o">[</span>command<span class="o">]</span>

Examples:
myCmd <span class="nb">help</span>

Available Commands:
  <span class="nb">help</span>        Help about any <span class="nb">command</span>
  stat        统计目录

Flags:
  -d, --dir string   文件路径 <span class="o">(</span>default <span class="s2">&#34;.&#34;</span><span class="o">)</span>
  -h, --help         <span class="nb">help</span> <span class="k">for</span> myCmd
  -v, --version      version <span class="k">for</span> myCmd

Use <span class="s2">&#34;myCmd [command] --help&#34;</span> <span class="k">for</span> more information about a command.

<span class="c1"># 查看子命令help</span>
➜./myCmd stat -h
统计目录

Usage:
  myCmd stat <span class="o">[</span>flags<span class="o">]</span>

Flags:
  -h, --help           <span class="nb">help</span> <span class="k">for</span> stat
  -s, --stat_dir       是否统计目录信息

Global Flags:
  -d, --dir string   文件路径 <span class="o">(</span>default <span class="s2">&#34;.&#34;</span><span class="o">)</span>

<span class="c1"># 统计</span>
➜./myCmd stat -d .
path:go.mod, size:61, modTime:2021-07-04 15:03:33.339495852 +0800 CST
path:go.sum, size:56568, modTime:2021-07-04 15:03:33.339185898 +0800 CST
path:main.go, size:929, modTime:2021-07-04 15:55:07.206300444 +0800 CST
path:myCmd, size:4344056, modTime:2021-07-04 16:01:12.930132286 +0800 CST
path:stat/stat.go, size:691, modTime:2021-07-04 16:01:09.353487727 +0800 CST
path:variable/variable.go, size:73, modTime:2021-07-04 15:48:18.345134258 +0800 CST
</code></pre></td></tr></table>
</div>
</div><p>不难发现，这个子命令可以无限嵌套，我们可以拥有二级三级子命令，能满足我们各种各样奇葩的需求，子命令可以复用其上级目录的 flag参数。</p>
<h2 id="自主更新">自主更新</h2>
<p>假如我们开发命令，已经发布到 GitHub 上，别人可以简单的 <code>go get</code> 命令就能安装使用我们的命令。但是我要是发布一个新版本，希望使用的人能知道我的命令工具有新版了而且要是能方便的更新到最新的版本是不是一个非常人性化的设计呢？</p>
<p>其实实现起来也不难，这里抛出个思路。假如我们命令每次执行的时候，我做一次版本检查（但是<strong>强烈不建议</strong>每次都检查，最好本地做一个上次检查时间的缓存，最多一天检查一次，否则用户体验非常不好），如果有新的版本我就提醒用户，甚至我可以检查的时候拉过来新版本的 feature 展现给用户，，然后提供一个 <code>update</code> 的子命令，自我更新，这体验是不是听起来就很不错呀。</p>
<p>至于 <code>update</code> 这个子命令实现也很简单，尝试执行一次 <code>go get -u &lt;myCmdRemoteURL&gt;</code>  即可，虽然看起来是对 <code>go get</code> 的一次封装，但是对于用户来说就很简单方便。</p>
<h2 id="小彩蛋">小彩蛋</h2>
<p>到这里我们一个小命令行工具也有模有样了，但是缺一个灵魂，是什么呢？</p>
<p>当然是</p>
<p>命令的炫酷的logo！！！</p>
<p>先看效果图：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 普通版本</span>
  __  __  __     __   _____   __  __   _____  
 <span class="p">|</span>  <span class="se">\/</span>  <span class="p">|</span> <span class="se">\ \ </span>  / /  / ____<span class="p">|</span> <span class="p">|</span>  <span class="se">\/</span>  <span class="p">|</span> <span class="p">|</span>  __ <span class="se">\ </span>
 <span class="p">|</span> <span class="se">\ </span> / <span class="p">|</span>  <span class="se">\ \_</span>/ /  <span class="p">|</span> <span class="p">|</span>      <span class="p">|</span> <span class="se">\ </span> / <span class="p">|</span> <span class="p">|</span> <span class="p">|</span>  <span class="p">|</span> <span class="p">|</span>
 <span class="p">|</span> <span class="p">|</span><span class="se">\/</span><span class="p">|</span> <span class="p">|</span>   <span class="se">\ </span>  /   <span class="p">|</span> <span class="p">|</span>      <span class="p">|</span> <span class="p">|</span><span class="se">\/</span><span class="p">|</span> <span class="p">|</span> <span class="p">|</span> <span class="p">|</span>  <span class="p">|</span> <span class="p">|</span>
 <span class="p">|</span> <span class="p">|</span>  <span class="p">|</span> <span class="p">|</span>    <span class="p">|</span> <span class="p">|</span>    <span class="p">|</span> <span class="p">|</span>____  <span class="p">|</span> <span class="p">|</span>  <span class="p">|</span> <span class="p">|</span> <span class="p">|</span> <span class="p">|</span>__<span class="p">|</span> <span class="p">|</span>
 <span class="p">|</span>_<span class="p">|</span>  <span class="p">|</span>_<span class="p">|</span>    <span class="p">|</span>_<span class="p">|</span>     <span class="se">\_</span>____<span class="p">|</span> <span class="p">|</span>_<span class="p">|</span>  <span class="p">|</span>_<span class="p">|</span> <span class="p">|</span>_____/ 
                                              
                                              
<span class="c1"># 斜体</span>
                                                                     
    /<span class="p">|</span>    //<span class="p">|</span> <span class="p">|</span> <span class="se">\\</span>    / /     //   <span class="o">)</span> <span class="o">)</span>     /<span class="p">|</span>    //<span class="p">|</span> <span class="p">|</span>     //    <span class="o">)</span> <span class="o">)</span> 
   //<span class="p">|</span>   // <span class="p">|</span> <span class="p">|</span>  <span class="se">\\</span>  / /     //           //<span class="p">|</span>   // <span class="p">|</span> <span class="p">|</span>    //    / /  
  // <span class="p">|</span>  //  <span class="p">|</span> <span class="p">|</span>   <span class="se">\\</span>/ /     //           // <span class="p">|</span>  //  <span class="p">|</span> <span class="p">|</span>   //    / /   
 //  <span class="p">|</span> //   <span class="p">|</span> <span class="p">|</span>    / /     //           //  <span class="p">|</span> //   <span class="p">|</span> <span class="p">|</span>  //    / /    
//   <span class="p">|</span>//    <span class="p">|</span> <span class="p">|</span>   / /     <span class="o">((</span>____/ /    //   <span class="p">|</span>//    <span class="p">|</span> <span class="p">|</span> //____/ /     

<span class="c1"># 夸张版本</span>
          _____                _____                    _____                    _____                    _____          
         /<span class="se">\ </span>   <span class="se">\ </span>             <span class="p">|</span><span class="se">\ </span>   <span class="se">\ </span>                 /<span class="se">\ </span>   <span class="se">\ </span>                 /<span class="se">\ </span>   <span class="se">\ </span>                 /<span class="se">\ </span>   <span class="se">\ </span>        
        /::<span class="se">\_</span>___<span class="se">\ </span>            <span class="p">|</span>:<span class="se">\_</span>___<span class="se">\ </span>               /::<span class="se">\ </span>   <span class="se">\ </span>               /::<span class="se">\_</span>___<span class="se">\ </span>               /::<span class="se">\ </span>   <span class="se">\ </span>       
       /::::<span class="p">|</span>   <span class="p">|</span>             <span class="p">|</span>::<span class="p">|</span>   <span class="p">|</span>               /::::<span class="se">\ </span>   <span class="se">\ </span>             /::::<span class="p">|</span>   <span class="p">|</span>               /::::<span class="se">\ </span>   <span class="se">\ </span>      
      /:::::<span class="p">|</span>   <span class="p">|</span>             <span class="p">|</span>::<span class="p">|</span>   <span class="p">|</span>              /::::::<span class="se">\ </span>   <span class="se">\ </span>           /:::::<span class="p">|</span>   <span class="p">|</span>              /::::::<span class="se">\ </span>   <span class="se">\ </span>     
     /::::::<span class="p">|</span>   <span class="p">|</span>             <span class="p">|</span>::<span class="p">|</span>   <span class="p">|</span>             /:::/<span class="se">\:</span>::<span class="se">\ </span>   <span class="se">\ </span>         /::::::<span class="p">|</span>   <span class="p">|</span>             /:::/<span class="se">\:</span>::<span class="se">\ </span>   <span class="se">\ </span>    
    /:::/<span class="p">|</span>::<span class="p">|</span>   <span class="p">|</span>             <span class="p">|</span>::<span class="p">|</span>   <span class="p">|</span>            /:::/  <span class="se">\:</span>::<span class="se">\ </span>   <span class="se">\ </span>       /:::/<span class="p">|</span>::<span class="p">|</span>   <span class="p">|</span>            /:::/  <span class="se">\:</span>::<span class="se">\ </span>   <span class="se">\ </span>   
   /:::/ <span class="p">|</span>::<span class="p">|</span>   <span class="p">|</span>             <span class="p">|</span>::<span class="p">|</span>   <span class="p">|</span>           /:::/    <span class="se">\:</span>::<span class="se">\ </span>   <span class="se">\ </span>     /:::/ <span class="p">|</span>::<span class="p">|</span>   <span class="p">|</span>           /:::/    <span class="se">\:</span>::<span class="se">\ </span>   <span class="se">\ </span>  
  /:::/  <span class="p">|</span>::<span class="p">|</span>___<span class="p">|</span>______       <span class="p">|</span>::<span class="p">|</span>___<span class="p">|</span>______    /:::/    / <span class="se">\:</span>::<span class="se">\ </span>   <span class="se">\ </span>   /:::/  <span class="p">|</span>::<span class="p">|</span>___<span class="p">|</span>______    /:::/    / <span class="se">\:</span>::<span class="se">\ </span>   <span class="se">\ </span> 
 /:::/   <span class="p">|</span>::::::::<span class="se">\ </span>   <span class="se">\ </span>     /::::::::<span class="se">\ </span>   <span class="se">\ </span> /:::/    /   <span class="se">\:</span>::<span class="se">\ </span>   <span class="se">\ </span> /:::/   <span class="p">|</span>::::::::<span class="se">\ </span>   <span class="se">\ </span> /:::/    /   <span class="se">\:</span>::<span class="se">\ </span>___<span class="se">\ </span>
/:::/    <span class="p">|</span>:::::::::<span class="se">\_</span>___<span class="se">\ </span>   /::::::::::<span class="se">\_</span>___<span class="se">\/</span>:::/____/     <span class="se">\:</span>::<span class="se">\_</span>___<span class="se">\/</span>:::/    <span class="p">|</span>:::::::::<span class="se">\_</span>___<span class="se">\/</span>:::/____/     <span class="se">\:</span>::<span class="p">|</span>    <span class="p">|</span>
<span class="se">\:</span>:/    / ~~~~~/:::/    /   /:::/~~~~/~~      <span class="se">\:</span>::<span class="se">\ </span>   <span class="se">\ </span>     <span class="se">\:</span>:/    /<span class="se">\:</span>:/    / ~~~~~/:::/    /<span class="se">\:</span>::<span class="se">\ </span>   <span class="se">\ </span>    /:::<span class="p">|</span>____<span class="p">|</span>
 <span class="se">\/</span>____/      /:::/    /   /:::/    /          <span class="se">\:</span>::<span class="se">\ </span>   <span class="se">\ </span>     <span class="se">\/</span>____/  <span class="se">\/</span>____/      /:::/    /  <span class="se">\:</span>::<span class="se">\ </span>   <span class="se">\ </span>  /:::/    / 
             /:::/    /   /:::/    /            <span class="se">\:</span>::<span class="se">\ </span>   <span class="se">\ </span>                         /:::/    /    <span class="se">\:</span>::<span class="se">\ </span>   <span class="se">\ </span>/:::/    /  
            /:::/    /   /:::/    /              <span class="se">\:</span>::<span class="se">\ </span>   <span class="se">\ </span>                       /:::/    /      <span class="se">\:</span>::<span class="se">\ </span>   /:::/    /   
           /:::/    /    <span class="se">\:</span>:/    /                <span class="se">\:</span>::<span class="se">\ </span>   <span class="se">\ </span>                     /:::/    /        <span class="se">\:</span>::<span class="se">\ </span> /:::/    /    
          /:::/    /      <span class="se">\/</span>____/                  <span class="se">\:</span>::<span class="se">\ </span>   <span class="se">\ </span>                   /:::/    /          <span class="se">\:</span>::<span class="se">\/</span>:::/    /     
         /:::/    /                                 <span class="se">\:</span>::<span class="se">\ </span>   <span class="se">\ </span>                 /:::/    /            <span class="se">\:</span>:::::/    /      
        /:::/    /                                   <span class="se">\:</span>::<span class="se">\_</span>___<span class="se">\ </span>               /:::/    /              <span class="se">\:</span>:::/    /       
        <span class="se">\:</span>:/    /                                     <span class="se">\:</span>:/    /                <span class="se">\:</span>:/    /                <span class="se">\:</span>:/____/        
         <span class="se">\/</span>____/                                       <span class="se">\/</span>____/                  <span class="se">\/</span>____/                  ~~              
                                                                                                                         
</code></pre></td></tr></table>
</div>
</div><p>我随机选了几个作为演示，<a href="https://www.colorschemer.com/ascii-art-generator">点击这里跳转</a>制作自己工具的logo，然后再主命令注册一个 <code>PreRun</code> 的函数，在该函数内打印我们的logo。这样在主逻辑执行前会打印我们的logo，辨识度一下子提高很多。</p>
<p>实际效果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">➜./myCmd -d main.go 
 __  __  __     __   _____   __  __   _____  
<span class="p">|</span>  <span class="se">\/</span>  <span class="p">|</span> <span class="se">\ \ </span>  / /  / ____<span class="p">|</span> <span class="p">|</span>  <span class="se">\/</span>  <span class="p">|</span> <span class="p">|</span>  __ <span class="se">\ </span>
<span class="p">|</span> <span class="se">\ </span> / <span class="p">|</span>  <span class="se">\ \_</span>/ /  <span class="p">|</span> <span class="p">|</span>      <span class="p">|</span> <span class="se">\ </span> / <span class="p">|</span> <span class="p">|</span> <span class="p">|</span>  <span class="p">|</span> <span class="p">|</span>
<span class="p">|</span> <span class="p">|</span><span class="se">\/</span><span class="p">|</span> <span class="p">|</span>   <span class="se">\ </span>  /   <span class="p">|</span> <span class="p">|</span>      <span class="p">|</span> <span class="p">|</span><span class="se">\/</span><span class="p">|</span> <span class="p">|</span> <span class="p">|</span> <span class="p">|</span>  <span class="p">|</span> <span class="p">|</span>
<span class="p">|</span> <span class="p">|</span>  <span class="p">|</span> <span class="p">|</span>    <span class="p">|</span> <span class="p">|</span>    <span class="p">|</span> <span class="p">|</span>____  <span class="p">|</span> <span class="p">|</span>  <span class="p">|</span> <span class="p">|</span> <span class="p">|</span> <span class="p">|</span>__<span class="p">|</span> <span class="p">|</span>
<span class="p">|</span>_<span class="p">|</span>  <span class="p">|</span>_<span class="p">|</span>    <span class="p">|</span>_<span class="p">|</span>     <span class="se">\_</span>____<span class="p">|</span> <span class="p">|</span>_<span class="p">|</span>  <span class="p">|</span>_<span class="p">|</span> <span class="p">|</span>_____/ 
   
name:main.go, size:1320 modTime:2021-07-04 16:28:51.339520282 +0800 CST 
</code></pre></td></tr></table>
</div>
</div><p>暂且就这么多，感谢 <code>spf13/cobra</code> 的作者，提供这么高质量的开源库。</p>
]]></content><category scheme="https://yusank.github.io/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术"/></entry><entry><title type="text">Go-Micro 中使用Nacos</title><link rel="alternate" type="text/html" href="https://yusank.github.io/posts/use-nacos-with-go-micro/"/><id>https://yusank.github.io/posts/use-nacos-with-go-micro/</id><updated>2021-07-04T08:33:24+00:00</updated><published>2021-06-23T18:22:00+08:00</published><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><summary type="html">go-micro 作为比较流行的微服务框架，其良好的接口设计为后期扩展使用带来了非常好的便利性。本文章主要讲在 go-micro 中用 nacos 作为服务注册中心和……</summary><content type="html"><![CDATA[<p><code>go-micro</code> 作为比较流行的微服务框架，其良好的接口设计为后期扩展使用带来了非常好的便利性。本文章主要讲在 <code>go-micro</code> 中用 <code>nacos</code> 作为服务注册中心和配置中心。</p>
<h2 id="注册中心">注册中心</h2>
<p>先看一下 <code>go-micro</code> 定义的服务注册接口。</p>
<p>registry.go</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 服务注册接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Registry</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// 初始化
</span><span class="c1"></span>    <span class="nf">Init</span><span class="p">(</span><span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="kt">error</span>
    <span class="c1">// 返回可选参数
</span><span class="c1"></span>    <span class="nf">Options</span><span class="p">()</span> <span class="nx">Options</span>
    <span class="c1">// 服务注册
</span><span class="c1"></span>    <span class="nf">Register</span><span class="p">(</span><span class="o">*</span><span class="nx">Service</span><span class="p">,</span> <span class="o">...</span><span class="nx">RegisterOption</span><span class="p">)</span> <span class="kt">error</span>
    <span class="c1">// 服务注销
</span><span class="c1"></span>    <span class="nf">Deregister</span><span class="p">(</span><span class="o">*</span><span class="nx">Service</span><span class="p">,</span> <span class="o">...</span><span class="nx">DeregisterOption</span><span class="p">)</span> <span class="kt">error</span>
    <span class="c1">// 查询服务
</span><span class="c1"></span>    <span class="nf">GetService</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="o">...</span><span class="nx">GetOption</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">Service</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="c1">// 列出服务
</span><span class="c1"></span>    <span class="nf">ListServices</span><span class="p">(</span><span class="o">...</span><span class="nx">ListOption</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">Service</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="c1">// 监听服务
</span><span class="c1"></span>    <span class="nf">Watch</span><span class="p">(</span><span class="o">...</span><span class="nx">WatchOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">Watcher</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>只要基于任意一个服务注册服务实现以上接口，即可在 <code>go-micro</code> 中作为注册中心使用。假如我用一个 <code>customRegistry</code> 实现接口后，在 <code>go-micro</code> 初始化的时候或服务启动时候通过启动参数指定实现接口的接口的 <code>String() string</code>方法的返回值接口。</p>
<p>如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 假如该结构体已实现 Registry 接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">customRegistry</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">customRegistry</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&#34;custom&#34;</span>
<span class="p">}</span>

<span class="c1">// 代码中指定
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">micro</span><span class="p">.</span><span class="nf">NewService</span><span class="p">(</span><span class="nx">micro</span><span class="p">.</span><span class="nf">Registry</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">customRegistry</span><span class="p">{}))</span>
<span class="p">}</span>

<span class="c1">// 启动参数指定
</span><span class="c1"></span><span class="p">.</span><span class="o">/</span><span class="nx">myApp</span> <span class="o">--</span> <span class="nx">registry</span> <span class="nx">custom</span>

</code></pre></td></tr></table>
</div>
</div><p>如此一看，发现非常方便和好扩展，接下来贴出如何使用nacos 实现该 <code>Registry</code> 接口。</p>
<p>直接列出关键代码块：</p>
<p>registry.go</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">
<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;errors&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;net&#34;</span>
    <span class="s">&#34;strconv&#34;</span>
    <span class="s">&#34;time&#34;</span>

    <span class="s">&#34;github.com/asim/go-micro/v3/cmd&#34;</span>

    <span class="s">&#34;github.com/asim/go-micro/v3/registry&#34;</span>
    <span class="s">&#34;github.com/nacos-group/nacos-sdk-go/v2/clients&#34;</span>
    <span class="s">&#34;github.com/nacos-group/nacos-sdk-go/v2/clients/naming_client&#34;</span>
    <span class="s">&#34;github.com/nacos-group/nacos-sdk-go/v2/common/constant&#34;</span>
    <span class="s">&#34;github.com/nacos-group/nacos-sdk-go/v2/common/logger&#34;</span>
    <span class="s">&#34;github.com/nacos-group/nacos-sdk-go/v2/vo&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">nacosRegistry</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// nacos sdk 的client
</span><span class="c1"></span>    <span class="nx">client</span> <span class="nx">naming_client</span><span class="p">.</span><span class="nx">INamingClient</span>
    <span class="c1">// 可选参数，初始化的时候可以通过 registry.Option 方法指定配置
</span><span class="c1"></span>    <span class="nx">opts</span>   <span class="nx">registry</span><span class="p">.</span><span class="nx">Options</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 设置为默认配置
</span><span class="c1"></span>    <span class="nx">cmd</span><span class="p">.</span><span class="nx">DefaultRegistries</span><span class="p">[</span><span class="s">&#34;nacos&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">NewRegistry</span>
<span class="p">}</span>

<span class="c1">// NewRegistry NewRegistry
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewRegistry</span><span class="p">(</span><span class="nx">opts</span> <span class="o">...</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Option</span><span class="p">)</span> <span class="nx">registry</span><span class="p">.</span><span class="nx">Registry</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">nacosRegistry</span><span class="p">{</span>
        <span class="nx">opts</span><span class="p">:</span> <span class="nx">registry</span><span class="p">.</span><span class="nx">Options</span><span class="p">{},</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">configure</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>

<span class="c1">// 这个方法总结下来就是干了一件事：配置初始化
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">configure</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">nacosRegistry</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Option</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">// set opts
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">o</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
        <span class="nf">o</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">n</span><span class="p">.</span><span class="nx">opts</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">clientConfig</span> <span class="o">:=</span> <span class="nx">constant</span><span class="p">.</span><span class="nx">ClientConfig</span><span class="p">{}</span>
    <span class="nx">serverConfigs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">constant</span><span class="p">.</span><span class="nx">ServerConfig</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nx">contextPath</span> <span class="o">:=</span> <span class="s">&#34;/nacos&#34;</span>

    <span class="nx">cfg</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">Context</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="nx">configKey</span><span class="p">{}).(</span><span class="nx">constant</span><span class="p">.</span><span class="nx">ClientConfig</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">clientConfig</span> <span class="p">=</span> <span class="nx">cfg</span>
    <span class="p">}</span>
    <span class="nx">addrs</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">Context</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="nx">addressKey</span><span class="p">{}).([]</span><span class="kt">string</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">addrs</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;127.0.0.1:8848&#34;</span><span class="p">}</span> <span class="c1">// 默认连接本地
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">addr</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">addrs</span> <span class="p">{</span>
        <span class="c1">// check we have a port
</span><span class="c1"></span>        <span class="nx">host</span><span class="p">,</span> <span class="nx">port</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">SplitHostPort</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">err</span>
        <span class="p">}</span>

        <span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseUint</span><span class="p">(</span><span class="nx">port</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">err</span>
        <span class="p">}</span>

        <span class="nx">serverConfigs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">serverConfigs</span><span class="p">,</span> <span class="nx">constant</span><span class="p">.</span><span class="nx">ServerConfig</span><span class="p">{</span>
            <span class="c1">// Scheme:      &#34;go.micro&#34;,
</span><span class="c1"></span>            <span class="nx">IpAddr</span><span class="p">:</span>      <span class="nx">host</span><span class="p">,</span>
            <span class="nx">Port</span><span class="p">:</span>        <span class="nx">p</span><span class="p">,</span>
            <span class="nx">ContextPath</span><span class="p">:</span> <span class="nx">contextPath</span><span class="p">,</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">Timeout</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">n</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">Timeout</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">1</span>
    <span class="p">}</span>

    <span class="nx">clientConfig</span><span class="p">.</span><span class="nx">TimeoutMs</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">Timeout</span><span class="p">.</span><span class="nf">Milliseconds</span><span class="p">())</span>
    <span class="c1">// 创建客户端
</span><span class="c1"></span>    <span class="nx">client</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">clients</span><span class="p">.</span><span class="nf">CreateNamingClient</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
        <span class="nx">constant</span><span class="p">.</span><span class="nx">KEY_SERVER_CONFIGS</span><span class="p">:</span> <span class="nx">serverConfigs</span><span class="p">,</span>
        <span class="nx">constant</span><span class="p">.</span><span class="nx">KEY_CLIENT_CONFIG</span><span class="p">:</span>  <span class="nx">clientConfig</span><span class="p">,</span>
    <span class="p">})</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="nx">n</span><span class="p">.</span><span class="nx">client</span> <span class="p">=</span> <span class="nx">client</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">nacosRegistry</span><span class="p">)</span> <span class="nf">Init</span><span class="p">(</span><span class="nx">opts</span> <span class="o">...</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Option</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">_</span> <span class="p">=</span> <span class="nf">configure</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">nacosRegistry</span><span class="p">)</span> <span class="nf">Options</span><span class="p">()</span> <span class="nx">registry</span><span class="p">.</span><span class="nx">Options</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">n</span><span class="p">.</span><span class="nx">opts</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">nacosRegistry</span><span class="p">)</span> <span class="nf">Register</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Service</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">registry</span><span class="p">.</span><span class="nx">RegisterOption</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">options</span> <span class="nx">registry</span><span class="p">.</span><span class="nx">RegisterOptions</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">o</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
        <span class="nf">o</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">options</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">withContext</span> <span class="o">:=</span> <span class="kc">false</span>
    <span class="c1">// 处理参数
</span><span class="c1"></span>    <span class="nx">param</span> <span class="o">:=</span> <span class="nx">vo</span><span class="p">.</span><span class="nx">RegisterInstanceParam</span><span class="p">{}</span>
    <span class="k">if</span> <span class="nx">options</span><span class="p">.</span><span class="nx">Context</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">options</span><span class="p">.</span><span class="nx">Context</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="s">&#34;register_instance_param&#34;</span><span class="p">).(</span><span class="nx">vo</span><span class="p">.</span><span class="nx">RegisterInstanceParam</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
            <span class="nx">param</span> <span class="p">=</span> <span class="nx">p</span>
            <span class="nx">withContext</span> <span class="p">=</span> <span class="nx">ok</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">withContext</span> <span class="p">{</span>
        <span class="nx">host</span><span class="p">,</span> <span class="nx">port</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">getNodeIPPort</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">err</span>
        <span class="p">}</span>
        <span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Metadata</span><span class="p">[</span><span class="s">&#34;version&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Version</span>
        <span class="nx">param</span><span class="p">.</span><span class="nx">Ip</span> <span class="p">=</span> <span class="nx">host</span>
        <span class="nx">param</span><span class="p">.</span><span class="nx">Port</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">port</span><span class="p">)</span>
        <span class="nx">param</span><span class="p">.</span><span class="nx">Metadata</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Metadata</span>
        <span class="nx">param</span><span class="p">.</span><span class="nx">ServiceName</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Name</span>
        <span class="nx">param</span><span class="p">.</span><span class="nx">Enable</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="nx">param</span><span class="p">.</span><span class="nx">Healthy</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="nx">param</span><span class="p">.</span><span class="nx">Weight</span> <span class="p">=</span> <span class="mf">1.0</span>
        <span class="nx">param</span><span class="p">.</span><span class="nx">Ephemeral</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="c1">// 注册节点
</span><span class="c1"></span>    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">RegisterInstance</span><span class="p">(</span><span class="nx">param</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">nacosRegistry</span><span class="p">)</span> <span class="nf">Deregister</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Service</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">registry</span><span class="p">.</span><span class="nx">DeregisterOption</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">options</span> <span class="nx">registry</span><span class="p">.</span><span class="nx">DeregisterOptions</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">o</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
        <span class="nf">o</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">options</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">withContext</span> <span class="o">:=</span> <span class="kc">false</span>
    <span class="nx">param</span> <span class="o">:=</span> <span class="nx">vo</span><span class="p">.</span><span class="nx">DeregisterInstanceParam</span><span class="p">{}</span>
    <span class="k">if</span> <span class="nx">options</span><span class="p">.</span><span class="nx">Context</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">options</span><span class="p">.</span><span class="nx">Context</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="s">&#34;deregister_instance_param&#34;</span><span class="p">).(</span><span class="nx">vo</span><span class="p">.</span><span class="nx">DeregisterInstanceParam</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
            <span class="nx">param</span> <span class="p">=</span> <span class="nx">p</span>
            <span class="nx">withContext</span> <span class="p">=</span> <span class="nx">ok</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">withContext</span> <span class="p">{</span>
        <span class="nx">host</span><span class="p">,</span> <span class="nx">port</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">getNodeIPPort</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">err</span>
        <span class="p">}</span>
        <span class="nx">param</span><span class="p">.</span><span class="nx">Ip</span> <span class="p">=</span> <span class="nx">host</span>
        <span class="nx">param</span><span class="p">.</span><span class="nx">Port</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">port</span><span class="p">)</span>
        <span class="nx">param</span><span class="p">.</span><span class="nx">ServiceName</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Name</span>
    <span class="p">}</span>

    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">DeregisterInstance</span><span class="p">(</span><span class="nx">param</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">nacosRegistry</span><span class="p">)</span> <span class="nf">GetService</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">registry</span><span class="p">.</span><span class="nx">GetOption</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Service</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">options</span> <span class="nx">registry</span><span class="p">.</span><span class="nx">GetOptions</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">o</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
        <span class="nf">o</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">options</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">withContext</span> <span class="o">:=</span> <span class="kc">false</span>
    <span class="nx">param</span> <span class="o">:=</span> <span class="nx">vo</span><span class="p">.</span><span class="nx">GetServiceParam</span><span class="p">{}</span>
    <span class="k">if</span> <span class="nx">options</span><span class="p">.</span><span class="nx">Context</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 可以通过context传参
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">options</span><span class="p">.</span><span class="nx">Context</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="s">&#34;select_instances_param&#34;</span><span class="p">).(</span><span class="nx">vo</span><span class="p">.</span><span class="nx">GetServiceParam</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
            <span class="nx">param</span> <span class="p">=</span> <span class="nx">p</span>
            <span class="nx">withContext</span> <span class="p">=</span> <span class="nx">ok</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">withContext</span> <span class="p">{</span>
        <span class="nx">param</span><span class="p">.</span><span class="nx">ServiceName</span> <span class="p">=</span> <span class="nx">name</span>
    <span class="p">}</span>
    <span class="nx">service</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">GetService</span><span class="p">(</span><span class="nx">param</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="nx">services</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Service</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">service</span><span class="p">.</span><span class="nx">Hosts</span> <span class="p">{</span>
        <span class="c1">//log.Printf(&#34;%+v\n&#34;, v)
</span><span class="c1"></span>        <span class="c1">// 跳过不正常的节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nx">v</span><span class="p">.</span><span class="nx">Healthy</span> <span class="o">||</span> <span class="p">!</span><span class="nx">v</span><span class="p">.</span><span class="nx">Enable</span> <span class="o">||</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Weight</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>

        <span class="nx">nodes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="nx">nodes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nodes</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Node</span><span class="p">{</span>
            <span class="nx">Id</span><span class="p">:</span>       <span class="nx">v</span><span class="p">.</span><span class="nx">InstanceId</span><span class="p">,</span>
            <span class="nx">Address</span><span class="p">:</span>  <span class="nx">net</span><span class="p">.</span><span class="nf">JoinHostPort</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Ip</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Port</span><span class="p">)),</span>
            <span class="nx">Metadata</span><span class="p">:</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">,</span>
        <span class="p">})</span>
        <span class="nx">s</span> <span class="o">:=</span> <span class="nx">registry</span><span class="p">.</span><span class="nx">Service</span><span class="p">{</span>
            <span class="nx">Name</span><span class="p">:</span>     <span class="nx">v</span><span class="p">.</span><span class="nx">ServiceName</span><span class="p">,</span>
            <span class="nx">Version</span><span class="p">:</span>  <span class="nx">v</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">[</span><span class="s">&#34;version&#34;</span><span class="p">],</span>
            <span class="nx">Metadata</span><span class="p">:</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">,</span>
            <span class="nx">Nodes</span><span class="p">:</span>    <span class="nx">nodes</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="nx">services</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">services</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">services</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">nacosRegistry</span><span class="p">)</span> <span class="nf">ListServices</span><span class="p">(</span><span class="nx">opts</span> <span class="o">...</span><span class="nx">registry</span><span class="p">.</span><span class="nx">ListOption</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Service</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">options</span> <span class="nx">registry</span><span class="p">.</span><span class="nx">ListOptions</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">o</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
        <span class="nf">o</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">options</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">withContext</span> <span class="o">:=</span> <span class="kc">false</span>
    <span class="nx">param</span> <span class="o">:=</span> <span class="nx">vo</span><span class="p">.</span><span class="nx">GetAllServiceInfoParam</span><span class="p">{}</span>
    <span class="k">if</span> <span class="nx">options</span><span class="p">.</span><span class="nx">Context</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">options</span><span class="p">.</span><span class="nx">Context</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="s">&#34;get_all_service_info_param&#34;</span><span class="p">).(</span><span class="nx">vo</span><span class="p">.</span><span class="nx">GetAllServiceInfoParam</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
            <span class="nx">param</span> <span class="p">=</span> <span class="nx">p</span>
            <span class="nx">withContext</span> <span class="p">=</span> <span class="nx">ok</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">withContext</span> <span class="p">{</span>
        <span class="nx">services</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">GetAllServicesInfo</span><span class="p">(</span><span class="nx">param</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
        <span class="p">}</span>
        <span class="nx">param</span><span class="p">.</span><span class="nx">PageNo</span> <span class="p">=</span> <span class="mi">1</span>
        <span class="nx">param</span><span class="p">.</span><span class="nx">PageSize</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">services</span><span class="p">.</span><span class="nx">Count</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">services</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">GetAllServicesInfo</span><span class="p">(</span><span class="nx">param</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">registryServices</span> <span class="p">[]</span><span class="o">*</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Service</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">services</span><span class="p">.</span><span class="nx">Doms</span> <span class="p">{</span>
        <span class="nx">registryServices</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">registryServices</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Service</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="nx">v</span><span class="p">})</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">registryServices</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">nacosRegistry</span><span class="p">)</span> <span class="nf">Watch</span><span class="p">(</span><span class="nx">opts</span> <span class="o">...</span><span class="nx">registry</span><span class="p">.</span><span class="nx">WatchOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Watcher</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">newWatcher</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">nacosRegistry</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&#34;nacos&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">getNodeIPPort</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Service</span><span class="p">)</span> <span class="p">(</span><span class="nx">host</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">port</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;you must deregister at least one node&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">node</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nx">host</span><span class="p">,</span> <span class="nx">pt</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">SplitHostPort</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="nx">port</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">pt</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>watcher.go 是监听服务的逻辑：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">
<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;log&#34;</span>
    <span class="s">&#34;net&#34;</span>
    <span class="s">&#34;reflect&#34;</span>
    <span class="s">&#34;sync&#34;</span>

    <span class="s">&#34;github.com/asim/go-micro/v3/logger&#34;</span>
    <span class="s">&#34;github.com/asim/go-micro/v3/registry&#34;</span>
    <span class="s">&#34;github.com/nacos-group/nacos-sdk-go/v2/model&#34;</span>
    <span class="s">&#34;github.com/nacos-group/nacos-sdk-go/v2/vo&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">watcher</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">n</span>  <span class="o">*</span><span class="nx">nacosRegistry</span> <span class="c1">// 注册实现
</span><span class="c1"></span>    <span class="nx">wo</span> <span class="nx">registry</span><span class="p">.</span><span class="nx">WatchOptions</span> <span class="c1">// 监听option
</span><span class="c1"></span>
    <span class="nx">next</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Result</span> <span class="c1">// 通过channel传递数据
</span><span class="c1"></span>    <span class="nx">exit</span> <span class="kd">chan</span> <span class="kt">bool</span> <span class="c1">// 退出channel
</span><span class="c1"></span>
    <span class="c1">// 在内存中缓存数据并定时维护
</span><span class="c1"></span>    <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
    <span class="nx">services</span>      <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="o">*</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Service</span>
    <span class="nx">cacheServices</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="nx">model</span><span class="p">.</span><span class="nx">Instance</span>
    <span class="nx">param</span>         <span class="o">*</span><span class="nx">vo</span><span class="p">.</span><span class="nx">SubscribeParam</span>
    <span class="nx">Doms</span>          <span class="p">[]</span><span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newWatcher</span><span class="p">(</span><span class="nx">nr</span> <span class="o">*</span><span class="nx">nacosRegistry</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">registry</span><span class="p">.</span><span class="nx">WatchOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Watcher</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">wo</span> <span class="nx">registry</span><span class="p">.</span><span class="nx">WatchOptions</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">o</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
        <span class="nf">o</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wo</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">nw</span> <span class="o">:=</span> <span class="nx">watcher</span><span class="p">{</span>
        <span class="nx">n</span><span class="p">:</span>             <span class="nx">nr</span><span class="p">,</span>
        <span class="nx">wo</span><span class="p">:</span>            <span class="nx">wo</span><span class="p">,</span>
        <span class="nx">exit</span><span class="p">:</span>          <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">),</span>
        <span class="nx">next</span><span class="p">:</span>          <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Result</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
        <span class="nx">services</span><span class="p">:</span>      <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="o">*</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Service</span><span class="p">),</span>
        <span class="nx">cacheServices</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="nx">model</span><span class="p">.</span><span class="nx">Instance</span><span class="p">),</span>
        <span class="nx">param</span><span class="p">:</span>         <span class="nb">new</span><span class="p">(</span><span class="nx">vo</span><span class="p">.</span><span class="nx">SubscribeParam</span><span class="p">),</span>
        <span class="nx">Doms</span><span class="p">:</span>          <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="nx">withContext</span> <span class="o">:=</span> <span class="kc">false</span>
    <span class="k">if</span> <span class="nx">wo</span><span class="p">.</span><span class="nx">Context</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">wo</span><span class="p">.</span><span class="nx">Context</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="s">&#34;subscribe_param&#34;</span><span class="p">).(</span><span class="nx">vo</span><span class="p">.</span><span class="nx">SubscribeParam</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
            <span class="nx">nw</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">p</span>
            <span class="nx">withContext</span> <span class="p">=</span> <span class="nx">ok</span>
            <span class="nx">nw</span><span class="p">.</span><span class="nx">param</span><span class="p">.</span><span class="nx">SubscribeCallback</span> <span class="p">=</span> <span class="nx">nw</span><span class="p">.</span><span class="nx">callBackHandle</span>
            <span class="k">go</span> <span class="nx">nr</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">Subscribe</span><span class="p">(</span><span class="nx">nw</span><span class="p">.</span><span class="nx">param</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">withContext</span> <span class="p">{</span>
        <span class="nx">param</span> <span class="o">:=</span> <span class="nx">vo</span><span class="p">.</span><span class="nx">GetAllServiceInfoParam</span><span class="p">{}</span>
        <span class="nx">services</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">nr</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">GetAllServicesInfo</span><span class="p">(</span><span class="nx">param</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
        <span class="p">}</span>
        <span class="nx">param</span><span class="p">.</span><span class="nx">PageNo</span> <span class="p">=</span> <span class="mi">1</span>
        <span class="nx">param</span><span class="p">.</span><span class="nx">PageSize</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">services</span><span class="p">.</span><span class="nx">Count</span><span class="p">)</span>
        <span class="nx">services</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">nr</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">GetAllServicesInfo</span><span class="p">(</span><span class="nx">param</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
        <span class="p">}</span>
        <span class="nx">nw</span><span class="p">.</span><span class="nx">Doms</span> <span class="p">=</span> <span class="nx">services</span><span class="p">.</span><span class="nx">Doms</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nw</span><span class="p">.</span><span class="nx">Doms</span> <span class="p">{</span>
            <span class="nx">param</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">vo</span><span class="p">.</span><span class="nx">SubscribeParam</span><span class="p">{</span>
                <span class="nx">ServiceName</span><span class="p">:</span>       <span class="nx">v</span><span class="p">,</span>
                <span class="nx">SubscribeCallback</span><span class="p">:</span> <span class="nx">nw</span><span class="p">.</span><span class="nx">callBackHandle</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">go</span> <span class="nx">nr</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">Subscribe</span><span class="p">(</span><span class="nx">param</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">nw</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// callBackHandle 回调函数注册到nacosSDK内，监听的服务有变化时 会被调用
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">nw</span> <span class="o">*</span><span class="nx">watcher</span><span class="p">)</span> <span class="nf">callBackHandle</span><span class="p">(</span><span class="nx">services</span> <span class="p">[]</span><span class="nx">model</span><span class="p">.</span><span class="nx">Instance</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">logger</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="s">&#34;nacos watcher call back handle error:%v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">serviceName</span> <span class="o">:=</span> <span class="nx">services</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">ServiceName</span>

    <span class="k">if</span> <span class="nx">nw</span><span class="p">.</span><span class="nx">cacheServices</span><span class="p">[</span><span class="nx">serviceName</span><span class="p">]</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>

        <span class="nx">nw</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
        <span class="nx">nw</span><span class="p">.</span><span class="nx">cacheServices</span><span class="p">[</span><span class="nx">serviceName</span><span class="p">]</span> <span class="p">=</span> <span class="nx">services</span>
        <span class="nx">nw</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">services</span> <span class="p">{</span>
            <span class="nx">nw</span><span class="p">.</span><span class="nx">next</span> <span class="o">&lt;-</span> <span class="o">&amp;</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Result</span><span class="p">{</span><span class="nx">Action</span><span class="p">:</span> <span class="s">&#34;create&#34;</span><span class="p">,</span> <span class="nx">Service</span><span class="p">:</span> <span class="nf">buildRegistryService</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">)}</span>
            <span class="k">return</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">subscribeService</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">services</span> <span class="p">{</span>
            <span class="nx">create</span> <span class="o">:=</span> <span class="kc">true</span>
            <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">cacheService</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nw</span><span class="p">.</span><span class="nx">cacheServices</span><span class="p">[</span><span class="nx">serviceName</span><span class="p">]</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nx">subscribeService</span><span class="p">.</span><span class="nx">InstanceId</span> <span class="o">==</span> <span class="nx">cacheService</span><span class="p">.</span><span class="nx">InstanceId</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">!</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">subscribeService</span><span class="p">,</span> <span class="nx">cacheService</span><span class="p">)</span> <span class="p">{</span>
                        <span class="c1">//update instance
</span><span class="c1"></span>                        <span class="nx">nw</span><span class="p">.</span><span class="nx">next</span> <span class="o">&lt;-</span> <span class="o">&amp;</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Result</span><span class="p">{</span><span class="nx">Action</span><span class="p">:</span> <span class="s">&#34;update&#34;</span><span class="p">,</span> <span class="nx">Service</span><span class="p">:</span> <span class="nf">buildRegistryService</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">subscribeService</span><span class="p">)}</span>
                        <span class="k">return</span>
                    <span class="p">}</span>
                    <span class="nx">create</span> <span class="p">=</span> <span class="kc">false</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">//new instance
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">create</span> <span class="p">{</span>
                <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;create&#34;</span><span class="p">,</span> <span class="nx">subscribeService</span><span class="p">.</span><span class="nx">ServiceName</span><span class="p">,</span> <span class="nx">subscribeService</span><span class="p">.</span><span class="nx">Port</span><span class="p">)</span>

                <span class="nx">nw</span><span class="p">.</span><span class="nx">next</span> <span class="o">&lt;-</span> <span class="o">&amp;</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Result</span><span class="p">{</span><span class="nx">Action</span><span class="p">:</span> <span class="s">&#34;create&#34;</span><span class="p">,</span> <span class="nx">Service</span><span class="p">:</span> <span class="nf">buildRegistryService</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">subscribeService</span><span class="p">)}</span>

                <span class="nx">nw</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
                <span class="nx">nw</span><span class="p">.</span><span class="nx">cacheServices</span><span class="p">[</span><span class="nx">serviceName</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nw</span><span class="p">.</span><span class="nx">cacheServices</span><span class="p">[</span><span class="nx">serviceName</span><span class="p">],</span> <span class="nx">subscribeService</span><span class="p">)</span>
                <span class="nx">nw</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
                <span class="k">return</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">cacheService</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nw</span><span class="p">.</span><span class="nx">cacheServices</span><span class="p">[</span><span class="nx">serviceName</span><span class="p">]</span> <span class="p">{</span>
            <span class="nx">del</span> <span class="o">:=</span> <span class="kc">true</span>
            <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">subscribeService</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">services</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nx">subscribeService</span><span class="p">.</span><span class="nx">InstanceId</span> <span class="o">==</span> <span class="nx">cacheService</span><span class="p">.</span><span class="nx">InstanceId</span> <span class="p">{</span>
                    <span class="nx">del</span> <span class="p">=</span> <span class="kc">false</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">del</span> <span class="p">{</span>
                <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;del&#34;</span><span class="p">,</span> <span class="nx">cacheService</span><span class="p">.</span><span class="nx">ServiceName</span><span class="p">,</span> <span class="nx">cacheService</span><span class="p">.</span><span class="nx">Port</span><span class="p">)</span>
                <span class="nx">nw</span><span class="p">.</span><span class="nx">next</span> <span class="o">&lt;-</span> <span class="o">&amp;</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Result</span><span class="p">{</span><span class="nx">Action</span><span class="p">:</span> <span class="s">&#34;delete&#34;</span><span class="p">,</span> <span class="nx">Service</span><span class="p">:</span> <span class="nf">buildRegistryService</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cacheService</span><span class="p">)}</span>

                <span class="nx">nw</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
                <span class="nx">nw</span><span class="p">.</span><span class="nx">cacheServices</span><span class="p">[</span><span class="nx">serviceName</span><span class="p">][</span><span class="nx">index</span><span class="p">]</span> <span class="p">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">Instance</span><span class="p">{}</span>
                <span class="nx">nw</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

                <span class="k">return</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="nf">buildRegistryService</span><span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">model</span><span class="p">.</span><span class="nx">Instance</span><span class="p">)</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Service</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">nodes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nx">nodes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nodes</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Node</span><span class="p">{</span>
        <span class="nx">Id</span><span class="p">:</span>       <span class="nx">v</span><span class="p">.</span><span class="nx">InstanceId</span><span class="p">,</span>
        <span class="nx">Address</span><span class="p">:</span>  <span class="nx">net</span><span class="p">.</span><span class="nf">JoinHostPort</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Ip</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Port</span><span class="p">)),</span>
        <span class="nx">Metadata</span><span class="p">:</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">,</span>
    <span class="p">})</span>
    <span class="nx">s</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Service</span><span class="p">{</span>
        <span class="nx">Name</span><span class="p">:</span>     <span class="nx">v</span><span class="p">.</span><span class="nx">ServiceName</span><span class="p">,</span>
        <span class="nx">Version</span><span class="p">:</span>  <span class="s">&#34;latest&#34;</span><span class="p">,</span>
        <span class="nx">Metadata</span><span class="p">:</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">,</span>
        <span class="nx">Nodes</span><span class="p">:</span>    <span class="nx">nodes</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="c1">// watcher 实现了 register.Watcher 接口，该方法为阻塞的，只有服务有变化时 next channel里才会有值
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">nw</span> <span class="o">*</span><span class="nx">watcher</span><span class="p">)</span> <span class="nf">Next</span><span class="p">()</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Result</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">nw</span><span class="p">.</span><span class="nx">exit</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">registry</span><span class="p">.</span><span class="nx">ErrWatcherStopped</span>
    <span class="k">case</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">nw</span><span class="p">.</span><span class="nx">next</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">registry</span><span class="p">.</span><span class="nx">ErrWatcherStopped</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">r</span><span class="p">,</span> <span class="kc">nil</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">nw</span> <span class="o">*</span><span class="nx">watcher</span><span class="p">)</span> <span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">nw</span><span class="p">.</span><span class="nx">exit</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="nb">close</span><span class="p">(</span><span class="nx">nw</span><span class="p">.</span><span class="nx">exit</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nw</span><span class="p">.</span><span class="nx">Doms</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nw</span><span class="p">.</span><span class="nx">Doms</span> <span class="p">{</span>
                <span class="nx">param</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">vo</span><span class="p">.</span><span class="nx">SubscribeParam</span><span class="p">{</span>
                    <span class="nx">ServiceName</span><span class="p">:</span>       <span class="nx">v</span><span class="p">,</span>
                    <span class="nx">SubscribeCallback</span><span class="p">:</span> <span class="nx">nw</span><span class="p">.</span><span class="nx">callBackHandle</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="nx">_</span> <span class="p">=</span> <span class="nx">nw</span><span class="p">.</span><span class="nx">n</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">Unsubscribe</span><span class="p">(</span><span class="nx">param</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">_</span> <span class="p">=</span> <span class="nx">nw</span><span class="p">.</span><span class="nx">n</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">Unsubscribe</span><span class="p">(</span><span class="nx">nw</span><span class="p">.</span><span class="nx">param</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>不难发现，其实在接口定义好的情况下，写其实现方法不难，只要按照接口定义和含义，正常逻辑逻辑即可。
这段代码我已经 PR 到 <code>go-micro</code> 项目 ，可以在GitHub上直接查看源码。<a href="https://github.com/asim/go-micro/tree/master/plugins/registry/nacos">传送门</a>。</p>
]]></content><category scheme="https://yusank.github.io/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术"/><category scheme="https://yusank.github.io/categories/microservice/" term="microservice" label="microservice"/></entry><entry><title type="text">Go-Micro 的架构及其使用（一）</title><link rel="alternate" type="text/html" href="https://yusank.github.io/posts/go-micro-1/"/><id>https://yusank.github.io/posts/go-micro-1/</id><updated>2021-07-04T08:33:24+00:00</updated><published>2021-06-11T18:22:00+08:00</published><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><summary type="html">关于如何使用go的微服务框架 go-micro/v3 的使用和其插件的自定义。第一部分将框架的架构大致了解一遍。 架构 以 v3.5.1 分支为例 go-micor 项目的目录结构……</summary><content type="html"><![CDATA[<p>关于如何使用go的微服务框架 <code>go-micro/v3</code> 的使用和其插件的自定义。第一部分将框架的架构大致了解一遍。</p>
<h2 id="架构">架构</h2>
<blockquote>
<p>以 <code>v3.5.1</code> 分支为例</p>
</blockquote>
<p><code>go-micor</code> 项目的目录结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ tree -L <span class="m">2</span>
.
├── LICENSE
├── README.md
├── _config.yml
├── api // api 接口的定义，包括http、grpc、router等
├── auth // 账号认证接口的定义
├── broker // 消息队列接口定义及默认实现
├── client // 客户端相关接口定义和实现
├── cmd // 可执行命令（包括生成protobuf的命令实现）
├── codec // code encoder
├── config // 动态配置的接口定义
├── debug // debug 模式
├── errors // 错误处理
├── examples // 各个模块的示例代码
├── logger // 日志模块接口定义
├── metadata // 原数据
├── plugins // 各个模块定义的接口的不同实现
├── registry // 服务注册接口定义
├── selector // 负载均衡
├── server // 服务端接口定义
├── store // 数据存储接口定义
├── sync 
├── transport // 请求转发
└── util // 工具类
</code></pre></td></tr></table>
</div>
</div><p>下面按目录将 <code>go-micro</code> 的主要核心模块过一遍。</p>
<h3 id="api">API</h3>
<blockquote>
<p><code>api</code> 层为定义和实现基于http/gRPC的api service。即http请求处理 路由处理 路由注册等。</p>
</blockquote>
<p>接口定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Api</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Initialise options
</span><span class="c1"></span>	<span class="nf">Init</span><span class="p">(</span><span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// Get the options
</span><span class="c1"></span>	<span class="nf">Options</span><span class="p">()</span> <span class="nx">Options</span>
	<span class="c1">// Register a http handler
</span><span class="c1"></span>	<span class="nf">Register</span><span class="p">(</span><span class="o">*</span><span class="nx">Endpoint</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// Register a route
</span><span class="c1"></span>	<span class="nf">Deregister</span><span class="p">(</span><span class="o">*</span><span class="nx">Endpoint</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// Implemenation of api
</span><span class="c1"></span>	<span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>目录结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ tree
.
├── api.go
├── api_test.go
├── handler // 接口处理方法
│   ├── api // 实现 http.ServerHTTP<span class="o">()</span> 方法
│   ├── event // 基于消息队列的实现
│   ├── handler.go // 接口定义
│   ├── http // 基于http的实现
│   ├── options.go
│   ├── rpc // 基于rpc的实现
│   └── web // 支持websocket的实现
├── proto
│   ├── api.pb.go
│   ├── api.pb.micro.go
│   └── api.proto // 数据结构定义
├── resolver // 解析请求及路由
│   ├── grpc
│   ├── host
│   ├── options.go
│   ├── path
│   ├── resolver.go
│   └── vpath
├── router // 路由定义和注册
│   ├── options.go
│   ├── registry
│   ├── router.go
│   ├── static
│   └── util
└── server // 服务定义和启动
    ├── acme
    ├── cors
    ├── http
    ├── options.go
    └── server.go
</code></pre></td></tr></table>
</div>
</div><h3 id="config">Config</h3>
<blockquote>
<p><code>config</code> 作为动态配置中心的接口定义和实现。支持动态加载、插件式配置源、配置合并和观察配置变化。</p>
</blockquote>
<p>接口定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Config is an interface abstraction for dynamic configuration
</span><span class="c1">// 配置接口定义
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Config</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// provide the reader.Values interface
</span><span class="c1"></span>    <span class="c1">// 读取到的配置的reader
</span><span class="c1"></span>	<span class="nx">reader</span><span class="p">.</span><span class="nx">Values</span>
	<span class="c1">// Init the config
</span><span class="c1"></span>	<span class="nf">Init</span><span class="p">(</span><span class="nx">opts</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// Options in the config
</span><span class="c1"></span>	<span class="nf">Options</span><span class="p">()</span> <span class="nx">Options</span>
	<span class="c1">// Stop the config loader/watcher
</span><span class="c1"></span>	<span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>
	<span class="c1">// Load config sources
</span><span class="c1"></span>    <span class="c1">// 可以加载多个Source
</span><span class="c1"></span>	<span class="nf">Load</span><span class="p">(</span><span class="nx">source</span> <span class="o">...</span><span class="nx">source</span><span class="p">.</span><span class="nx">Source</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// Force a source changeset sync
</span><span class="c1"></span>    <span class="c1">// 同步配置变化
</span><span class="c1"></span>	<span class="nf">Sync</span><span class="p">()</span> <span class="kt">error</span>
	<span class="c1">// Watch a value for changes
</span><span class="c1"></span>    <span class="c1">// 订阅配置变化
</span><span class="c1"></span>	<span class="nf">Watch</span><span class="p">(</span><span class="nx">path</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Watcher</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Watcher is the config watcher
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Watcher</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Next</span><span class="p">()</span> <span class="p">(</span><span class="nx">reader</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nf">Stop</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="c1">// Source is the source from which config is loaded
</span><span class="c1">// Source 就是配置来源 go-micro 已实现基于consul，etcd，file等多种配置来源，也可以自己实现下面接口来使用
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Source</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Read</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">ChangeSet</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nf">Write</span><span class="p">(</span><span class="o">*</span><span class="nx">ChangeSet</span><span class="p">)</span> <span class="kt">error</span>
	<span class="nf">Watch</span><span class="p">()</span> <span class="p">(</span><span class="nx">Watcher</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// Reader is an interface for merging changesets
</span><span class="c1">// 用于配置合并
</span><span class="c1">// go-micro 实现了基于json的Reader,默认用json作为解析配置内容，并在插件目录内实现了 toml yaml xml等格式的Encoder可以按需求替换
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Merge</span><span class="p">(</span><span class="o">...*</span><span class="nx">source</span><span class="p">.</span><span class="nx">ChangeSet</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">source</span><span class="p">.</span><span class="nx">ChangeSet</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nf">Values</span><span class="p">(</span><span class="o">*</span><span class="nx">source</span><span class="p">.</span><span class="nx">ChangeSet</span><span class="p">)</span> <span class="p">(</span><span class="nx">Values</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// Values is returned by the reader
</span><span class="c1">// 用于读写配置，读取的配置会返回 Value
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Values</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Bytes</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="nf">Get</span><span class="p">(</span><span class="nx">path</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="nx">Value</span>
	<span class="nf">Set</span><span class="p">(</span><span class="nx">val</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">path</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span>
	<span class="nf">Del</span><span class="p">(</span><span class="nx">path</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span>
	<span class="nf">Map</span><span class="p">()</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
	<span class="nf">Scan</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="c1">// Value represents a value of any type
</span><span class="c1">// Value 为拿到的配置，可以通过其方法转到基础类型。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Value</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Bool</span><span class="p">(</span><span class="nx">def</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span>
	<span class="nf">Int</span><span class="p">(</span><span class="nx">def</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
	<span class="nf">String</span><span class="p">(</span><span class="nx">def</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>
	<span class="nf">Float64</span><span class="p">(</span><span class="nx">def</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span>
	<span class="nf">Duration</span><span class="p">(</span><span class="nx">def</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
	<span class="nf">StringSlice</span><span class="p">(</span><span class="nx">def</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span>
	<span class="nf">StringMap</span><span class="p">(</span><span class="nx">def</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
	<span class="nf">Scan</span><span class="p">(</span><span class="nx">val</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
	<span class="nf">Bytes</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>目录结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ tree -L <span class="m">2</span>
.
├── README.md
├── config.go // Config 接口定义
├── default.go // 默认实现的Config
├── default_test.go
├── encoder // encoder 解析配置内容
│   ├── encoder.go
│   └── json // json实现
├── loader // 加载配置
│   ├── loader.go
│   └── memory // 基于内存的加载，即启动时会将配置加载到内存
├── options.go
├── reader // 定义和实现Reader，内部依赖Encoder
│   ├── json
│   ├── options.go
│   ├── preprocessor.go
│   ├── preprocessor_test.go
│   └── reader.go
├── secrets // 定义和实现需要加解密的配置
│   ├── box
│   ├── secretbox
│   └── secrets.go
├── <span class="nb">source</span> // 配置来源
│   ├── changeset.go
│   ├── cli
│   ├── env // 基于环境变量的实现
│   ├── file // 基于本地文件实现
│   ├── flag // 基于启动参数flag实现
│   ├── memory // 基于内存实现
│   ├── noop.go
│   ├── options.go
│   └── source.go
└── value.go
</code></pre></td></tr></table>
</div>
</div><p><code>plugins/config/encoder</code> 目录:</p>
<blockquote>
<p>实现Encoder接口</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ tree
plugins/config/encoder
├── cue
├── hcl
├── toml
├── xml
└── yaml
</code></pre></td></tr></table>
</div>
</div><p><code>plugins/config/source</code> 目录：</p>
<blockquote>
<p>实现Source接口</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ tree
plugins/config/source
├── configmap
├── consul
├── etcd
├── grpc
├── mucp
├── pkger
├── runtimevar
├── url
└── vault
</code></pre></td></tr></table>
</div>
</div><h3 id="logger">Logger</h3>
<blockquote>
<p><code>Logger</code> 包为全局日志库，默认实现了一套，并在<code>plugins</code> 内实现了基于 logrus，zap的个主流的日志的实现。</p>
</blockquote>
<p>接口定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Logger is a generic logging interface
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Logger</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Init initialises options
</span><span class="c1"></span>	<span class="nf">Init</span><span class="p">(</span><span class="nx">options</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// The Logger options
</span><span class="c1"></span>	<span class="nf">Options</span><span class="p">()</span> <span class="nx">Options</span>
	<span class="c1">// Fields set fields to always be logged
</span><span class="c1"></span>	<span class="nf">Fields</span><span class="p">(</span><span class="nx">fields</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="nx">Logger</span>
	<span class="c1">// Log writes a log entry
</span><span class="c1"></span>	<span class="nf">Log</span><span class="p">(</span><span class="nx">level</span> <span class="nx">Level</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
	<span class="c1">// Logf writes a formatted log entry
</span><span class="c1"></span>	<span class="nf">Logf</span><span class="p">(</span><span class="nx">level</span> <span class="nx">Level</span><span class="p">,</span> <span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
	<span class="c1">// String returns the name of logger
</span><span class="c1"></span>	<span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>若需要自己定义日志格式和日志库，可以实现上面接口，并初始化的时候指定即可。</p>
<h3 id="plugins">plugins</h3>
<blockquote>
<p>该目录作为插件目录，实现了大部分预定义的接口，方便使用的时候替换成默认实现的模块代码。
该目录下所有子目录均可以作为go mod package 导入使用
在之后讲如何使用是 同时演示如何使用插件</p>
</blockquote>
<p>目录结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ tree
plugins
├── LICENSE
├── README.md
├── auth // 用户认真
│   └── jwt // 实现基于jwt的auth接口
├── broker // 支持了市面上大部分消息队列
│   ├── gocloud
│   ├── googlepubsub
│   ├── grpc
│   ├── http
│   ├── kafka
│   ├── memory
│   ├── mqtt
│   ├── nats
│   ├── nsq
│   ├── proxy
│   ├── rabbitmq
│   ├── redis
│   ├── segmentio
│   ├── snssqs
│   ├── sqs
│   ├── stan
│   └── stomp
├── client // 支持了grpc http 等方式的客户端实现
│   ├── grpc
│   ├── http
│   ├── mock
│   └── mucp
├── codec // 消息的编码解码的实现
│   ├── bsonrpc
│   ├── json-iterator
│   ├── jsonrpc2
│   ├── msgpackrpc
│   └── segmentio
├── config // 配置
│    ├── encoder // 配置编码解码
│       ├── cue
│       ├── hcl
│       ├── toml
│       ├── xml
│       └── yaml
│   └── <span class="nb">source</span> // 配置数据源
│       ├── configmap
│       ├── consul
│       ├── etcd
│       ├── grpc
│       ├── mucp
│       ├── pkger
│       ├── runtimevar
│       ├── url
│       └── vault
├── logger // 日志库
│   ├── apex
│   ├── logrus
│   ├── zap
│   └── zerolog
├── plugin.go
├── proxy
│   └── http
├── registry // 服务发现服务注册
│   ├── cache
│   ├── consul
│   ├── etcd
│   ├── eureka
│   ├── gossip
│   ├── kubernetes
│   ├── mdns
│   ├── memory
│   ├── multi
│   ├── nats
│   ├── proxy
│   └── zookeeper
├── release.sh
├── selector // 负载均衡
│   ├── dns
│   ├── label
│   ├── registry
│   ├── shard
│   └── static
├── server // 后端服务
│   ├── grpc
│   ├── http
│   └── mucp
├── store // 数据存储的实现
│   ├── cockroach
│   ├── consul
│   ├── file
│   ├── memcached
│   ├── memory
│   ├── mysql
│   └── redis
├── sync // 数据同步
│   ├── etcd
│   └── memory
├── template.go
├── transport // 服务之间通讯模块
│   ├── grpc
│   ├── http
│   ├── memory
│   ├── nats
│   ├── quic
│   ├── rabbitmq
│   ├── tcp
│   └── utp
└── wrapper // 自定义组件 比如监控、限流、熔断、追踪等
    ├── README.md
    ├── breaker // 熔断
    ├── endpoint // 指定服务节点
    ├── monitoring // 监控
    ├── ratelimiter // 限流
    ├── <span class="k">select</span> // 负载均衡
    ├── service
    ├── trace // 链路追踪
    └── validator // 参数校验（处理请求时 可以统一参数校验等工作）
</code></pre></td></tr></table>
</div>
</div><h3 id="registry">Registry</h3>
<blockquote>
<p>服务发现/服务注册相关逻辑均在 <code>registry</code> 包内实现。</p>
</blockquote>
<p>核心接口定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The registry provides an interface for service discovery
</span><span class="c1">// and an abstraction over varying implementations
</span><span class="c1">// {consul, etcd, zookeeper, ...}
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Registry</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Init</span><span class="p">(</span><span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="kt">error</span>
	<span class="nf">Options</span><span class="p">()</span> <span class="nx">Options</span>
    <span class="c1">// 服务注册
</span><span class="c1"></span>	<span class="nf">Register</span><span class="p">(</span><span class="o">*</span><span class="nx">Service</span><span class="p">,</span> <span class="o">...</span><span class="nx">RegisterOption</span><span class="p">)</span> <span class="kt">error</span>
    <span class="c1">// 服务注销
</span><span class="c1"></span>	<span class="nf">Deregister</span><span class="p">(</span><span class="o">*</span><span class="nx">Service</span><span class="p">,</span> <span class="o">...</span><span class="nx">DeregisterOption</span><span class="p">)</span> <span class="kt">error</span>
    <span class="c1">// 查询服务
</span><span class="c1"></span>	<span class="nf">GetService</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="o">...</span><span class="nx">GetOption</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">Service</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="c1">// 列出服务列表
</span><span class="c1"></span>	<span class="nf">ListServices</span><span class="p">(</span><span class="o">...</span><span class="nx">ListOption</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">Service</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="c1">// 监控服务
</span><span class="c1"></span>	<span class="nf">Watch</span><span class="p">(</span><span class="o">...</span><span class="nx">WatchOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">Watcher</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// Watcher is an interface that returns updates
</span><span class="c1">// about services within the registry.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Watcher</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Next is a blocking call
</span><span class="c1"></span>	<span class="nf">Next</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">Result</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nf">Stop</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="selector">Selector</h3>
<blockquote>
<p>负载均衡逻辑，即客户端请求其他服务时如何选取服务节点都是在该包内实现。可以通过option指定策略，随机，轮询等。</p>
</blockquote>
<p>接口定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Selector builds on the registry as a mechanism to pick nodes
</span><span class="c1">// and mark their status. This allows host pools and other things
</span><span class="c1">// to be built using various algorithms.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Selector</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Init</span><span class="p">(</span><span class="nx">opts</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="kt">error</span>
	<span class="nf">Options</span><span class="p">()</span> <span class="nx">Options</span>
	<span class="c1">// Select returns a function which should return the next node
</span><span class="c1"></span>	<span class="nf">Select</span><span class="p">(</span><span class="nx">service</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">SelectOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">Next</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="c1">// Mark sets the success/error against a node
</span><span class="c1"></span>	<span class="nf">Mark</span><span class="p">(</span><span class="nx">service</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">node</span> <span class="o">*</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
	<span class="c1">// Reset returns state back to zero for a service
</span><span class="c1"></span>	<span class="nf">Reset</span><span class="p">(</span><span class="nx">service</span> <span class="kt">string</span><span class="p">)</span>
	<span class="c1">// Close renders the selector unusable
</span><span class="c1"></span>	<span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>
	<span class="c1">// Name of the selector
</span><span class="c1"></span>	<span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// Next is a function that returns the next node
</span><span class="c1">// based on the selector&#39;s strategy
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Next</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">registry</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="server">Server</h3>
<blockquote>
<p>server 包为定义和实现管理服务相关逻辑。</p>
</blockquote>
<p>server的定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Server is a simple micro server abstraction
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Server</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Initialise options
</span><span class="c1"></span>	<span class="nf">Init</span><span class="p">(</span><span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// Retrieve the options
</span><span class="c1"></span>	<span class="nf">Options</span><span class="p">()</span> <span class="nx">Options</span>
	<span class="c1">// Register a handler
</span><span class="c1"></span>	<span class="nf">Handle</span><span class="p">(</span><span class="nx">Handler</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// Create a new handler
</span><span class="c1"></span>	<span class="nf">NewHandler</span><span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="o">...</span><span class="nx">HandlerOption</span><span class="p">)</span> <span class="nx">Handler</span>
	<span class="c1">// Create a new subscriber
</span><span class="c1"></span>	<span class="nf">NewSubscriber</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kd">interface</span><span class="p">{},</span> <span class="o">...</span><span class="nx">SubscriberOption</span><span class="p">)</span> <span class="nx">Subscriber</span>
	<span class="c1">// Register a subscriber
</span><span class="c1"></span>	<span class="nf">Subscribe</span><span class="p">(</span><span class="nx">Subscriber</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// Start the server
</span><span class="c1"></span>	<span class="nf">Start</span><span class="p">()</span> <span class="kt">error</span>
	<span class="c1">// Stop the server
</span><span class="c1"></span>	<span class="nf">Stop</span><span class="p">()</span> <span class="kt">error</span>
	<span class="c1">// Server implementation
</span><span class="c1"></span>	<span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// Router handle serving messages
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Router</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// ProcessMessage processes a message
</span><span class="c1"></span>    <span class="c1">// 处理消息队列消息
</span><span class="c1"></span>	<span class="nf">ProcessMessage</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">Message</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// ServeRequest processes a request to completion
</span><span class="c1"></span>    <span class="c1">// 处理 http/rpc 请求
</span><span class="c1"></span>	<span class="nf">ServeRequest</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">Request</span><span class="p">,</span> <span class="nx">Response</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>默认实现了rpc和消息队列，http服务 可以使用<code>plugins/server/http</code> 包。</p>
<h3 id="store">Store</h3>
<blockquote>
<p>该包定义了数据存储的接口。</p>
</blockquote>
<p>接口定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Store is a data storage interface
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Store</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Init initialises the store. It must perform any required setup on the backing storage implementation and check that it is ready for use, returning any errors.
</span><span class="c1"></span>	<span class="nf">Init</span><span class="p">(</span><span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// Options allows you to view the current options.
</span><span class="c1"></span>	<span class="nf">Options</span><span class="p">()</span> <span class="nx">Options</span>
	<span class="c1">// Read takes a single key name and optional ReadOptions. It returns matching []*Record or an error.
</span><span class="c1"></span>	<span class="nf">Read</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">ReadOption</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">Record</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="c1">// Write() writes a record to the store, and returns an error if the record was not written.
</span><span class="c1"></span>	<span class="nf">Write</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Record</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">WriteOption</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// Delete removes the record with the corresponding key from the store.
</span><span class="c1"></span>	<span class="nf">Delete</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">DeleteOption</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// List returns any keys that match, or an empty list with no error if none matched.
</span><span class="c1"></span>	<span class="nf">List</span><span class="p">(</span><span class="nx">opts</span> <span class="o">...</span><span class="nx">ListOption</span><span class="p">)</span> <span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="c1">// Close the store
</span><span class="c1"></span>	<span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>
	<span class="c1">// String returns the name of the implementation.
</span><span class="c1"></span>	<span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>具体使用数据库类型，在<code>plugins/store</code> 内初始化对应的实例。</p>
<h3 id="sync">Sync</h3>
<blockquote>
<p><code>sync</code> 包为定义分布式选举和分布式锁的定义。</p>
</blockquote>
<p>接口定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Sync is an interface for distributed synchronization
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Sync</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Initialise options
</span><span class="c1"></span>	<span class="nf">Init</span><span class="p">(</span><span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// Return the options
</span><span class="c1"></span>	<span class="nf">Options</span><span class="p">()</span> <span class="nx">Options</span>
	<span class="c1">// Elect a leader
</span><span class="c1"></span>    <span class="c1">// 选举
</span><span class="c1"></span>	<span class="nf">Leader</span><span class="p">(</span><span class="nx">id</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">LeaderOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">Leader</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="c1">// Lock acquires a lock
</span><span class="c1"></span>    <span class="c1">// 上锁
</span><span class="c1"></span>	<span class="nf">Lock</span><span class="p">(</span><span class="nx">id</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">LockOption</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// Unlock releases a lock
</span><span class="c1"></span>    <span class="c1">// 释放锁
</span><span class="c1"></span>	<span class="nf">Unlock</span><span class="p">(</span><span class="nx">id</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// Sync implementation
</span><span class="c1"></span>	<span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// Leader provides leadership election
</span><span class="c1">// 提供分布式选举
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Leader</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// resign leadership
</span><span class="c1"></span>    <span class="c1">// 辞职 即放弃Leader状态
</span><span class="c1"></span>	<span class="nf">Resign</span><span class="p">()</span> <span class="kt">error</span>
	<span class="c1">// status returns when leadership is lost
</span><span class="c1"></span>    <span class="c1">// 在leader 状态失去时，channel内可读取
</span><span class="c1"></span>	<span class="nf">Status</span><span class="p">()</span> <span class="kd">chan</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>]]></content><category scheme="https://yusank.github.io/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术"/><category scheme="https://yusank.github.io/categories/microservice/" term="microservice" label="microservice"/></entry><entry><title type="text">Go 面试总结</title><link rel="alternate" type="text/html" href="https://yusank.github.io/posts/go-interview/"/><id>https://yusank.github.io/posts/go-interview/</id><updated>2021-07-04T08:33:24+00:00</updated><published>2021-05-31T21:13:41+08:00</published><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><summary type="html">经历了2个月的面试折磨，拿到offer总算结束了这段时间。主要是想记录面试中遇到的问题，列出来的问题不一定有答案，有答案……</summary><content type="html"><![CDATA[<p>经历了2个月的面试折磨，拿到offer总算结束了这段时间。主要是想记录面试中遇到的问题，列出来的问题不一定有答案，有答案也不一定是最佳答案，所以还是看问题为主，答案自行解决。</p>
<h1 id="知识架构">知识架构</h1>
<p><img src="https://raw.githubusercontent.com/yusank/hugo.yusank.space/master/xmind.png" alt="xmind"></p>
<h2 id="数据库">数据库</h2>
<h3 id="mysql">MySQL</h3>
<h4 id="索引">索引</h4>
<ul>
<li>B+tree <a href="https://mp.weixin.qq.com/s/5Yl6H6up9ntZq6l8qxiogw">索引</a>
<ul>
<li>数据存储位置-在叶子节点 相邻节点是链表结构 这样可以实现 range 查询</li>
<li>联合索引 最左原则</li>
<li>索引不能是表达式的一部分 否则不走索引</li>
<li>为什么主键是递增的，随机会怎么样？
<ul>
<li>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而<code>移动数据</code>，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了<code>大量的碎片</code>，得到了不够紧凑的索引结构，后续不得不通过<code>OPTIMIZE TABLE</code>来重建表并优化填充页面。</li>
</ul>
</li>
</ul>
</li>
<li>哈希索引 - 精准查询</li>
<li>聚簇索引和非聚簇索引
<img src="https://img2018.cnblogs.com/i-beta/1464190/201911/1464190-20191106145143172-1760681728.png" alt="请看图"></li>
</ul>
<h4 id="事务">事务</h4>
<ul>
<li>
<p>事务的四种特性：</p>
<ul>
<li>原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li>致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>
<li>隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
</li>
<li>
<p>事务的<a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">隔离级别</a>：</p>
<ul>
<li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</li>
<li>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)</li>
<li>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读</li>
<li>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读（Dirty Read）</th>
<th>不可重复读（NonRepeatable Read）</th>
<th>幻读（Phantom Read）</th>
</tr>
</thead>
<tbody>
<tr>
<td>未提交读（Read uncommitted）</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>已提交读（Read committed）</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重复读（Repeatable read）</td>
<td>不可能</td>
<td>不可能</td>
<td>可能（innodb 不存在）</td>
</tr>
<tr>
<td>可串行化（Serializable ）</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody>
</table>
<h4 id="分库分表">分库分表</h4>
<p>水平：</p>
<ul>
<li>水平分表 -- 表之间结构相同 表之间数据不相同 所有表的数据并集是总数据（单表数据量很大，影响sql性能）</li>
<li>水平分库 -- 库之间表结构相同 库之间数据不相同 所有库数据的并集是总数据（并发量很高，cpu 网络扛不住，分库缓解压力）</li>
</ul>
<p>垂直：</p>
<ul>
<li>垂直分表 -- 表之间结构不相同，数据根据某个字段关联，缓解io性能</li>
<li>垂直分库 -- 库之前的表之间结构不相同，服务压力很高 可以考虑拆出去做单独服务了</li>
</ul>
<p>方案：</p>
<p><strong>方案一（水平扩容库）</strong>
采用双倍扩容策略，避免数据迁移。扩容前每个节点的数据，有一半要迁移至一个新增节点中，对应关系比较简单。
具体操作如下(假设已有 2 个节点 A/B，要双倍扩容至 A/A2/B/B2 这 4 个节点)：</p>
<ul>
<li>无需停止应用服务器；</li>
<li>新增两个数据库 A2/B2 作为从库，设置主从同步关系为：A=&gt;A2、B=&gt;B2，直至主从数据同步完毕(早期数据可手工同步)；</li>
<li>调整分片规则并使之生效：</li>
<li>原 ID%2=0 =&gt; A 改为 ID%4=0 =&gt; A, ID%4=2 =&gt; A2；</li>
<li>原 ID%2=1 =&gt; B 改为 ID%4=1 =&gt; B, ID%4=3 =&gt; B2。</li>
<li>解除数据库实例的主从同步关系，并使之生效；</li>
<li>此时，四个节点的数据都已完整，只是有冗余(多存了和自己配对的节点的那部分数据)，择机清除即可(过后随时进行，不影响业务)。</li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-789f54a192017f3fa3138d3bf768cbad_r.jpg" alt="水平扩库"></p>
<p><strong>方案二（水平扩容表-双写）</strong></p>
<ul>
<li>第一步：（同步双写）修改应用配置和代码，加上双写，部署</li>
<li>第二步：（同步双写）将老库中的老数据复制到新库中</li>
<li>第三步：（同步双写）以老库为准校对新库中的老数据</li>
<li>第四步：（同步双写）修改应用配置和代码，去掉双写，部署；</li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-4847eb9e869a90b8eb293ecdfeb19acd_r.jpg" alt="水平扩容表"></p>
<h3 id="redis">Redis</h3>
<h4 id="数据结构">数据结构</h4>
<ul>
<li>String 简单动态字符串
<ul>
<li>编码方式不同会有什么影响</li>
</ul>
</li>
<li>Set 底层哈希表</li>
<li>ZSet member存在哈希表中 score 存在跳表里 查询插入时间复杂 logn
<ul>
<li>为什么用跳表</li>
</ul>
</li>
<li>List 双向链表结构</li>
<li>Hmap 哈希表</li>
</ul>
<h4 id="性能">性能</h4>
<p><a href="https://mp.weixin.qq.com/s/b_yzbLeQh57oYjqlIgPiYQ">为什么这么快</a>
<a href="https://juejin.cn/post/6915599025882431501?utm_source=gold_browser_extension#heading-4">为什么这么快2</a></p>
<ul>
<li>数据均存在内存（引发出持久化问题）</li>
<li>高效的数据结构</li>
<li>单线程，省去线程间上下文切换的时间 以及不需要考虑锁</li>
<li>网络io 多路复用 可以让单个线程处理多个请求连接 减少网络io</li>
<li>Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</li>
</ul>
<h4 id="持久化">持久化</h4>
<p>两种持久化：</p>
<ul>
<li>RDB持久化 即内存数据定时dump到磁盘上。
<ul>
<li>fork 一个子进程 将数据写入一个临时文件 写入成功后 替换源文件。</li>
<li>快照的数据是截止fork命令执行的那一刻</li>
</ul>
</li>
<li>AOF 将Redis的操作日志以追加的方式写入文件。
<ul>
<li>将每一个写、删操作记录下来。默认配置时每秒同步一次。</li>
</ul>
</li>
</ul>
<p>RDB存在哪些优势呢？</p>
<p>1). 一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</p>
<p>2). 对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。</p>
<p>3). 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</p>
<p>4). 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</p>
<p>RDB又存在哪些劣势呢？</p>
<p>1). 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</p>
<p>2). 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p>
<p>AOF的优势有哪些呢？</p>
<p>1). 该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。</p>
<p>2). 由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。</p>
<p>3). 如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</p>
<p>4). AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</p>
<p>AOF的劣势有哪些呢？</p>
<p>1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p>
<p>2). 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</p>
<p>二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。</p>
<h4 id="内存模型">内存模型</h4>
<p><a href="https://mp.weixin.qq.com/s/YGmOoBZ7J-3dPrNntRTfSg">内存模型</a></p>
<h3 id="mongodb">MongoDB</h3>
<blockquote>
<p>待补充</p>
</blockquote>
<h3 id="缓存">缓存</h3>
<blockquote>
<p>常见缓存策略</p>
</blockquote>
<p><a href="https://www.cnblogs.com/lpfuture/p/5796398.html">一致性哈希</a> 解决某个缓存节点宕机的情况。</p>
<h4 id="缓存穿透">缓存穿透</h4>
<p>描述：缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>
<p>解决方案：</p>
<ul>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截。</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击。</li>
<li><a href="https://zhuanlan.zhihu.com/p/72378274">布隆过滤器</a>：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
<ul>
<li>布隆过滤器原理：对key进行多个(n)hash算法 并将其值与 bitArray 长度m 进行取模 并对应的位置置位1，当一个新的key进行查询时 先查询其n个hash算法后的各个位置是否为1 如果都为1 则这个key可能存在 如果有任意一个位置不是1 则这个key 一定不存在。</li>
</ul>
</li>
</ul>
<h4 id="缓存击穿">缓存击穿</h4>
<p>描述：缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p>
<p>解决方案：</p>
<ul>
<li>热点数据不做过期</li>
<li>互斥锁。如果数据缓存不存在 则先进行上锁读数据写缓存释放锁</li>
</ul>
<h4 id="缓存雪崩">缓存雪崩</h4>
<p>描述：缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p>解决方案：</p>
<ul>
<li>过期时间加随机数</li>
<li>热点数据不过期</li>
<li>分布式缓存 将热点数据拆分到不同的实例</li>
</ul>
<h2 id="语言特性">语言特性</h2>
<h3 id="gmp">GMP</h3>
<p><a href="https://www.cnblogs.com/sunsky303/p/9705727.html">调度</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4ODg0NDkzOA==&amp;mid=2247487174&amp;idx=1&amp;sn=a716cc5cc48b7cf6078698942a6c6c18&amp;source=41&amp;key=&amp;ascene=14&amp;uin=&amp;devicetype=Windows+10&amp;version=620603c8&amp;lang=zh_CN&amp;winzoom=1">调度2</a></p>
<p><img src="https://camo.githubusercontent.com/9a6338ccd341d0221f1096630c67f74ddf8a9f58f50b3f7f359d88d760d5355a/68747470733a2f2f7a68616f6d656e672d707269766174652e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f696d616765732f676d702e706e67" alt="调度"></p>
<h4 id="概念">概念</h4>
<ul>
<li>G：代表一个goroutine对象，每次go调用的时候，都会创建一个G对象，它包括栈、指令指针以及对于调用goroutines很重要的其它信息，比如阻塞它的任何channel，其主要数据结构：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">stack</span>       <span class="nx">stack</span>   <span class="c1">// 描述了真实的栈内存，包括上下界
</span><span class="c1"></span>
  <span class="nx">m</span>              <span class="o">*</span><span class="nx">m</span>     <span class="c1">// 当前的m
</span><span class="c1"></span>  <span class="nx">sched</span>          <span class="nx">gobuf</span>   <span class="c1">// goroutine切换时，用于保存g的上下文      
</span><span class="c1"></span>  <span class="nx">param</span>          <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 用于传递参数，睡眠时其他goroutine可以设置param，唤醒时该goroutine可以获取
</span><span class="c1"></span>  <span class="nx">atomicstatus</span>   <span class="kt">uint32</span>
  <span class="nx">stackLock</span>      <span class="kt">uint32</span> 
  <span class="nx">goid</span>           <span class="kt">int64</span>  <span class="c1">// goroutine的ID
</span><span class="c1"></span>  <span class="nx">waitsince</span>      <span class="kt">int64</span> <span class="c1">// g被阻塞的大体时间
</span><span class="c1"></span>  <span class="nx">lockedm</span>        <span class="o">*</span><span class="nx">m</span>     <span class="c1">// G被锁定只在这个m上运行
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>M: 代表内核线程(Pthread)，它本身就与一个内核线程进行绑定，goroutine 运行在M上。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>    
    <span class="cm">/*
</span><span class="cm">        1.  所有调用栈的Goroutine,这是一个比较特殊的Goroutine。
</span><span class="cm">        2.  普通的Goroutine栈是在Heap分配的可增长的stack,而g0的stack是M对应的线程栈。
</span><span class="cm">        3.  所有调度相关代码,会先切换到该Goroutine的栈再执行。
</span><span class="cm">    */</span>
    <span class="nx">g0</span>       <span class="o">*</span><span class="nx">g</span>
    <span class="nx">curg</span>     <span class="o">*</span><span class="nx">g</span>         <span class="c1">// M当前绑定的结构体G
</span><span class="c1"></span>
    <span class="c1">// SP、PC寄存器用于现场保护和现场恢复
</span><span class="c1"></span>    <span class="nx">vdsoSP</span> <span class="kt">uintptr</span>
    <span class="nx">vdsoPC</span> <span class="kt">uintptr</span>

    <span class="c1">// 省略…}
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>P：P(Processor)是一个抽象的概念，并不是真正的物理CPU。所以当P有任务时需要创建或者唤醒一个系统线程来执行它队列里的任务。所以P/M需要进行绑定，构成一个执行单元。
P决定了同时可以并发任务的数量，可通过GOMAXPROCS限制同时执行用户级任务的操作系统线程。可以通过runtime.GOMAXPROCS进行指定。在Go1.5之后GOMAXPROCS被默认设置可用的核数，而之前则默认为1。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 自定义设置GOMAXPROCS数量
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>    
    <span class="cm">/*
</span><span class="cm">        1.  GOMAXPROCS设置可执行的CPU的最大数量,同时返回之前的设置。
</span><span class="cm">        2.  如果n &lt; 1,则不更改当前的值。
</span><span class="cm">    */</span>
    <span class="nx">ret</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span>

    <span class="nf">stopTheWorld</span><span class="p">(</span><span class="s">&#34;GOMAXPROCS&#34;</span><span class="p">)</span>    
    <span class="c1">// startTheWorld启动时,使用newprocs。
</span><span class="c1"></span>    <span class="nx">newprocs</span> <span class="p">=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
    <span class="nf">startTheWorld</span><span class="p">()</span>    
    <span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
<span class="c1">// 默认P被绑定到所有CPU核上
</span><span class="c1">// P == cpu.cores
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">getproccount</span><span class="p">()</span> <span class="kt">int32</span> <span class="p">{</span>    
    <span class="kd">const</span> <span class="nx">maxCPUs</span> <span class="p">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span>
    <span class="kd">var</span> <span class="nx">buf</span> <span class="p">[</span><span class="nx">maxCPUs</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">byte</span>


    <span class="c1">// 获取CPU Core
</span><span class="c1"></span>    <span class="nx">r</span> <span class="o">:=</span> <span class="nf">sched_getaffinity</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">buf</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nx">n</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>    
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">buf</span><span class="p">[:</span><span class="nx">r</span><span class="p">]</span> <span class="p">{</span>        
       <span class="k">for</span> <span class="nx">v</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">n</span> <span class="o">+=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">v</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="nx">v</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>    
    <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
       <span class="nx">n</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="p">}</span>    
    <span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>
<span class="c1">// 一个进程默认被绑定在所有CPU核上,返回所有CPU core。
</span><span class="c1">// 获取进程的CPU亲和性掩码系统调用
</span><span class="c1">// rax 204                          ; 系统调用码
</span><span class="c1">// system_call sys_sched_getaffinity; 系统调用名称
</span><span class="c1">// rid  pid                         ; 进程号
</span><span class="c1">// rsi unsigned int len             
</span><span class="c1">// rdx unsigned long *user_mask_ptr
</span><span class="c1"></span><span class="nx">sys_linux_amd64</span><span class="p">.</span><span class="nx">s</span><span class="p">:</span>
<span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">sched_getaffinity</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span>
    <span class="nx">MOVQ</span>    <span class="nx">pid</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">DI</span>
    <span class="nx">MOVQ</span>    <span class="nx">len</span><span class="o">+</span><span class="mi">8</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">SI</span>
    <span class="nx">MOVQ</span>    <span class="nx">buf</span><span class="o">+</span><span class="mi">16</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">DX</span>
    <span class="nx">MOVL</span>    <span class="err">$</span><span class="nx">SYS_sched_getaffinity</span><span class="p">,</span> <span class="nx">AX</span>
    <span class="nx">SYSCALL</span>
    <span class="nx">MOVL</span>    <span class="nx">AX</span><span class="p">,</span> <span class="nx">ret</span><span class="o">+</span><span class="mi">24</span><span class="p">(</span><span class="nx">FP</span><span class="p">)</span>
    <span class="nx">RET</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="调度过程">调度过程</h4>
<p>首先创建一个G对象，G对象保存到P本地队列或者是全局队列。P此时去唤醒一个M。P继续执行它的执行序。M寻找是否有空闲的P，如果有则将该G对象移动到它本身。接下来M执行一个调度循环(调用G对象-&gt;执行-&gt;清理线程→继续找新的Goroutine执行)。</p>
<p>M执行过程中，随时会发生上下文切换。当发生上线文切换时，需要对执行现场进行保护，以便下次被调度执行时进行现场恢复。Go调度器M的栈保存在G对象上，只需要将M所需要的寄存器(SP、PC等)保存到G对象上就可以实现现场保护。当这些寄存器数据被保护起来，就随时可以做上下文切换了，在中断之前把现场保存起来。如果此时G任务还没有执行完，M可以将任务重新丢到P的任务队列，等待下一次被调度执行。当再次被调度执行时，M通过访问G的vdsoSP、vdsoPC寄存器进行现场恢复(从上次中断位置继续执行)。</p>
<h5 id="多个线程下如何调度">多个线程下如何调度</h5>
<p>抛出一个问题：每个P里面的G执行时间是不可控的，如果多个P同时在执行，会不会出现有的P里面的G执行不完，有的P里面几乎没有G可执行呢？</p>
<p>这就要从M的自循环过程中如何获取G、归还G的行为说起了</p>
<p>有两种途径：1.借助全局队列 sched.runq 作为中介，本地P里的G太多的话就放全局里，G太少的话就从全局取。
2.全局列表里没有的话直接从P1里偷取(steal)。(更多M在执行的话，同样的原理，这里就只拿2个来举例)</p>
<h5 id="调度循环中如何让出cpu">调度循环中如何让出CPU</h5>
<ul>
<li>正常完成让出CPU</li>
<li>主动让出CPU
<ul>
<li>time.Sleep(),IO阻塞等</li>
</ul>
</li>
<li>抢占让出CPU</li>
</ul>
<h4 id="抢占式调度">抢占式调度</h4>
<p>概念：枚举所有的P 如果P在系统调用中(_Psyscall), 且经过了一次sysmon循环(20us~10ms), 则抢占这个P， 调用handoffp解除M和P之间的关联， 如果P在运行中(_Prunning), 且经过了一次sysmon循环并且G运行时间超过forcePreemptNS(10ms), 则抢占这个P</p>
<p>并设置g.preempt = true，g.stackguard0 = stackPreempt。</p>
<p>为什么设置了stackguard就可以实现抢占?</p>
<p>因为这个值用于检查当前栈空间是否足够, go函数的开头会比对这个值判断是否需要扩张栈。</p>
<p>newstack函数判断g.stackguard0等于stackPreempt, 就知道这是抢占触发的, 这时会再检查一遍是否要抢占。</p>
<p>抢占机制保证了不会有一个G长时间的运行导致其他G无法运行的情况发生。</p>
<h4 id="主动让出cpu">主动让出CPU</h4>
<h5 id="timesleep">time.Sleep()</h5>
<p>timeSleep 函数里通过 addtimerLocked 把定时器加入到 timer 管理器（timer 通过最小堆的数据结构存放每个定时器，在这不做详细说明）后，再通过 goparkunlock 实现把当前G休眠，这里看到了上面提到的 gopark 方法进行调度循环的上下文切换。</p>
<p>在 addtimerLocked 方法的最下面有个逻辑在运行期间开启了'全局时间事件驱动器'timerproc,该方法会全程遍历最小堆，寻找最早进入 timer 管理器的定时器，然后唤醒。他是怎么找到要唤醒哪个G的？回头看下 timeSleep 方法里把当时正在执行的G以及唤醒方法 goroutineReady 带到了每个定时器里，而在 timerproc 则通过找到期的定时器执行f(arg, seq)</p>
<p>即通过 goroutineReady 方法唤醒。方法调用过程: goroutineReady() -&gt; ready()</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runtime/time.go
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">timeSleep</span><span class="p">(</span><span class="nx">ns</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">ns</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="nx">t</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">timer</span>
  <span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">timer</span><span class="p">)</span>
    <span class="nf">getg</span><span class="p">().</span><span class="nx">timer</span> <span class="p">=</span> <span class="nx">t</span>
  <span class="p">}</span>
  <span class="o">*</span><span class="nx">t</span> <span class="p">=</span> <span class="nx">timer</span><span class="p">{}</span> <span class="c1">// 每个定时任务都创建一个timer
</span><span class="c1"></span>  <span class="nx">t</span><span class="p">.</span><span class="nx">when</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">+</span> <span class="nx">ns</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">f</span> <span class="p">=</span> <span class="nx">goroutineReady</span> <span class="c1">// 记录唤醒该G的方法,唤醒时通过该方法执行唤醒
</span><span class="c1"></span>  <span class="nx">t</span><span class="p">.</span><span class="nx">arg</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>       <span class="c1">// 把timer与当前G关联,时间到了唤醒时通过该参数找到所在的G
</span><span class="c1"></span>  <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">timers</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
  <span class="nf">addtimerLocked</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>                                      <span class="c1">// 把timer添加到最小堆里
</span><span class="c1"></span>  <span class="nf">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">timers</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="s">&#34;sleep&#34;</span><span class="p">,</span> <span class="nx">traceEvGoSleep</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// 切到G0让出CPU,进入休眠
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>总结：time.Sleep 想要进入阻塞(休眠)状态，其实是通过 gopark 方法给自己标记个_Gwaiting 状态，然后把自己所占用的CPU线程资源给释放出来，继续执行调度任务，调度其它的G来运行。而唤醒是通过把G更改回_Grunnable 状态后，然后把G放入到P的待运行队列里等待执行。通过这点还可以看出休眠中的G其实并不占用 CPU 资源，最多是占用内存，是个很轻量级的阻塞。</p>
<h5 id="mutex">Mutex</h5>
<p>Mutex.Lock 方法通过调用 runtime_SemacquireMutex 最终还是调用 goparkunlock 实现把G进入到休眠状态。在进入休眠之前先把自己加入到队列里 root.queue(addr, s, lifo)，在 queue 方法里，记录了当前的G，以便以后找到并唤醒。</p>
<p>Mutex. Unlock 方法通过调用 runtime_Semrelease 最终还是调用 goready 实现把G唤醒。</p>
<h5 id="channel">Channel</h5>
<p><strong>发送端：</strong></p>
<p>当给一个 chan 发送消息的时候，实质触发的方法是 chansend。在该方法里不是先进入休眠状态。</p>
<p>1）如果此时有接收者接收这个 chan 的消息则直接把数据通过 send 方法扔给接收者，并唤醒接收者的G，然后当前G则继续执行。</p>
<p>2）如果没有接收者，就把数据 copy 到 chan 的临时内存里，且内存没有满就继续执行当前G。</p>
<p>3）如果没有接收者且 chan 满了，依然是通过 goparkunlock 方法进入休眠。在休眠前把当前的G相关信息存到队列（sendq）以便有接收者接收数据的时候唤醒当前G。</p>
<p><strong>接收端：</strong></p>
<p>chanrecv 方法是在 chan 接收者的地方调用的方法。</p>
<p>1）如果有发送者被休眠，则取出数据然后唤醒发送者，当前接收者的G拿到数据继续执行。</p>
<p>2）如果没有等待的发送者就看下有没有发送的数据还没被接收，有的话就直接取出数据然后返回，当前接收者的G拿到数据继续执行。（注意：这里取的数据不是正在等待的 sender 的数据，而是从 chan 的开头的内存取，如果是 sender 的数据则读出来的数据顺序就乱了）</p>
<p>3）如果即没有发送者，chan 里也没数据就通过 goparkunlock 进行休眠，在休眠之前把当前的G相关信息存到 recvq 里面，以便有数据时找到要唤醒的G。</p>
<h4 id="qa">QA</h4>
<p>1.为什么p的local queue 可无锁访问 任务窃取的时候需要加锁嘛？
答：原子操作。</p>
<h3 id="垃圾回收">垃圾回收</h3>
<ul>
<li><a href="https://segmentfault.com/a/1190000020086769">三色标记</a></li>
<li>哪些情况下不被垃圾回收？</li>
<li>强三色和弱三色</li>
<li>写屏障</li>
</ul>
<h3 id="channel-1">channel</h3>
<h3 id="slice">slice</h3>
<h3 id="map">map</h3>
<ul>
<li>怎么解决读写并发（除了锁）</li>
<li>sync.Map 了解一下</li>
</ul>
<h3 id="http库">http库</h3>
<h3 id="interface">interface</h3>
<ul>
<li>iface
<ul>
<li>有方法的interface{}</li>
</ul>
</li>
<li>eface
<ul>
<li>没有方法的interface{}</li>
</ul>
</li>
</ul>
<h3 id="其他">其他</h3>
<h4 id="变量逃逸">变量逃逸</h4>
<h2 id="项目经验">项目经验</h2>
<h3 id="微服务">微服务</h3>
<h3 id="服务限流限速熔断">服务限流限速熔断</h3>
<p><a href="https://mp.weixin.qq.com/s/n9wpL6uSjza2nEprLbJDKw">服务熔断</a></p>
<h3 id="提现个人能力的点">提现个人能力的点</h3>
<ul>
<li>引入 etcd，基于 etcd 开发服务间通信的基础库 解决服务间通信和服务选举问题</li>
<li>引入nsq 修改源码 支持延迟消息持久化，二次开发 SDK 支持连接池</li>
<li>开发项目基础架构，一键生成新项目</li>
<li>开发基础 lib 包，wechat 包 ，common 包， eventbus-lib ，htlog-go 提高开发效率</li>
<li>规范化项目开发+上线流程，规范化架构</li>
<li>开发统一的内部消息服务，规范内服飞书/企业微信消息的发送</li>
<li>后台服务单点登录功能</li>
<li>服务拆解 向微服务方向改进</li>
<li>敏感词 建立词库结构（B-tree）黑白名单的缓存</li>
<li>自我介绍：
<ul>
<li>部门内的定位：后端开发+基础服务搭建</li>
<li>关注新技术 表现出持续学习</li>
<li>岗位匹配度</li>
</ul>
</li>
</ul>
<h3 id="系统设计">系统设计</h3>
<p><a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md">系统设计</a></p>
<h2 id="算法">算法</h2>
<p><a href="https://github.com/yusank/leetcode">github项目</a></p>
<h3 id="堆">堆</h3>
<ul>
<li>最小堆/最大堆</li>
<li>topK 算法的实现： hash 加 小顶堆</li>
<li>堆排序</li>
</ul>
<h3 id="链表">链表</h3>
<ul>
<li>单向链表/双向链表</li>
<li>链表找环（快慢指针）</li>
<li>链表局部/全部旋转（即修改方向）</li>
</ul>
<p>问题：查找倒数第 K 个节点</p>
<h3 id="二叉树">二叉树</h3>
<ul>
<li>
<p>二叉树的五种遍历</p>
<ul>
<li>前序 根-左-右</li>
<li>中序 左-根-右</li>
<li>后序 左-右-根</li>
<li>层次遍历 一层一层从左到右</li>
<li>锯齿遍历（s型遍历）每一层换方向</li>
</ul>
</li>
<li>
<p>二叉树查找</p>
<ul>
<li>查找最近路劲</li>
<li>查找共同祖先（最近祖先）</li>
</ul>
</li>
<li>
<p>二叉树的转换</p>
<ul>
<li>左右转换</li>
</ul>
</li>
<li>
<p>其他</p>
<ul>
<li>打印右视图左视图（即打印每一层的最右边或最左边）</li>
</ul>
</li>
</ul>
<h3 id="回溯法递归法">回溯法递归法</h3>
<p>理解回溯递归的每一层堆栈情况，学会什么情况下使用回溯/递归</p>
<h3 id="动态规划dp">动态规划（DP）</h3>
<p>找路线数量，爬台阶，背包问题
数组等和分组问题</p>
<h2 id="计算机基础">计算机基础</h2>
<h3 id="基础概念">基础概念</h3>
<p>问题：查看当前服务器的性能&amp;查看 go 开的线程数？</p>
<p>问题：进程线程协程的区别？</p>
<p>问题：select poll epoll 的区别？</p>
<ul>
<li>select 有大小限制 效率低 对 socket 是线性扫描  同步多路复用 O(n)</li>
<li>poll 与 select 类似 但是用的链表结构 所以没有大小限制 同步多路复用 O(n)</li>
<li>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）</li>
</ul>
<p><a href="https://www.cnblogs.com/aspirant/p/9166944.html">相关链接</a></p>
<h3 id="tcpudp">tcp/udp</h3>
<p><a href="https://mp.weixin.qq.com/s/THQ9zAJ4yso1knGtwKcw_Q">tcp必备</a></p>
<p>问题：tcp time await 发生在哪端？</p>
<p>A: 发生在四次挥手时客户端，最后会等2MSL。</p>
<p>问题：为什么客户端最后还要等待2MSL？</p>
<p>答：MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失。站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。如果客户端收到服务端的FIN+ACK报文后，发送一个ACK给服务端之后就“自私”地立马进入CLOSED状态，可能会导致服务端无法确认收到最后的ACK指令，也就无法进入CLOSED状态，这是客户端不负责任的表现。第二，防止失效请求。防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<p>在TIME_WAIT状态无法真正释放句柄资源，在此期间，Socket中使用的本地端口在默认情况下不能再被使用。该限制对于客户端机器来说是无所谓的，但对于高并发服务器来说，会极大地限制有效连接的创建数量，称为性能瓶颈。所以建议将高并发服务器TIME_WAIT超时时间调小。RFC793中规定MSL为2分钟。但是在当前的高速网络中，2分钟的等待时间会造成资源的极大浪费，在高并发服务器上通常会使用更小的值。</p>
<h3 id="http">http</h3>
<p><a href="https://zhuanlan.zhihu.com/p/159274359?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io">谈谈HTTP</a></p>
<p>https 相关</p>
<h3 id="grpc">grpc</h3>
<h2 id="其他qa">其他QA</h2>
<ul>
<li>Q: 解释graceful 平滑重启？</li>
<li>Q：</li>
</ul>
]]></content><category scheme="https://yusank.github.io/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术"/><category scheme="https://yusank.github.io/categories/%E7%BB%8F%E9%AA%8C/" term="经验" label="经验"/><category scheme="https://yusank.github.io/tags/go/" term="go" label="go"/></entry><entry><title type="text">Go 语言开发及常用库的使用规范(语言篇)</title><link rel="alternate" type="text/html" href="https://yusank.github.io/posts/go-standard/"/><id>https://yusank.github.io/posts/go-standard/</id><updated>2021-07-04T08:33:24+00:00</updated><published>2020-11-25T16:24:41+08:00</published><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><summary type="html">语言篇，提出常见的开发上的不好的、不规范的写法，并给出更好的写法。 Uber 是一家美国硅谷的科技公司，也是 Go 语言的早期 adopt……</summary><content type="html"><![CDATA[<p>语言篇，提出常见的开发上的不好的、不规范的写法，并给出更好的写法。
<a href="https://www.uber.com/">Uber</a> 是一家美国硅谷的科技公司，也是 Go 语言的早期 adopter。其开源了很多 golang 项目，诸如被 Gopher 圈熟知的 <a href="https://github.com/uber-go/zap">zap</a>、<a href="https://github.com/jaegertracing/jaeger">jaeger</a> 等。2018 年年末 Uber 将内部的 <a href="https://github.com/uber-go/guide">Go 风格规范</a> 开源到 GitHub，经过一年的积累和更新，该规范已经初具规模，并受到广大 Gopher 的关注。本文是该规范的中文版本，并加以作者个人的一些看法，非 <code>uber</code> 官方的建议和看法 本人会加以标注。</p>
<h2 id="介绍">介绍</h2>
<p>样式 (style) 是支配我们代码的惯例。术语<code>样式</code>有点用词不当，因为这些约定涵盖的范围不限于由 gofmt 替我们处理的源文件格式。</p>
<p>本指南的目的是通过详细描述在 Uber 编写 Go 代码的注意事项来管理这种复杂性。这些规则的存在是为了使代码库易于管理，同时仍然允许工程师更有效地使用 Go 语言功能。</p>
<p>该指南最初由 <a href="https://github.com/prashantv">Prashant Varanasi</a> 和 <a href="https://github.com/nomis52">Simon Newton</a> 编写，目的是使一些同事能快速使用 Go。多年来，该指南已根据其他人的反馈进行了修改。</p>
<p>本文档记录了我们在 Uber 遵循的 Go 代码中的惯用约定。其中许多是 Go 的通用准则，而其他扩展准则依赖于下面外部的指南：</p>
<ol>
<li><a href="https://golang.org/doc/effective_go.html">Effective Go</a></li>
<li><a href="https://github.com/golang/go/wiki/CodeReviewComments">The Go common mistakes guide</a></li>
</ol>
<p>所有代码都应该通过<code>golint</code>和<code>go vet</code>的检查并无错误。我们建议您将编辑器设置为：</p>
<ul>
<li>保存时运行 <code>goimports</code></li>
<li>运行 <code>golint</code> 和 <code>go vet</code> 检查错误</li>
</ul>
<p>您可以在以下 Go 编辑器工具支持页面中找到更为详细的信息：
<a href="https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins">https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins</a></p>
<h2 id="指导原则">指导原则</h2>
<h3 id="指向-interface-的指针">指向 interface 的指针</h3>
<p>您几乎不需要指向接口类型的指针。您应该将接口作为值进行传递，在这样的传递过程中，实质上传递的底层数据仍然可以是指针。</p>
<p>接口实质上在底层用两个字段表示：</p>
<ol>
<li>一个指向某些特定类型信息的指针。您可以将其视为&quot;type&quot;。</li>
<li>数据指针。如果存储的数据是指针，则直接存储。如果存储的数据是一个值，则存储指向该值的指针。</li>
</ol>
<p>如果希望接口方法修改基础数据，则必须使用指针传递(将对象指针赋值给接口变量)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">F</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">S1</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">S1</span><span class="p">)</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">S2</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">S2</span><span class="p">)</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>

<span class="c1">// f1.f()无法修改底层数据
</span><span class="c1">// f2.f() 可以修改底层数据,给接口变量f2赋值时使用的是对象指针
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">f1</span> <span class="nx">F</span><span class="o">:=</span> <span class="nx">S1</span><span class="p">{}</span>
<span class="kd">var</span> <span class="nx">f2</span> <span class="nx">F</span><span class="o">:=</span> <span class="o">&amp;</span><span class="nx">S2</span><span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="interface-合理性验证">Interface 合理性验证</h3>
<p>在编译时验证接口的符合性。这包括：</p>
<ul>
<li>将实现特定接口的导出类型作为接口API 的一部分进行检查</li>
<li>实现同一接口的(导出和非导出)类型属于实现类型的集合</li>
<li>任何违反接口合理性检查的场景,都会终止编译,并通知给用户</li>
</ul>
<p>补充:上面3条是编译器对接口的检查机制,
大体意思是错误使用接口会在编译期报错.
所以可以利用这个机制让部分问题在编译期暴露.</p>
<table>
<thead>
<tr>
<th>Bad</th>
<th>Good</th>
</tr>
</thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 如果Handler没有实现http.Handler,会在运行时报错
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Handler</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">Handler</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span>
  <span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span>
  <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Handler</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// 用于触发编译期的接口的合理性检查机制
</span><span class="c1">// 如果Handler没有实现http.Handler,会在编译期报错
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">_</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">Handler</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">Handler</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span>
  <span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span>
  <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>如果 <code>*Handler</code> 与 <code>http.Handler</code> 的接口不匹配,
那么语句 <code>var _ http.Handler = (*Handler)(nil)</code> 将无法编译通过.</p>
<p>赋值的右边应该是断言类型的零值。
对于指针类型（如 <code>*Handler</code>）、切片和映射，这是 <code>nil</code>；
对于结构类型，这是空结构。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">LogHandler</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">h</span>   <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span>
  <span class="nx">log</span> <span class="o">*</span><span class="nx">zap</span><span class="p">.</span><span class="nx">Logger</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span> <span class="p">=</span> <span class="nx">LogHandler</span><span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">LogHandler</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span>
  <span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span>
  <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="接收器-receiver-与接口">接收器 (receiver) 与接口</h3>
<p>使用值接收器的方法既可以通过值调用，也可以通过指针调用。</p>
<p>带指针接收器的方法只能通过指针或 <a href="https://golang.org/ref/spec#Method_values">addressable values</a>调用.</p>
<p>例如，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">S</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">data</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">S</span><span class="p">)</span> <span class="nf">Read</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">data</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">S</span><span class="p">)</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">s</span><span class="p">.</span><span class="nx">data</span> <span class="p">=</span> <span class="nx">str</span>
<span class="p">}</span>

<span class="nx">sVals</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="nx">S</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s">&#34;A&#34;</span><span class="p">}}</span>

<span class="c1">// 你只能通过值调用 Read
</span><span class="c1"></span><span class="nx">sVals</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">Read</span><span class="p">()</span>

<span class="c1">// 这不能编译通过：
</span><span class="c1">//  sVals[1].Write(&#34;test&#34;)
</span><span class="c1"></span>
<span class="nx">sPtrs</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="nx">S</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s">&#34;A&#34;</span><span class="p">}}</span>

<span class="c1">// 通过指针既可以调用 Read，也可以调用 Write 方法
</span><span class="c1"></span><span class="nx">sPtrs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">Read</span><span class="p">()</span>
<span class="nx">sPtrs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">Write</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>类似的,即使方法有了值接收器,也同样可以用指针接收器来满足接口.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">F</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">S1</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">S1</span><span class="p">)</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">S2</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">S2</span><span class="p">)</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>

<span class="nx">s1Val</span> <span class="o">:=</span> <span class="nx">S1</span><span class="p">{}</span>
<span class="nx">s1Ptr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">S1</span><span class="p">{}</span>
<span class="nx">s2Val</span> <span class="o">:=</span> <span class="nx">S2</span><span class="p">{}</span>
<span class="nx">s2Ptr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">S2</span><span class="p">{}</span>

<span class="kd">var</span> <span class="nx">i</span> <span class="nx">F</span>
<span class="nx">i</span> <span class="p">=</span> <span class="nx">s1Val</span>
<span class="nx">i</span> <span class="p">=</span> <span class="nx">s1Ptr</span>
<span class="nx">i</span> <span class="p">=</span> <span class="nx">s2Ptr</span>

<span class="c1">//  下面代码无法通过编译。因为 s2Val 是一个值，而 S2 的 f 方法中没有使用值接收器
</span><span class="c1">//   i = s2Val
</span></code></pre></td></tr></table>
</div>
</div><p><a href="https://golang.org/doc/effective_go.html">Effective Go</a> 中有一段关于 <a href="https://golang.org/doc/effective_go.html#pointers_vs_values">pointers vs. values</a> 的精彩讲解。</p>
<p>补充:</p>
<ul>
<li>一个类型可以有值接收器方法集和指针接收器方法集
<ul>
<li>值接收器方法集是指针接收器方法集的子集,反之不是</li>
</ul>
</li>
<li>规则
<ul>
<li>值对象只可以使用值接收器方法集</li>
<li>指针对象可以使用 值接收器方法集 + 指针接收器方法集</li>
</ul>
</li>
<li>接口的匹配(或者叫实现)
<ul>
<li>类型实现了接口的所有方法,叫匹配</li>
<li>具体的讲,要么是类型的值方法集匹配接口,要么是指针方法集匹配接口</li>
</ul>
</li>
</ul>
<p>具体的匹配分两种:</p>
<ul>
<li>值方法集和接口匹配
<ul>
<li>给接口变量赋值的不管是值还是指针对象,都ok,因为都包含值方法集</li>
</ul>
</li>
<li>指针方法集和接口匹配
<ul>
<li>只能将指针对象赋值给接口变量,因为只有指针方法集和接口匹配</li>
<li>如果将值对象赋值给接口变量,会在编译期报错(会触发接口合理性检查机制)</li>
</ul>
</li>
</ul>
<p>为啥 i = s2Val 会报错,因为值方法集和接口不匹配.</p>
<h3 id="零值-mutex-是有效的">零值 Mutex 是有效的</h3>
<p>零值 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code> 是有效的。所以指向 mutex 的指针基本是不必要的。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">mu</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">)</span>
<span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>如果你使用结构体指针，mutex 可以非指针形式作为结构体的组成字段，或者更好的方式是直接嵌入到结构体中。
如果是私有结构体类型或是要实现 Mutex 接口的类型，我们可以使用嵌入 mutex 的方法：</p>
<table>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">smap</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// only for unexported types（仅适用于非导出类型）
</span><span class="c1"></span>
  <span class="nx">data</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newSMap</span><span class="p">()</span> <span class="o">*</span><span class="nx">smap</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">smap</span><span class="p">{</span>
    <span class="nx">data</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">smap</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">k</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

  <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SMap</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// 对于导出类型，请使用私有锁
</span><span class="c1"></span>
  <span class="nx">data</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewSMap</span><span class="p">()</span> <span class="o">*</span><span class="nx">SMap</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">SMap</span><span class="p">{</span>
    <span class="nx">data</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">SMap</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">k</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

  <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tr>
<tr>
<td>为私有类型或需要实现互斥接口的类型嵌入。</td>
<td>对于导出的类型，请使用专用字段。</td>
</tr>
</tbody></table>
<h3 id="在边界处拷贝-slices-和-maps">在边界处拷贝 Slices 和 Maps</h3>
<p>slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。</p>
<h4 id="接收-slices-和-maps">接收 Slices 和 Maps</h4>
<p>请记住，当 map 或 slice 作为函数参数传入时，如果您存储了对它们的引用，则用户可以对其进行修改。</p>
<table>
<thead><tr><th>Bad</th> <th>Good</th></tr></thead>
<tbody>
<tr>
<td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Driver</span><span class="p">)</span> <span class="nf">SetTrips</span><span class="p">(</span><span class="nx">trips</span> <span class="p">[]</span><span class="nx">Trip</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">d</span><span class="p">.</span><span class="nx">trips</span> <span class="p">=</span> <span class="nx">trips</span>
<span class="p">}</span>

<span class="nx">trips</span> <span class="o">:=</span> <span class="o">...</span>
<span class="nx">d1</span><span class="p">.</span><span class="nf">SetTrips</span><span class="p">(</span><span class="nx">trips</span><span class="p">)</span>

<span class="c1">// 你是要修改 d1.trips 吗？
</span><span class="c1"></span><span class="nx">trips</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div></td>
<td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Driver</span><span class="p">)</span> <span class="nf">SetTrips</span><span class="p">(</span><span class="nx">trips</span> <span class="p">[]</span><span class="nx">Trip</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">d</span><span class="p">.</span><span class="nx">trips</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">Trip</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">trips</span><span class="p">))</span>
  <span class="nb">copy</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">trips</span><span class="p">,</span> <span class="nx">trips</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">trips</span> <span class="o">:=</span> <span class="o">...</span>
<span class="nx">d1</span><span class="p">.</span><span class="nf">SetTrips</span><span class="p">(</span><span class="nx">trips</span><span class="p">)</span>

<span class="c1">// 这里我们修改 trips[0]，但不会影响到 d1.trips
</span><span class="c1"></span><span class="nx">trips</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div></td>
</tr>
</tbody>
</table>
<h4 id="返回-slices-或-maps">返回 slices 或 maps</h4>
<p>同样，请注意用户对暴露内部状态的 map 或 slice 的修改。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Stats</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>

  <span class="nx">counters</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// Snapshot 返回当前状态。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Stats</span><span class="p">)</span> <span class="nf">Snapshot</span><span class="p">()</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

  <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">counters</span>
<span class="p">}</span>

<span class="c1">// snapshot 不再受互斥锁保护
</span><span class="c1">// 因此对 snapshot 的任何访问都将受到数据竞争的影响
</span><span class="c1">// 影响 stats.counters
</span><span class="c1"></span><span class="nx">snapshot</span> <span class="o">:=</span> <span class="nx">stats</span><span class="p">.</span><span class="nf">Snapshot</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Stats</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>

  <span class="nx">counters</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Stats</span><span class="p">)</span> <span class="nf">Snapshot</span><span class="p">()</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

  <span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">counters</span><span class="p">))</span>
  <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">counters</span> <span class="p">{</span>
    <span class="nx">result</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// snapshot 现在是一个拷贝
</span><span class="c1"></span><span class="nx">snapshot</span> <span class="o">:=</span> <span class="nx">stats</span><span class="p">.</span><span class="nf">Snapshot</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<h3 id="使用-defer-释放资源">使用 defer 释放资源</h3>
<p>使用 defer 释放资源，诸如文件和锁。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">p</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">count</span> <span class="p">&lt;</span> <span class="mi">10</span> <span class="p">{</span>
  <span class="nx">p</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">count</span>
<span class="p">}</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
<span class="nx">newCount</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">count</span>
<span class="nx">p</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

<span class="k">return</span> <span class="nx">newCount</span>

<span class="c1">// 当有多个 return 分支时，很容易遗忘 unlock
</span></code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">p</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
<span class="k">defer</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">count</span> <span class="p">&lt;</span> <span class="mi">10</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">count</span>
<span class="p">}</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
<span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">count</span>

<span class="c1">// 更可读
</span></code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>Defer 的开销非常小，只有在您可以证明函数执行时间处于纳秒级的程度时，才应避免这样做。使用 defer 提升可读性是值得的，因为使用它们的成本微不足道。尤其适用于那些不仅仅是简单内存访问的较大的方法，在这些方法中其他计算的资源消耗远超过 <code>defer</code>。</p>
<h3 id="channel-的-size-要么是-1要么是无缓冲的">Channel 的 size 要么是 1，要么是无缓冲的</h3>
<p>channel 通常 size 应为 1 或是无缓冲的。默认情况下，channel 是无缓冲的，其 size 为零。任何其他尺寸都必须经过严格的审查。我们需要考虑如何确定大小，考虑是什么阻止了 channel 在高负载下和阻塞写时的写入，以及当这种情况发生时系统逻辑有哪些变化。(翻译解释：按照原文意思是需要界定通道边界，竞态条件，以及逻辑上下文梳理)</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 应该足以满足任何情况！
</span><span class="c1"></span><span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 大小：1
</span><span class="c1"></span><span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 或者
</span><span class="c1">// 无缓冲 channel，大小为 0
</span><span class="c1"></span><span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<h3 id="枚举从-1-开始">枚举从 1 开始</h3>
<p>在 Go 中引入枚举的标准方法是声明一个自定义类型和一个使用了 iota 的 const 组。由于变量的默认值为 0，因此通常应以非零值开头枚举。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Operation</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">Add</span> <span class="nx">Operation</span> <span class="p">=</span> <span class="kc">iota</span>
  <span class="nx">Subtract</span>
  <span class="nx">Multiply</span>
<span class="p">)</span>

<span class="c1">// Add=0, Subtract=1, Multiply=2
</span></code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Operation</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">Add</span> <span class="nx">Operation</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="nx">Subtract</span>
  <span class="nx">Multiply</span>
<span class="p">)</span>

<span class="c1">// Add=1, Subtract=2, Multiply=3
</span></code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>在某些情况下，使用零值是有意义的（枚举从零开始），例如，当零值是理想的默认行为时。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">LogOutput</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">LogToStdout</span> <span class="nx">LogOutput</span> <span class="p">=</span> <span class="kc">iota</span>
  <span class="nx">LogToFile</span>
  <span class="nx">LogToRemote</span>
<span class="p">)</span>

<span class="c1">// LogToStdout=0, LogToFile=1, LogToRemote=2
</span></code></pre></td></tr></table>
</div>
</div><h3 id="使用-time-处理时间">使用 time 处理时间</h3>
<p>时间处理很复杂。关于时间的错误假设通常包括以下几点。</p>
<ol>
<li>一天有 24 小时</li>
<li>一小时有 60 分钟</li>
<li>一周有七天</li>
<li>一年 365 天</li>
<li><a href="https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time">还有更多</a></li>
</ol>
<p>例如，<em>1</em> 表示在一个时间点上加上 24 小时并不总是产生一个新的日历日。</p>
<p>因此，在处理时间时始终使用 <a href="https://golang.org/pkg/time/"><code>&quot;time&quot;</code></a> 包，因为它有助于以更安全、更准确的方式处理这些不正确的假设。</p>
<h4 id="使用-timetime-表达瞬时时间">使用 <code>time.Time</code> 表达瞬时时间</h4>
<p>在处理时间的瞬间时使用 <a href="https://golang.org/pkg/time/#Time"><code>time.time</code></a>，在比较、添加或减去时间时使用 <code>time.Time</code> 中的方法。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">isActive</span><span class="p">(</span><span class="nx">now</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">start</span> <span class="o">&lt;=</span> <span class="nx">now</span> <span class="o">&amp;&amp;</span> <span class="nx">now</span> <span class="p">&lt;</span> <span class="nx">stop</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">isActive</span><span class="p">(</span><span class="nx">now</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">start</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span> <span class="o">||</span> <span class="nx">start</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">now</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="nx">now</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">stop</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<h4 id="使用-timeduration-表达时间段">使用 <code>time.Duration</code> 表达时间段</h4>
<p>在处理时间段时使用 <a href="https://golang.org/pkg/time/#Duration"><code>time.Duration</code></a> .</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">poll</span><span class="p">(</span><span class="nx">delay</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nf">poll</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1">// 是几秒钟还是几毫秒?
</span></code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">poll</span><span class="p">(</span><span class="nx">delay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nf">poll</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>回到第一个例子，在一个时间瞬间加上 24 小时，我们用于添加时间的方法取决于意图。如果我们想要下一个日历日(当前天的下一天)的同一个时间点，我们应该使用 <a href="https://golang.org/pkg/time/#Time.AddDate"><code>Time.AddDate</code></a>。但是，如果我们想保证某一时刻比前一时刻晚 24 小时，我们应该使用 <a href="https://golang.org/pkg/time/#Time.Add"><code>Time.Add</code></a>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">newDay</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">AddDate</span><span class="p">(</span><span class="mi">0</span> <span class="cm">/* years */</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* months */</span><span class="p">,</span> <span class="mi">1</span> <span class="cm">/* days */</span><span class="p">)</span>
<span class="nx">maybeNewDay</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">24</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="对外部系统使用-timetime-和-timeduration">对外部系统使用 <code>time.Time</code> 和 <code>time.Duration</code></h4>
<p>尽可能在与外部系统的交互中使用 <code>time.Duration</code> 和 <code>time.Time</code> 例如 :</p>
<ul>
<li>
<p>Command-line 标志: <a href="https://golang.org/pkg/flag/"><code>flag</code></a> 通过 <a href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code></p>
</li>
<li>
<p>JSON: <a href="https://golang.org/pkg/encoding/json/"><code>encoding/json</code></a> 通过其 <a href="https://golang.org/pkg/time/#Time.UnmarshalJSON"><code>UnmarshalJSON</code> method</a> 方法支持将 <code>time.Time</code> 编码为 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 字符串</p>
</li>
<li>
<p>SQL: <a href="https://golang.org/pkg/database/sql/"><code>database/sql</code></a> 支持将 <code>DATETIME</code> 或 <code>TIMESTAMP</code> 列转换为 <code>time.Time</code>，如果底层驱动程序支持则返回</p>
</li>
<li>
<p>YAML: <a href="https://godoc.org/gopkg.in/yaml.v2"><code>gopkg.in/yaml.v2</code></a> 支持将 <code>time.Time</code> 作为 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 字符串，并通过 <a href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code>。</p>
</li>
</ul>
<p>当不能在这些交互中使用 <code>time.Duration</code> 时，请使用 <code>int</code> 或 <code>float64</code>，并在字段名称中包含单位。</p>
<p>例如，由于 <code>encoding/json</code> 不支持 <code>time.Duration</code>，因此该单位包含在字段的名称中。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// {&#34;interval&#34;: 2}
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Config</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Interval</span> <span class="kt">int</span> <span class="s">`json:&#34;interval&#34;`</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// {&#34;intervalMillis&#34;: 2000}
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Config</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">IntervalMillis</span> <span class="kt">int</span> <span class="s">`json:&#34;intervalMillis&#34;`</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>当在这些交互中不能使用 <code>time.Time</code> 时，除非达成一致，否则使用 <code>string</code> 和 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 中定义的格式时间戳。默认情况下，<a href="https://golang.org/pkg/time/#Time.UnmarshalText"><code>Time.UnmarshalText</code></a> 使用此格式，并可通过 <a href="https://golang.org/pkg/time/#RFC3339"><code>time.RFC3339</code></a> 在 <code>Time.Format</code> 和 <code>time.Parse</code> 中使用。</p>
<p>尽管这在实践中并不成问题，但请记住，<code>&quot;time&quot;</code> 包不支持解析闰秒时间戳（<a href="https://github.com/golang/go/issues/8728">8728</a>），也不在计算中考虑闰秒（<a href="https://github.com/golang/go/issues/15190">15190</a>）。如果您比较两个时间瞬间，则差异将不包括这两个瞬间之间可能发生的闰秒。</p>
<h3 id="错误类型">错误类型</h3>
<p>Go 中有多种声明错误（Error) 的选项：</p>
<ul>
<li><a href="https://golang.org/pkg/errors/#New"><code>errors.New</code></a> 对于简单静态字符串的错误</li>
<li><a href="https://golang.org/pkg/fmt/#Errorf"><code>fmt.Errorf</code></a> 用于格式化的错误字符串</li>
<li>实现 <code>Error()</code> 方法的自定义类型</li>
<li>用 <a href="https://godoc.org/github.com/pkg/errors#Wrap"><code>&quot;pkg/errors&quot;.Wrap</code></a> 的 Wrapped errors</li>
</ul>
<p>返回错误时，请考虑以下因素以确定最佳选择：</p>
<ul>
<li>
<p>这是一个不需要额外信息的简单错误吗？如果是这样，<a href="https://golang.org/pkg/errors/#New"><code>errors.New</code></a> 足够了。</p>
</li>
<li>
<p>客户需要检测并处理此错误吗？如果是这样，则应使用自定义类型并实现该 <code>Error()</code> 方法。</p>
</li>
<li>
<p>您是否正在传播下游函数返回的错误？如果是这样，请查看本文后面有关错误包装 <a href="#%E9%94%99%E8%AF%AF%E5%8C%85%E8%A3%85" title="Error-Wrapping">section on error wrapping</a> 部分的内容。</p>
</li>
<li>
<p>否则 <a href="https://golang.org/pkg/fmt/#Errorf"><code>fmt.Errorf</code></a> 就可以了。</p>
</li>
</ul>
<p>如果客户端需要检测错误，并且您已使用创建了一个简单的错误 <a href="https://golang.org/pkg/errors/#New"><code>errors.New</code></a>，请使用一个错误变量。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// package foo
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">Open</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;could not open&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// package bar
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">use</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">foo</span><span class="p">.</span><span class="nf">Open</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#34;could not open&#34;</span> <span class="p">{</span>
      <span class="c1">// handle
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;unknown error&#34;</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// package foo
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">ErrCouldNotOpen</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;could not open&#34;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">Open</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">ErrCouldNotOpen</span>
<span class="p">}</span>

<span class="c1">// package bar
</span><span class="c1"></span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">foo</span><span class="p">.</span><span class="nf">Open</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">ErrCouldNotOpen</span> <span class="p">{</span>
    <span class="c1">// handle
</span><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;unknown error&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>如果您有可能需要客户端检测的错误，并且想向其中添加更多信息（例如，它不是静态字符串），则应使用自定义类型。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">open</span><span class="p">(</span><span class="nx">file</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;file %q not found&#34;</span><span class="p">,</span> <span class="nx">file</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">use</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;testfile.txt&#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">(),</span> <span class="s">&#34;not found&#34;</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// handle
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;unknown error&#34;</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">errNotFound</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">file</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="nx">errNotFound</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;file %q not found&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">file</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">open</span><span class="p">(</span><span class="nx">file</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">errNotFound</span><span class="p">{</span><span class="nx">file</span><span class="p">:</span> <span class="nx">file</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">use</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;testfile.txt&#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">errNotFound</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
      <span class="c1">// handle
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;unknown error&#34;</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>直接导出自定义错误类型时要小心，因为它们已成为程序包公共 API 的一部分。最好公开匹配器功能以检查错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// package foo
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">errNotFound</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">file</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="nx">errNotFound</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;file %q not found&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">file</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">IsNotFoundError</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">errNotFound</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">ok</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Open</span><span class="p">(</span><span class="nx">file</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">errNotFound</span><span class="p">{</span><span class="nx">file</span><span class="p">:</span> <span class="nx">file</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// package bar
</span><span class="c1"></span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">foo</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">foo</span><span class="p">.</span><span class="nf">IsNotFoundError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// handle
</span><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;unknown error&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="错误包装-error-wrapping">错误包装 (Error Wrapping)</h3>
<p>一个（函数/方法）调用失败时，有三种主要的错误传播方式：</p>
<ul>
<li>如果没有要添加的其他上下文，并且您想要维护原始错误类型，则返回原始错误。</li>
<li>添加上下文，使用 <a href="https://godoc.org/github.com/pkg/errors#Wrap"><code>&quot;pkg/errors&quot;.Wrap</code></a> 以便错误消息提供更多上下文 ,<a href="https://godoc.org/github.com/pkg/errors#Cause"><code>&quot;pkg/errors&quot;.Cause</code></a> 可用于提取原始错误。</li>
<li>如果调用者不需要检测或处理的特定错误情况，使用 <a href="https://golang.org/pkg/fmt/#Errorf"><code>fmt.Errorf</code></a>。</li>
</ul>
<p>建议在可能的地方添加上下文，以使您获得诸如“调用服务 foo：连接被拒绝”之类的更有用的错误，而不是诸如“连接被拒绝”之类的模糊错误。</p>
<p>在将上下文添加到返回的错误时，请避免使用“failed to”之类的短语以保持上下文简洁，这些短语会陈述明显的内容，并随着错误在堆栈中的渗透而逐渐堆积：</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">store</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span>
        <span class="s">&#34;failed to create new store: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">store</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span>
        <span class="s">&#34;new store: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><tr><td>
<pre><code>failed to x: failed to y: failed to create new store: the error
</code></pre></td><td>
<pre><code>x: y: new store: the error
</code></pre></td></tr>
</tbody></table>
<p>但是，一旦将错误发送到另一个系统，就应该明确消息是错误消息（例如使用<code>err</code>标记，或在日志中以”Failed”为前缀）。</p>
<p>另请参见 <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">Don't just check errors, handle them gracefully</a>. 不要只是检查错误，要优雅地处理错误</p>
<h3 id="处理类型断言失败">处理类型断言失败</h3>
<p><a href="https://golang.org/ref/spec#Type_assertions">type assertion</a> 的单个返回值形式针对不正确的类型将产生 panic。因此，请始终使用“comma ok”的惯用法。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">t</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">t</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
  <span class="c1">// 优雅地处理错误
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<!-- TODO: There are a few situations where the single assignment form is
fine. -->
<h3 id="不要-panic">不要 panic</h3>
<p>在生产环境中运行的代码必须避免出现 panic。panic 是 <a href="https://en.wikipedia.org/wiki/Cascading_failure">cascading failures</a> 级联失败的主要根源 。如果发生错误，该函数必须返回错误，并允许调用方决定如何处理它。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">run</span><span class="p">(</span><span class="nx">args</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;an argument is required&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">run</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">run</span><span class="p">(</span><span class="nx">args</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;an argument is required&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">run</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintln</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>panic/recover 不是错误处理策略。仅当发生不可恢复的事情（例如：nil 引用）时，程序才必须 panic。程序初始化是一个例外：程序启动时应使程序中止的不良情况可能会引起 panic。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">_statusTemplate</span> <span class="p">=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">).</span><span class="nf">Parse</span><span class="p">(</span><span class="s">&#34;_statusHTML&#34;</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>即使在测试代码中，也优先使用<code>t.Fatal</code>或者<code>t.FailNow</code>而不是 panic 来确保失败被标记。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// func TestFoo(t *testing.T)
</span><span class="c1"></span>
<span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">TempFile</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;test&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;failed to set up test&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// func TestFoo(t *testing.T)
</span><span class="c1"></span>
<span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">TempFile</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;test&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;failed to set up test&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<!-- TODO: Explain how to use _test packages. -->
<h3 id="使用-gouberorgatomic">使用 go.uber.org/atomic</h3>
<p>使用 <a href="https://golang.org/pkg/sync/atomic/">sync/atomic</a> 包的原子操作对原始类型 (<code>int32</code>, <code>int64</code>等）进行操作，因为很容易忘记使用原子操作来读取或修改变量。</p>
<p><a href="https://godoc.org/go.uber.org/atomic">go.uber.org/atomic</a> 通过隐藏基础类型为这些操作增加了类型安全性。此外，它包括一个方便的<code>atomic.Bool</code>类型。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">foo</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">running</span> <span class="kt">int32</span>  <span class="c1">// atomic
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span><span class="o">*</span> <span class="nx">foo</span><span class="p">)</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">SwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">f</span><span class="p">.</span><span class="nx">running</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
     <span class="c1">// already running…
</span><span class="c1"></span>     <span class="k">return</span>
  <span class="p">}</span>
  <span class="c1">// start the Foo
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">foo</span><span class="p">)</span> <span class="nf">isRunning</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="nx">running</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1">// race!
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">foo</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">running</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Bool</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">foo</span><span class="p">)</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nx">running</span><span class="p">.</span><span class="nf">Swap</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
     <span class="c1">// already running…
</span><span class="c1"></span>     <span class="k">return</span>
  <span class="p">}</span>
  <span class="c1">// start the Foo
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">foo</span><span class="p">)</span> <span class="nf">isRunning</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="nx">running</span><span class="p">.</span><span class="nf">Load</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<h3 id="避免可变全局变量">避免可变全局变量</h3>
<p>使用选择依赖注入方式避免改变全局变量。
既适用于函数指针又适用于其他值类型</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// sign.go
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">_timeNow</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span>
<span class="kd">func</span> <span class="nf">sign</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">now</span> <span class="o">:=</span> <span class="nf">_timeNow</span><span class="p">()</span>
  <span class="k">return</span> <span class="nf">signWithTime</span><span class="p">(</span><span class="nx">msg</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// sign.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">signer</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">now</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">newSigner</span><span class="p">()</span> <span class="o">*</span><span class="nx">signer</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">signer</span><span class="p">{</span>
    <span class="nx">now</span><span class="p">:</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">signer</span><span class="p">)</span> <span class="nf">Sign</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">now</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">now</span><span class="p">()</span>
  <span class="k">return</span> <span class="nf">signWithTime</span><span class="p">(</span><span class="nx">msg</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// sign_test.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TestSign</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">oldTimeNow</span> <span class="o">:=</span> <span class="nx">_timeNow</span>
  <span class="nx">_timeNow</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">someFixedTime</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">_timeNow</span> <span class="p">=</span> <span class="nx">oldTimeNow</span> <span class="p">}()</span>
  <span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">want</span><span class="p">,</span> <span class="nf">sign</span><span class="p">(</span><span class="nx">give</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// sign_test.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TestSigner</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">s</span> <span class="o">:=</span> <span class="nf">newSigner</span><span class="p">()</span>
  <span class="nx">s</span><span class="p">.</span><span class="nx">now</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">someFixedTime</span>
  <span class="p">}</span>
  <span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">want</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Sign</span><span class="p">(</span><span class="nx">give</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<h3 id="避免在公共结构中嵌入类型">避免在公共结构中嵌入类型</h3>
<p>这些嵌入的类型泄漏实现细节、禁止类型演化和模糊的文档。</p>
<p>假设您使用共享的 <code>AbstractList</code> 实现了多种列表类型，请避免在具体的列表实现中嵌入 <code>AbstractList</code>。
相反，只需手动将方法写入具体的列表，该列表将委托给抽象列表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">AbstractList</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="c1">// 添加将实体添加到列表中。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">AbstractList</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">e</span> <span class="nx">Entity</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// 移除从列表中移除实体。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">AbstractList</span><span class="p">)</span> <span class="nf">Remove</span><span class="p">(</span><span class="nx">e</span> <span class="nx">Entity</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ConcreteList 是一个实体列表。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ConcreteList</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="o">*</span><span class="nx">AbstractList</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ConcreteList 是一个实体列表。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ConcreteList</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">list</span> <span class="o">*</span><span class="nx">AbstractList</span>
<span class="p">}</span>
<span class="c1">// 添加将实体添加到列表中。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">ConcreteList</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">e</span> <span class="nx">Entity</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">l</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 移除从列表中移除实体。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">ConcreteList</span><span class="p">)</span> <span class="nf">Remove</span><span class="p">(</span><span class="nx">e</span> <span class="nx">Entity</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">l</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>Go 允许 <a href="https://golang.org/doc/effective_go.html#embedding">类型嵌入</a> 作为继承和组合之间的折衷。
外部类型获取嵌入类型的方法的隐式副本。
默认情况下，这些方法委托给嵌入实例的同一方法。</p>
<p>结构还获得与类型同名的字段。
所以，如果嵌入的类型是 public，那么字段是 public。为了保持向后兼容性，外部类型的每个未来版本都必须保留嵌入类型。</p>
<p>很少需要嵌入类型。
这是一种方便，可以帮助您避免编写冗长的委托方法。</p>
<p>即使嵌入兼容的抽象列表 <em>interface</em>，而不是结构体，这将为开发人员提供更大的灵活性来改变未来，但仍然泄露了具体列表使用抽象实现的细节。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// AbstractList 是各种实体列表的通用实现。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">AbstractList</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nf">Add</span><span class="p">(</span><span class="nx">Entity</span><span class="p">)</span>
  <span class="nf">Remove</span><span class="p">(</span><span class="nx">Entity</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// ConcreteList 是一个实体列表。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ConcreteList</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">AbstractList</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ConcreteList 是一个实体列表。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ConcreteList</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">list</span> <span class="o">*</span><span class="nx">AbstractList</span>
<span class="p">}</span>
<span class="c1">// 添加将实体添加到列表中。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">ConcreteList</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">e</span> <span class="nx">Entity</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">l</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 移除从列表中移除实体。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">ConcreteList</span><span class="p">)</span> <span class="nf">Remove</span><span class="p">(</span><span class="nx">e</span> <span class="nx">Entity</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">l</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>无论是使用嵌入式结构还是使用嵌入式接口，嵌入式类型都会限制类型的演化.</p>
<ul>
<li>向嵌入式接口添加方法是一个破坏性的改变。</li>
<li>删除嵌入类型是一个破坏性的改变。</li>
<li>即使使用满足相同接口的替代方法替换嵌入类型，也是一个破坏性的改变。</li>
</ul>
<p>尽管编写这些委托方法是乏味的，但是额外的工作隐藏了实现细节，留下了更多的更改机会，还消除了在文档中发现完整列表接口的间接性操作。</p>
<h3 id="避免使用内置名称">避免使用内置名称</h3>
<p>Go语言规范<a href="https://golang.org/ref/spec">language specification</a> 概述了几个内置的，
不应在Go项目中使用的名称标识<a href="https://golang.org/ref/spec#Predeclared_identifiers">predeclared identifiers</a>。</p>
<p>根据上下文的不同，将这些标识符作为名称重复使用，
将在当前作用域（或任何嵌套作用域）中隐藏原始标识符，或者混淆代码。
在最好的情况下，编译器会报错；在最坏的情况下，这样的代码可能会引入潜在的、难以恢复的错误。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="kt">error</span> <span class="kt">string</span>
<span class="c1">// `error` 作用域隐式覆盖
</span><span class="c1"></span>
<span class="c1">// or
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">handleErrorMessage</span><span class="p">(</span><span class="kt">error</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// `error` 作用域隐式覆盖
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">errorMessage</span> <span class="kt">string</span>
<span class="c1">// `error` 指向内置的非覆盖
</span><span class="c1"></span>
<span class="c1">// or
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">handleErrorMessage</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// `error` 指向内置的非覆盖
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Foo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 虽然这些字段在技术上不构成阴影，但`error`或`string`字符串的重映射现在是不明确的。
</span><span class="c1"></span>    <span class="kt">error</span>  <span class="kt">error</span>
    <span class="kt">string</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Foo</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">// `error` 和 `f.error` 在视觉上是相似的
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="kt">error</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Foo</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="c1">// `string` and `f.string` 在视觉上是相似的
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Foo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// `error` and `string` 现在是明确的。
</span><span class="c1"></span>    <span class="nx">err</span> <span class="kt">error</span>
    <span class="nx">str</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Foo</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Foo</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="nx">str</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>注意，编译器在使用预先分隔的标识符时不会生成错误，
但是诸如<code>go vet</code>之类的工具会正确地指出这些和其他情况下的隐式问题。</p>
<h3 id="避免使用-init">避免使用 <code>init()</code></h3>
<p>尽可能避免使用<code>init()</code>。当<code>init()</code>是不可避免或可取的，代码应先尝试：</p>
<ol>
<li>无论程序环境或调用如何，都要完全确定。</li>
<li>避免依赖于其他<code>init()</code>函数的顺序或副作用。虽然<code>init()</code>顺序是明确的，但代码可以更改，
因此<code>init()</code>函数之间的关系可能会使代码变得脆弱和容易出错。</li>
<li>避免访问或操作全局或环境状态，如机器信息、环境变量、工作目录、程序参数/输入等。</li>
<li>避免<code>I/O</code>，包括文件系统、网络和系统调用。</li>
</ol>
<p>不能满足这些要求的代码可能属于要作为<code>main()</code>调用的一部分（或程序生命周期中的其他地方），
或者作为<code>main()</code>本身的一部分写入。特别是，打算由其他程序使用的库应该特别注意完全确定性，
而不是执行“init magic”</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Foo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">_defaultFoo</span> <span class="nx">Foo</span>
<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">_defaultFoo</span> <span class="p">=</span> <span class="nx">Foo</span><span class="p">{</span>
        <span class="c1">// ...
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">_defaultFoo</span> <span class="p">=</span> <span class="nx">Foo</span><span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// or, 为了更好的可测试性:
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">_defaultFoo</span> <span class="p">=</span> <span class="nf">defaultFoo</span><span class="p">()</span>
<span class="kd">func</span> <span class="nf">defaultFoo</span><span class="p">()</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Foo</span><span class="p">{</span>
        <span class="c1">// ...
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Config</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">_config</span> <span class="nx">Config</span>
<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Bad: 基于当前目录
</span><span class="c1"></span>    <span class="nx">cwd</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getwd</span><span class="p">()</span>
    <span class="c1">// Bad: I/O
</span><span class="c1"></span>    <span class="nx">raw</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span>
        <span class="nx">path</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">cwd</span><span class="p">,</span> <span class="s">&#34;config&#34;</span><span class="p">,</span> <span class="s">&#34;config.yaml&#34;</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="nx">yaml</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">raw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">_config</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Config</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">func</span> <span class="nf">loadConfig</span><span class="p">()</span> <span class="nx">Config</span> <span class="p">{</span>
    <span class="nx">cwd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getwd</span><span class="p">()</span>
    <span class="c1">// handle err
</span><span class="c1"></span>    <span class="nx">raw</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span>
        <span class="nx">path</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">cwd</span><span class="p">,</span> <span class="s">&#34;config&#34;</span><span class="p">,</span> <span class="s">&#34;config.yaml&#34;</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="c1">// handle err
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">config</span> <span class="nx">Config</span>
    <span class="nx">yaml</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">raw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">config</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">config</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>考虑到上述情况，在某些情况下，<code>init()</code>可能更可取或是必要的，可能包括：</p>
<ul>
<li>
<p>不能表示为单个赋值的复杂表达式。</p>
</li>
<li>
<p>可插入的钩子，如<code>database/sql</code>、编码类型注册表等。</p>
</li>
<li>
<p>对<a href="https://cloud.google.com/functions/docs/bestpractices/tips#use_global_variables_to_reuse_objects_in_future_invocations">Google Cloud Functions</a>和其他形式的确定性预计算的优化。</p>
</li>
</ul>
<h3 id="追加时优先指定切片容量">追加时优先指定切片容量</h3>
<p>追加时优先指定切片容量</p>
<p>在尽可能的情况下，在初始化要追加的切片时为<code>make()</code>提供一个容量值。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">size</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">{</span>
    <span class="nx">data</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">size</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">{</span>
    <span class="nx">data</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
<tr><td>
<pre><code>BenchmarkBad-4    100000000    2.48s
</code></pre></td><td>
<pre><code>BenchmarkGood-4   100000000    0.21s
</code></pre></td></tr>
</tbody></table>
<h2 id="性能">性能</h2>
<p>性能方面的特定准则只适用于高频场景。</p>
<h3 id="优先使用-strconv-而不是-fmt">优先使用 strconv 而不是 fmt</h3>
<p>将原语转换为字符串或从字符串转换时，<code>strconv</code>速度比<code>fmt</code>快。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">s</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Int</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">s</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Int</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
<tr><td>
<pre><code>BenchmarkFmtSprint-4    143 ns/op    2 allocs/op
</code></pre></td><td>
<pre><code>BenchmarkStrconv-4    64.2 ns/op    1 allocs/op
</code></pre></td></tr>
</tbody></table>
<h3 id="避免字符串到字节的转换">避免字符串到字节的转换</h3>
<p>不要反复从固定字符串创建字节 slice。相反，请执行一次转换并捕获结果。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;Hello world&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;Hello world&#34;</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></tr>
<tr><td>
<pre><code>BenchmarkBad-4   50000000   22.2 ns/op
</code></pre></td><td>
<pre><code>BenchmarkGood-4  500000000   3.25 ns/op
</code></pre></td></tr>
</tbody></table>
<h3 id="指定容器容量">指定容器容量</h3>
<p>尽可能指定容器容量，以便为容器预先分配内存。这将在添加元素时最小化后续分配（通过复制和调整容器大小）。</p>
<h4 id="指定map容量提示">指定Map容量提示</h4>
<p>在尽可能的情况下，在使用 <code>make()</code> 初始化的时候提供容量信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">T1</span><span class="p">]</span><span class="nx">T2</span><span class="p">,</span> <span class="nx">hint</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>向<code>make()</code>提供容量提示会在初始化时尝试调整map的大小，这将减少在将元素添加到map时为map重新分配内存。</p>
<p>注意，与slices不同。map capacity提示并不保证完全的抢占式分配，而是用于估计所需的hashmap bucket的数量。
因此，在将元素添加到map时，甚至在指定map容量时，仍可能发生分配。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">os</span><span class="p">.</span><span class="nx">FileInfo</span><span class="p">)</span>

<span class="nx">files</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadDir</span><span class="p">(</span><span class="s">&#34;./files&#34;</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">files</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">[</span><span class="nx">f</span><span class="p">.</span><span class="nf">Name</span><span class="p">()]</span> <span class="p">=</span> <span class="nx">f</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">
<span class="nx">files</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadDir</span><span class="p">(</span><span class="s">&#34;./files&#34;</span><span class="p">)</span>

<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">os</span><span class="p">.</span><span class="nx">FileInfo</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">files</span><span class="p">))</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">files</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">[</span><span class="nx">f</span><span class="p">.</span><span class="nf">Name</span><span class="p">()]</span> <span class="p">=</span> <span class="nx">f</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
<tr><td>
<p><code>m</code> 是在没有大小提示的情况下创建的； 在运行时可能会有更多分配。</p>
</td><td>
<p><code>m</code> 是有大小提示创建的；在运行时可能会有更少的分配。</p>
</td></tr>
</tbody></table>
<h4 id="指定切片容量">指定切片容量</h4>
<p>在尽可能的情况下，在使用<code>make()</code>初始化切片时提供容量信息，特别是在追加切片时。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">length</span><span class="p">,</span> <span class="nx">capacity</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>与maps不同，slice capacity不是一个提示：编译器将为提供给<code>make()</code>的slice的容量分配足够的内存，
这意味着后续的append()`操作将导致零分配（直到slice的长度与容量匹配，在此之后，任何append都可能调整大小以容纳其他元素）。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">size</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">{</span>
    <span class="nx">data</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">size</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">{</span>
    <span class="nx">data</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
<tr><td>
<pre><code>BenchmarkBad-4    100000000    2.48s
</code></pre></td><td>
<pre><code>BenchmarkGood-4   100000000    0.21s
</code></pre></td></tr>
</tbody></table>
<h2 id="规范">规范</h2>
<h3 id="一致性">一致性</h3>
<p>本文中概述的一些标准都是客观性的评估，是根据场景、上下文、或者主观性的判断；</p>
<p>但是最重要的是，<strong>保持一致</strong>.</p>
<p>一致性的代码更容易维护、是更合理的、需要更少的学习成本、并且随着新的约定出现或者出现错误后更容易迁移、更新、修复 bug</p>
<p>相反，在一个代码库中包含多个完全不同或冲突的代码风格会导致维护成本开销、不确定性和认知偏差。所有这些都会直接导致速度降低、代码审查痛苦、而且增加 bug 数量。</p>
<p>将这些标准应用于代码库时，建议在 package（或更大）级别进行更改，子包级别的应用程序通过将多个样式引入到同一代码中，违反了上述关注点。</p>
<h3 id="相似的声明放在一组">相似的声明放在一组</h3>
<p>Go 语言支持将相似的声明放在一个组内。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;a&#34;</span>
<span class="kn">import</span> <span class="s">&#34;b&#34;</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;a&#34;</span>
  <span class="s">&#34;b&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>这同样适用于常量、变量和类型声明：</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">const</span> <span class="nx">a</span> <span class="p">=</span> <span class="mi">1</span>
<span class="kd">const</span> <span class="nx">b</span> <span class="p">=</span> <span class="mi">2</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="mi">1</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="p">=</span> <span class="mi">2</span>

<span class="kd">type</span> <span class="nx">Area</span> <span class="kt">float64</span>
<span class="kd">type</span> <span class="nx">Volume</span> <span class="kt">float64</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
  <span class="nx">a</span> <span class="p">=</span> <span class="mi">1</span>
  <span class="nx">b</span> <span class="p">=</span> <span class="mi">2</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
  <span class="nx">a</span> <span class="p">=</span> <span class="mi">1</span>
  <span class="nx">b</span> <span class="p">=</span> <span class="mi">2</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="p">(</span>
  <span class="nx">Area</span> <span class="kt">float64</span>
  <span class="nx">Volume</span> <span class="kt">float64</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>仅将相关的声明放在一组。不要将不相关的声明放在一组。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Operation</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">Add</span> <span class="nx">Operation</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="nx">Subtract</span>
  <span class="nx">Multiply</span>
  <span class="nx">ENV_VAR</span> <span class="p">=</span> <span class="s">&#34;MY_ENV&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Operation</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">Add</span> <span class="nx">Operation</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="nx">Subtract</span>
  <span class="nx">Multiply</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">ENV_VAR</span> <span class="p">=</span> <span class="s">&#34;MY_ENV&#34;</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>分组使用的位置没有限制，例如：你可以在函数内部使用它们：</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">f</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">red</span> <span class="p">=</span> <span class="nx">color</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="mh">0xff0000</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">green</span> <span class="p">=</span> <span class="nx">color</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="mh">0x00ff00</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">blue</span> <span class="p">=</span> <span class="nx">color</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="mh">0x0000ff</span><span class="p">)</span>

  <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">f</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="p">(</span>
    <span class="nx">red</span>   <span class="p">=</span> <span class="nx">color</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="mh">0xff0000</span><span class="p">)</span>
    <span class="nx">green</span> <span class="p">=</span> <span class="nx">color</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="mh">0x00ff00</span><span class="p">)</span>
    <span class="nx">blue</span>  <span class="p">=</span> <span class="nx">color</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="mh">0x0000ff</span><span class="p">)</span>
  <span class="p">)</span>

  <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<h3 id="import-分组">import 分组</h3>
<p>导入应该分为两组：</p>
<ul>
<li>标准库</li>
<li>当前项目内的引用</li>
<li>第三方库</li>
</ul>
<p>默认情况下，这是 goimports 应用的分组。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;os&#34;</span>
  <span class="s">&#34;go.uber.org/atomic&#34;</span>
  <span class="s">&#34;golang.org/x/sync/errgroup&#34;</span>
  <span class="s">&#34;currentProject/model&#34;</span>
  <span class="s">&#34;currentProject/handler&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;os&#34;</span>
  
  <span class="s">&#34;currentProject/model&#34;</span>
  <span class="s">&#34;currentProject/handler&#34;</span>

  <span class="s">&#34;go.uber.org/atomic&#34;</span>
  <span class="s">&#34;golang.org/x/sync/errgroup&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<h3 id="包名">包名</h3>
<p>当命名包时，请按下面规则选择一个名称：</p>
<ul>
<li>全部小写。没有大写或下划线。</li>
<li>大多数使用命名导入的情况下，不需要重命名。</li>
<li>简短而简洁。请记住，在每个使用的地方都完整标识了该名称。</li>
<li>不用复数。例如<code>net/url</code>，而不是<code>net/urls</code>。</li>
<li>不要用“common”，“util”，“shared”或“lib”。这些是不好的，信息量不足的名称。(应该使用更具体的命名方式 如<code>httputil</code>, <code>mathutil</code> 等。)</li>
</ul>
<p>另请参阅 <a href="https://blog.golang.org/package-names">Package Names</a> 和 <a href="https://rakyll.org/style-packages/">Go 包样式指南</a>.</p>
<h3 id="函数名">函数名</h3>
<p>我们遵循 Go 社区关于使用 <a href="https://golang.org/doc/effective_go.html#mixed-caps">MixedCaps 作为函数名</a> 的约定。有一个例外，为了对相关的测试用例进行分组，函数名可能包含下划线，如：<code>TestMyFunction_WhatIsBeingTested</code>.</p>
<h3 id="导入别名">导入别名</h3>
<p>如果程序包名称与导入路径的最后一个元素不匹配，则必须使用导入别名。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;net/http&#34;</span>

  <span class="nx">client</span> <span class="s">&#34;example.com/client-go&#34;</span>
  <span class="nx">trace</span> <span class="s">&#34;example.com/trace/v2&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>在所有其他情况下，除非导入之间有直接冲突，否则应避免导入别名。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;os&#34;</span>

  <span class="nx">nettrace</span> <span class="s">&#34;golang.net/x/trace&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;os&#34;</span>
  <span class="s">&#34;runtime/trace&#34;</span>

  <span class="nx">nettrace</span> <span class="s">&#34;golang.net/x/trace&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<h3 id="函数分组与顺序">函数分组与顺序</h3>
<ul>
<li>函数应按粗略的调用顺序排序。</li>
<li>同一文件中的函数应按接收者分组。</li>
</ul>
<p>因此，导出的函数应先出现在文件中，放在<code>struct</code>, <code>const</code>, <code>var</code>定义的后面。</p>
<p>在定义类型之后，但在接收者的其余方法之前，可能会出现一个 <code>newXYZ()</code>/<code>NewXYZ()</code></p>
<p>由于函数是按接收者分组的，因此普通工具函数应在文件末尾出现。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">something</span><span class="p">)</span> <span class="nf">Cost</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">calcCost</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">weights</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">something</span> <span class="kd">struct</span><span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">calcCost</span><span class="p">(</span><span class="nx">n</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">something</span><span class="p">)</span> <span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">newSomething</span><span class="p">()</span> <span class="o">*</span><span class="nx">something</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">something</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">something</span> <span class="kd">struct</span><span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">newSomething</span><span class="p">()</span> <span class="o">*</span><span class="nx">something</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">something</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">something</span><span class="p">)</span> <span class="nf">Cost</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">calcCost</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">weights</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">something</span><span class="p">)</span> <span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">calcCost</span><span class="p">(</span><span class="nx">n</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<h3 id="减少嵌套">减少嵌套</h3>
<p>代码应通过尽可能先处理错误情况/特殊情况并尽早返回或继续循环来减少嵌套。减少嵌套多个级别的代码的代码量。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">data</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nx">F1</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="nx">v</span> <span class="p">=</span> <span class="nf">process</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Call</span><span class="p">();</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">v</span><span class="p">.</span><span class="nf">Send</span><span class="p">()</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Invalid v: %v&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">data</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nx">F1</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Invalid v: %v&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="k">continue</span>
  <span class="p">}</span>

  <span class="nx">v</span> <span class="p">=</span> <span class="nf">process</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Call</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="nx">v</span><span class="p">.</span><span class="nf">Send</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<h3 id="不必要的-else">不必要的 else</h3>
<p>如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">a</span> <span class="kt">int</span>
<span class="k">if</span> <span class="nx">b</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="p">=</span> <span class="mi">100</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="p">=</span> <span class="mi">10</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">a</span> <span class="o">:=</span> <span class="mi">10</span>
<span class="k">if</span> <span class="nx">b</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="p">=</span> <span class="mi">100</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<h3 id="顶层变量声明">顶层变量声明</h3>
<p>在顶层，使用标准<code>var</code>关键字。请勿指定类型，除非它与表达式的类型不同。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">_s</span> <span class="kt">string</span> <span class="p">=</span> <span class="nf">F</span><span class="p">()</span>

<span class="kd">func</span> <span class="nf">F</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;A&#34;</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">_s</span> <span class="p">=</span> <span class="nf">F</span><span class="p">()</span>
<span class="c1">// 由于 F 已经明确了返回一个字符串类型，因此我们没有必要显式指定_s 的类型
</span><span class="c1">// 还是那种类型
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">F</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;A&#34;</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>如果表达式的类型与所需的类型不完全匹配，请指定类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">myError</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">myError</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;error&#34;</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">F</span><span class="p">()</span> <span class="nx">myError</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">myError</span><span class="p">{}</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nx">_e</span> <span class="kt">error</span> <span class="p">=</span> <span class="nf">F</span><span class="p">()</span>
<span class="c1">// F 返回一个 myError 类型的实例，但是我们要 error 类型
</span></code></pre></td></tr></table>
</div>
</div><h3 id="对于未导出的顶层常量和变量使用_作为前缀">对于未导出的顶层常量和变量，使用_作为前缀</h3>
<p>在未导出的顶级<code>vars</code>和<code>consts</code>， 前面加上前缀_，以使它们在使用时明确表示它们是全局符号。</p>
<p>例外：未导出的错误值，应以<code>err</code>开头。</p>
<p>基本依据：顶级变量和常量具有包范围作用域。使用通用名称可能很容易在其他文件中意外使用错误的值。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// foo.go
</span><span class="c1"></span>
<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">defaultPort</span> <span class="p">=</span> <span class="mi">8080</span>
  <span class="nx">defaultUser</span> <span class="p">=</span> <span class="s">&#34;user&#34;</span>
<span class="p">)</span>

<span class="c1">// bar.go
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">Bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">defaultPort</span> <span class="o">:=</span> <span class="mi">9090</span>
  <span class="o">...</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Default port&#34;</span><span class="p">,</span> <span class="nx">defaultPort</span><span class="p">)</span>

  <span class="c1">// We will not see a compile error if the first line of
</span><span class="c1"></span>  <span class="c1">// Bar() is deleted.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// foo.go
</span><span class="c1"></span>
<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">_defaultPort</span> <span class="p">=</span> <span class="mi">8080</span>
  <span class="nx">_defaultUser</span> <span class="p">=</span> <span class="s">&#34;user&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<h3 id="结构体中的嵌入">结构体中的嵌入</h3>
<p>嵌入式类型（例如 mutex）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Client</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">version</span> <span class="kt">int</span>
  <span class="nx">http</span><span class="p">.</span><span class="nx">Client</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Client</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">http</span><span class="p">.</span><span class="nx">Client</span>

  <span class="nx">version</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>内嵌应该提供切实的好处，比如以语义上合适的方式添加或增强功能。
它应该在对用户不利影响的情况下完成这项工作（另请参见：<code>避免在公共结构中嵌入类型</code><a href="#avoid-embedding-types-in-public-structs">Avoid Embedding Types in Public Structs</a>）。</p>
<p>嵌入 <strong>不应该</strong>:</p>
<ul>
<li>纯粹是为了美观或方便。</li>
<li>使外部类型更难构造或使用。</li>
<li>影响外部类型的零值。如果外部类型有一个有用的零值，则在嵌入内部类型之后应该仍然有一个有用的零值。</li>
<li>作为嵌入内部类型的副作用，从外部类型公开不相关的函数或字段。</li>
<li>公开未导出的类型。</li>
<li>影响外部类型的复制形式。</li>
<li>更改外部类型的API或类型语义。</li>
<li>嵌入内部类型的非规范形式。</li>
<li>公开外部类型的实现详细信息。</li>
<li>允许用户观察或控制类型内部。</li>
<li>通过包装的方式改变内部函数的一般行为，这种包装方式会给用户带来一些意料之外情况。</li>
</ul>
<p>简单地说，有意识地和有目的地嵌入。一种很好的测试体验是，
&quot;是否所有这些导出的内部方法/字段都将直接添加到外部类型&quot;
如果答案是<code>some</code>或<code>no</code>，不要嵌入内部类型-而是使用字段。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">A</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Bad: A.Lock() and A.Unlock() 现在可用
</span><span class="c1"></span>    <span class="c1">// 不提供任何功能性好处，并允许用户控制有关A的内部细节。
</span><span class="c1"></span>    <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">countingWriteCloser</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Good: Write() 在外层提供用于特定目的，
</span><span class="c1"></span>    <span class="c1">// 并且委托工作到内部类型的Write()中。
</span><span class="c1"></span>    <span class="nx">io</span><span class="p">.</span><span class="nx">WriteCloser</span>
    <span class="nx">count</span> <span class="kt">int</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">countingWriteCloser</span><span class="p">)</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">bs</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">w</span><span class="p">.</span><span class="nx">count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">bs</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">w</span><span class="p">.</span><span class="nx">WriteCloser</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">bs</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Book</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Bad: 指针更改零值的有用性
</span><span class="c1"></span>    <span class="nx">io</span><span class="p">.</span><span class="nx">ReadWriter</span>
    <span class="c1">// other fields
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// later
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">b</span> <span class="nx">Book</span>
<span class="nx">b</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>  <span class="c1">// panic: nil pointer
</span><span class="c1"></span><span class="nx">b</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span>   <span class="c1">// panic: nil pointer
</span><span class="c1"></span><span class="nx">b</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1">// panic: nil pointer
</span></code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Book</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Good: 有用的零值
</span><span class="c1"></span>    <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
    <span class="c1">// other fields
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// later
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">b</span> <span class="nx">Book</span>
<span class="nx">b</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>  <span class="c1">// ok
</span><span class="c1"></span><span class="nx">b</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span>   <span class="c1">// ok
</span><span class="c1"></span><span class="nx">b</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1">// ok
</span></code></pre></td></tr></table>
</div>
</div></td></tr>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Client</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
    <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
    <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
    <span class="nx">url</span><span class="p">.</span><span class="nx">URL</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Client</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">mtx</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
    <span class="nx">wg</span>  <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
    <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
    <span class="nx">url</span> <span class="nx">url</span><span class="p">.</span><span class="nx">URL</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<h3 id="使用字段名初始化结构体">使用字段名初始化结构体</h3>
<p>初始化结构体时，应该指定字段名称。现在由 <a href="https://golang.org/cmd/vet/"><code>go vet</code></a> 强制执行。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">k</span> <span class="o">:=</span> <span class="nx">User</span><span class="p">{</span><span class="s">&#34;John&#34;</span><span class="p">,</span> <span class="s">&#34;Doe&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">k</span> <span class="o">:=</span> <span class="nx">User</span><span class="p">{</span>
    <span class="nx">FirstName</span><span class="p">:</span> <span class="s">&#34;John&#34;</span><span class="p">,</span>
    <span class="nx">LastName</span><span class="p">:</span> <span class="s">&#34;Doe&#34;</span><span class="p">,</span>
    <span class="nx">Admin</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>例外：如果有 3 个或更少的字段，则可以在测试表中省略字段名称。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">tests</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span><span class="p">{</span>
  <span class="nx">op</span> <span class="nx">Operation</span>
  <span class="nx">want</span> <span class="kt">string</span>
<span class="p">}{</span>
  <span class="p">{</span><span class="nx">Add</span><span class="p">,</span> <span class="s">&#34;add&#34;</span><span class="p">},</span>
  <span class="p">{</span><span class="nx">Subtract</span><span class="p">,</span> <span class="s">&#34;subtract&#34;</span><span class="p">},</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="本地变量声明">本地变量声明</h3>
<p>如果将变量明确设置为某个值，则应使用短变量声明形式 (<code>:=</code>)。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">s</span> <span class="p">=</span> <span class="s">&#34;foo&#34;</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="s">&#34;foo&#34;</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>但是，在某些情况下，<code>var</code> 使用关键字时默认值会更清晰。例如，声明空切片。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">f</span><span class="p">(</span><span class="nx">list</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">filtered</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">list</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">v</span> <span class="p">&gt;</span> <span class="mi">10</span> <span class="p">{</span>
      <span class="nx">filtered</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">filtered</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">f</span><span class="p">(</span><span class="nx">list</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">filtered</span> <span class="p">[]</span><span class="kt">int</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">list</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">v</span> <span class="p">&gt;</span> <span class="mi">10</span> <span class="p">{</span>
      <span class="nx">filtered</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">filtered</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<h3 id="nil-是一个有效的-slice">nil 是一个有效的 slice</h3>
<p><code>nil</code> 是一个有效的长度为 0 的 slice，这意味着，</p>
<ul>
<li>
<p>您不应明确返回长度为零的切片。应该返回<code>nil</code> 来代替。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
</li>
<li>
<p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>。而非 <code>nil</code>。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
</li>
<li>
<p>零值切片（用<code>var</code>声明的切片）可立即使用，无需调用<code>make()</code>创建。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">nums</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
<span class="c1">// or, nums := make([]int)
</span><span class="c1"></span>
<span class="k">if</span> <span class="nx">add1</span> <span class="p">{</span>
  <span class="nx">nums</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">add2</span> <span class="p">{</span>
  <span class="nx">nums</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span>

<span class="k">if</span> <span class="nx">add1</span> <span class="p">{</span>
  <span class="nx">nums</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">add2</span> <span class="p">{</span>
  <span class="nx">nums</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
</li>
</ul>
<p>记住，虽然nil切片是有效的切片，但它不等于长度为0的切片（一个为nil，另一个不是），并且在不同的情况下（例如序列化），这两个切片的处理方式可能不同。</p>
<h3 id="缩小变量作用域">缩小变量作用域</h3>
<p>如果有可能，尽量缩小变量作用范围。除非它与 <a href="#%E5%87%8F%E5%B0%91%E5%B5%8C%E5%A5%97">减少嵌套</a>的规则冲突。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">WriteFile</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">data</span><span class="p">,</span> <span class="mo">0644</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
 <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">WriteFile</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">data</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
 <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>如果需要在 if 之外使用函数调用的结果，则不应尝试缩小范围。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">err</span> <span class="p">=</span> <span class="nx">cfg</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">cfg</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cfg</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">cfg</span><span class="p">)</span>
<span class="k">return</span> <span class="kc">nil</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<h3 id="避免参数语义不明确avoid-naked-parameters">避免参数语义不明确(Avoid Naked Parameters)</h3>
<p>函数调用中的<code>意义不明确的参数</code>可能会损害可读性。当参数名称的含义不明显时，请为参数添加 C 样式注释 (<code>/* ... */</code>)</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// func printInfo(name string, isLocal, done bool)
</span><span class="c1"></span>
<span class="nf">printInfo</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// func printInfo(name string, isLocal, done bool)
</span><span class="c1"></span>
<span class="nf">printInfo</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">,</span> <span class="kc">true</span> <span class="cm">/* isLocal */</span><span class="p">,</span> <span class="kc">true</span> <span class="cm">/* done */</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>对于上面的示例代码，还有一种更好的处理方式是将上面的 <code>bool</code> 类型换成自定义类型。将来，该参数可以支持不仅仅局限于两个状态（true/false）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Region</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">UnknownRegion</span> <span class="nx">Region</span> <span class="p">=</span> <span class="kc">iota</span>
  <span class="nx">Local</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Status</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">StatusReady</span> <span class="nx">Status</span><span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="nx">StatusDone</span>
  <span class="c1">// Maybe we will have a StatusInProgress in the future.
</span><span class="c1"></span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">printInfo</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">region</span> <span class="nx">Region</span><span class="p">,</span> <span class="nx">status</span> <span class="nx">Status</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="使用原始字符串字面值避免转义">使用原始字符串字面值，避免转义</h3>
<p>Go 支持使用 <a href="https://golang.org/ref/spec#raw_string_lit">原始字符串字面值</a>，也就是 &quot; ` &quot; 来表示原生字符串，在需要转义的场景下，我们应该尽量使用这种方案来替换。</p>
<p>可以跨越多行并包含引号。使用这些字符串可以避免更难阅读的手工转义的字符串。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">wantError</span> <span class="o">:=</span> <span class="s">&#34;unknown name:\&#34;test\&#34;&#34;</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">wantError</span> <span class="o">:=</span> <span class="s">`unknown error:&#34;test&#34;`</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<h3 id="初始化-struct-引用">初始化 Struct 引用</h3>
<p>在初始化结构引用时，请使用<code>&amp;T{}</code>代替<code>new(T)</code>，以使其与结构体初始化一致。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">sval</span> <span class="o">:=</span> <span class="nx">T</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;foo&#34;</span><span class="p">}</span>

<span class="c1">// inconsistent
</span><span class="c1"></span><span class="nx">sptr</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
<span class="nx">sptr</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="s">&#34;bar&#34;</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">sval</span> <span class="o">:=</span> <span class="nx">T</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;foo&#34;</span><span class="p">}</span>

<span class="nx">sptr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">T</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;bar&#34;</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<h3 id="初始化-maps">初始化 Maps</h3>
<p>对于空 map 请使用 <code>make(..)</code> 初始化， 并且 map 是通过编程方式填充的。
这使得 map 初始化在表现上不同于声明，并且它还可以方便地在 make 后添加大小提示。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
  <span class="c1">// m1 读写安全;
</span><span class="c1"></span>  <span class="c1">// m2 在写入时会 panic
</span><span class="c1"></span>  <span class="nx">m1</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="nx">T1</span><span class="p">]</span><span class="nx">T2</span><span class="p">{}</span>
  <span class="nx">m2</span> <span class="kd">map</span><span class="p">[</span><span class="nx">T1</span><span class="p">]</span><span class="nx">T2</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
  <span class="c1">// m1 读写安全;
</span><span class="c1"></span>  <span class="c1">// m2 在写入时会 panic
</span><span class="c1"></span>  <span class="nx">m1</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">T1</span><span class="p">]</span><span class="nx">T2</span><span class="p">)</span>
  <span class="nx">m2</span> <span class="kd">map</span><span class="p">[</span><span class="nx">T1</span><span class="p">]</span><span class="nx">T2</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
<tr><td>
<p>声明和初始化看起来非常相似的。</p>
</td><td>
<p>声明和初始化看起来差别非常大。</p>
</td></tr>
</tbody></table>
<p>在尽可能的情况下，请在初始化时提供 map 容量大小，详细请看 <a href="#%E6%8C%87%E5%AE%9AMap%E5%AE%B9%E9%87%8F%E6%8F%90%E7%A4%BA">指定Map容量提示</a>。</p>
<p>另外，如果 map 包含固定的元素列表，则使用 map literals(map 初始化列表) 初始化映射。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">T1</span><span class="p">]</span><span class="nx">T2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nx">m</span><span class="p">[</span><span class="nx">k1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v1</span>
<span class="nx">m</span><span class="p">[</span><span class="nx">k2</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v2</span>
<span class="nx">m</span><span class="p">[</span><span class="nx">k3</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v3</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="nx">T1</span><span class="p">]</span><span class="nx">T2</span><span class="p">{</span>
  <span class="nx">k1</span><span class="p">:</span> <span class="nx">v1</span><span class="p">,</span>
  <span class="nx">k2</span><span class="p">:</span> <span class="nx">v2</span><span class="p">,</span>
  <span class="nx">k3</span><span class="p">:</span> <span class="nx">v3</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>基本准则是：在初始化时使用 map 初始化列表 来添加一组固定的元素。否则使用 <code>make</code> (如果可以，请尽量指定 map 容量)。</p>
<h2 id="编程模式">编程模式</h2>
<h3 id="表驱动测试">表驱动测试</h3>
<p>当测试逻辑是重复的时候，通过  <a href="https://blog.golang.org/subtests">subtests</a> 使用 table 驱动的方式编写 case 代码看上去会更简洁。而且目前编译器可以通过快捷键快速生成单元测试方法，可以帮助养成良好习惯。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// func TestSplitHostPort(t *testing.T)
</span><span class="c1"></span>
<span class="nx">host</span><span class="p">,</span> <span class="nx">port</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">SplitHostPort</span><span class="p">(</span><span class="s">&#34;192.0.2.0:8000&#34;</span><span class="p">)</span>
<span class="nx">require</span><span class="p">.</span><span class="nf">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="s">&#34;192.0.2.0&#34;</span><span class="p">,</span> <span class="nx">host</span><span class="p">)</span>
<span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="s">&#34;8000&#34;</span><span class="p">,</span> <span class="nx">port</span><span class="p">)</span>

<span class="nx">host</span><span class="p">,</span> <span class="nx">port</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">SplitHostPort</span><span class="p">(</span><span class="s">&#34;192.0.2.0:http&#34;</span><span class="p">)</span>
<span class="nx">require</span><span class="p">.</span><span class="nf">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="s">&#34;192.0.2.0&#34;</span><span class="p">,</span> <span class="nx">host</span><span class="p">)</span>
<span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="s">&#34;http&#34;</span><span class="p">,</span> <span class="nx">port</span><span class="p">)</span>

<span class="nx">host</span><span class="p">,</span> <span class="nx">port</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">SplitHostPort</span><span class="p">(</span><span class="s">&#34;:8000&#34;</span><span class="p">)</span>
<span class="nx">require</span><span class="p">.</span><span class="nf">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">host</span><span class="p">)</span>
<span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="s">&#34;8000&#34;</span><span class="p">,</span> <span class="nx">port</span><span class="p">)</span>

<span class="nx">host</span><span class="p">,</span> <span class="nx">port</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">SplitHostPort</span><span class="p">(</span><span class="s">&#34;1:8&#34;</span><span class="p">)</span>
<span class="nx">require</span><span class="p">.</span><span class="nf">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="nx">host</span><span class="p">)</span>
<span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="s">&#34;8&#34;</span><span class="p">,</span> <span class="nx">port</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// func TestSplitHostPort(t *testing.T)
</span><span class="c1"></span>
<span class="nx">tests</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span><span class="p">{</span>
  <span class="nx">give</span>     <span class="kt">string</span>
  <span class="nx">wantHost</span> <span class="kt">string</span>
  <span class="nx">wantPort</span> <span class="kt">string</span>
<span class="p">}{</span>
  <span class="p">{</span>
    <span class="nx">give</span><span class="p">:</span>     <span class="s">&#34;192.0.2.0:8000&#34;</span><span class="p">,</span>
    <span class="nx">wantHost</span><span class="p">:</span> <span class="s">&#34;192.0.2.0&#34;</span><span class="p">,</span>
    <span class="nx">wantPort</span><span class="p">:</span> <span class="s">&#34;8000&#34;</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="nx">give</span><span class="p">:</span>     <span class="s">&#34;192.0.2.0:http&#34;</span><span class="p">,</span>
    <span class="nx">wantHost</span><span class="p">:</span> <span class="s">&#34;192.0.2.0&#34;</span><span class="p">,</span>
    <span class="nx">wantPort</span><span class="p">:</span> <span class="s">&#34;http&#34;</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="nx">give</span><span class="p">:</span>     <span class="s">&#34;:8000&#34;</span><span class="p">,</span>
    <span class="nx">wantHost</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span>
    <span class="nx">wantPort</span><span class="p">:</span> <span class="s">&#34;8000&#34;</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="nx">give</span><span class="p">:</span>     <span class="s">&#34;1:8&#34;</span><span class="p">,</span>
    <span class="nx">wantHost</span><span class="p">:</span> <span class="s">&#34;1&#34;</span><span class="p">,</span>
    <span class="nx">wantPort</span><span class="p">:</span> <span class="s">&#34;8&#34;</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">tt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nx">tt</span><span class="p">.</span><span class="nx">give</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">host</span><span class="p">,</span> <span class="nx">port</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">SplitHostPort</span><span class="p">(</span><span class="nx">tt</span><span class="p">.</span><span class="nx">give</span><span class="p">)</span>
    <span class="nx">require</span><span class="p">.</span><span class="nf">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">tt</span><span class="p">.</span><span class="nx">wantHost</span><span class="p">,</span> <span class="nx">host</span><span class="p">)</span>
    <span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">tt</span><span class="p">.</span><span class="nx">wantPort</span><span class="p">,</span> <span class="nx">port</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>很明显，使用 test table 的方式在代码逻辑扩展的时候，比如新增 test case，都会显得更加的清晰。</p>
<p>我们遵循这样的约定：将结构体切片称为<code>tests</code>。 每个测试用例称为<code>tt</code>。此外，我们鼓励使用<code>give</code>和<code>want</code>前缀说明每个测试用例的输入和输出值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">tests</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span><span class="p">{</span>
  <span class="nx">give</span>     <span class="kt">string</span>
  <span class="nx">wantHost</span> <span class="kt">string</span>
  <span class="nx">wantPort</span> <span class="kt">string</span>
<span class="p">}{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>

<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">tt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="功能选项">功能选项</h3>
<p>功能选项是一种模式，您可以在其中声明一个不透明 Option 类型，该类型在某些内部结构中记录信息。您接受这些选项的可变编号，并根据内部结构上的选项记录的全部信息采取行动。</p>
<p>将此模式用于您需要扩展的构造函数和其他公共 API 中的可选参数，尤其是在这些功能上已经具有三个或更多参数的情况下。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// package db
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">Open</span><span class="p">(</span>
  <span class="nx">addr</span> <span class="kt">string</span><span class="p">,</span>
  <span class="nx">cache</span> <span class="kt">bool</span><span class="p">,</span>
  <span class="nx">logger</span> <span class="o">*</span><span class="nx">zap</span><span class="p">.</span><span class="nx">Logger</span>
<span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Connection</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// package db
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">Option</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">WithCache</span><span class="p">(</span><span class="nx">c</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">Option</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">WithLogger</span><span class="p">(</span><span class="nx">log</span> <span class="o">*</span><span class="nx">zap</span><span class="p">.</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">Option</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Open creates a connection.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Open</span><span class="p">(</span>
  <span class="nx">addr</span> <span class="kt">string</span><span class="p">,</span>
  <span class="nx">opts</span> <span class="o">...</span><span class="nx">Option</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Connection</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
<tr><td>
<p>必须始终提供缓存和记录器参数，即使用户希望使用默认值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">db</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nx">DefaultCache</span><span class="p">,</span> <span class="nx">zap</span><span class="p">.</span><span class="nf">NewNop</span><span class="p">())</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nx">DefaultCache</span><span class="p">,</span> <span class="nx">log</span><span class="p">)</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="kc">false</span> <span class="cm">/* cache */</span><span class="p">,</span> <span class="nx">zap</span><span class="p">.</span><span class="nf">NewNop</span><span class="p">())</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="kc">false</span> <span class="cm">/* cache */</span><span class="p">,</span> <span class="nx">log</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></td><td>
<p>只有在需要时才提供选项。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">db</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nf">WithLogger</span><span class="p">(</span><span class="nx">log</span><span class="p">))</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nf">WithCache</span><span class="p">(</span><span class="kc">false</span><span class="p">))</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span>
  <span class="nx">addr</span><span class="p">,</span>
  <span class="nx">db</span><span class="p">.</span><span class="nf">WithCache</span><span class="p">(</span><span class="kc">false</span><span class="p">),</span>
  <span class="nx">db</span><span class="p">.</span><span class="nf">WithLogger</span><span class="p">(</span><span class="nx">log</span><span class="p">),</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></td></tr>
</tbody></table>
<p>Our suggested way of implementing this pattern is with an <code>Option</code> interface
that holds an unexported method, recording options on an unexported <code>options</code>
struct.</p>
<p>我们建议实现此模式的方法是使用一个 <code>Option</code> 接口，该接口保存一个未导出的方法，在一个未导出的 <code>options</code> 结构上记录选项。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">options</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">cache</span>  <span class="kt">bool</span>
  <span class="nx">logger</span> <span class="o">*</span><span class="nx">zap</span><span class="p">.</span><span class="nx">Logger</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Option</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nf">apply</span><span class="p">(</span><span class="o">*</span><span class="nx">options</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">cacheOption</span> <span class="kt">bool</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">cacheOption</span><span class="p">)</span> <span class="nf">apply</span><span class="p">(</span><span class="nx">opts</span> <span class="o">*</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">opts</span><span class="p">.</span><span class="nx">cache</span> <span class="p">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">WithCache</span><span class="p">(</span><span class="nx">c</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">Option</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">cacheOption</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">loggerOption</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Log</span> <span class="o">*</span><span class="nx">zap</span><span class="p">.</span><span class="nx">Logger</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="nx">loggerOption</span><span class="p">)</span> <span class="nf">apply</span><span class="p">(</span><span class="nx">opts</span> <span class="o">*</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">opts</span><span class="p">.</span><span class="nx">logger</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">Log</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">WithLogger</span><span class="p">(</span><span class="nx">log</span> <span class="o">*</span><span class="nx">zap</span><span class="p">.</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">Option</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">loggerOption</span><span class="p">{</span><span class="nx">Log</span><span class="p">:</span> <span class="nx">log</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Open creates a connection.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Open</span><span class="p">(</span>
  <span class="nx">addr</span> <span class="kt">string</span><span class="p">,</span>
  <span class="nx">opts</span> <span class="o">...</span><span class="nx">Option</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Connection</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">options</span> <span class="o">:=</span> <span class="nx">options</span><span class="p">{</span>
    <span class="nx">cache</span><span class="p">:</span>  <span class="nx">defaultCache</span><span class="p">,</span>
    <span class="nx">logger</span><span class="p">:</span> <span class="nx">zap</span><span class="p">.</span><span class="nf">NewNop</span><span class="p">(),</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">o</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
    <span class="nx">o</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">options</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意: 还有一种使用闭包实现这个模式的方法，但是我们相信上面的模式为作者提供了更多的灵活性，并且更容易对用户进行调试和测试。特别是，在不可能进行比较的情况下它允许在测试和模拟中对选项进行比较。此外，它还允许选项实现其他接口，包括 <code>fmt.Stringer</code>，允许用户读取选项的字符串表示形式。</p>
<p>还可以参考下面资料：</p>
<ul>
<li>
<p><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html">Self-referential functions and the design of options</a></p>
</li>
<li>
<p><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis">Functional options for friendly APIs</a></p>
</li>
</ul>
<h2 id="linting">Linting</h2>
<p>比任何 &quot;blessed&quot; linter 集更重要的是，lint在一个代码库中始终保持一致。</p>
<p>建议至少使用以下linters，因为我认为它们有助于发现最常见的问题，并在不需要规定的情况下为代码质量建立一个高标准：</p>
<ul>
<li>
<p><a href="https://github.com/kisielk/errcheck">errcheck</a> 以确保错误得到处理</p>
</li>
<li>
<p><a href="https://godoc.org/golang.org/x/tools/cmd/goimports">goimports</a> 格式化代码和管理 imports</p>
</li>
<li>
<p><a href="https://github.com/golang/lint">golint</a> 指出常见的文体错误</p>
</li>
<li>
<p><a href="https://golang.org/cmd/vet/">govet</a> 分析代码中的常见错误</p>
</li>
<li>
<p><a href="https://staticcheck.io/">staticcheck</a> 各种静态分析检查</p>
</li>
</ul>
]]></content><category scheme="https://yusank.github.io/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术"/><category scheme="https://yusank.github.io/categories/%E8%A7%84%E8%8C%83/" term="规范" label="规范"/><category scheme="https://yusank.github.io/tags/go/" term="go" label="go"/></entry><entry><title type="text">Go Map 源码解读</title><link rel="alternate" type="text/html" href="https://yusank.github.io/posts/go-map/"/><id>https://yusank.github.io/posts/go-map/</id><updated>2021-07-04T08:33:24+00:00</updated><published>2020-06-14T16:24:41+08:00</published><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><summary type="html">Go 的 map 作为该语言最常见的基础数据结构之一。 源码解读 Go 语言实现的 map 并非是完全的哈希 map ，是一种类似两层树状的结构，根据 key 的哈……</summary><content type="html"><![CDATA[<p>Go 的 <code>map</code> 作为该语言最常见的基础数据结构之一。</p>
<h2 id="源码解读">源码解读</h2>
<p>Go 语言实现的 map 并非是完全的哈希 map ，是一种类似两层树状的结构，根据 key 的哈希值的低八位 决定第一层的位置，根据高八位决定第二层，如果第二层所在冲突了则会有一个额外的位置 用于存储哈希碰撞的 kv。看图会帮助理解：</p>
<h3 id="图解">图解：</h3>
<p><img src="http://blog.linkinstars.com/mweb/15593603213325.jpg" alt="图解"></p>
<h3 id="数据结构">数据结构</h3>
<p>源码在 <code>go/src/runtime/map.go</code> 文件中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// map 的实现
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">count</span>     <span class="kt">int</span> <span class="c1">// 已使用位置数（即 len() 方法会返回该值），之所以说已使用的是因为并非所有的位置都存放位置
</span><span class="c1"></span>	<span class="nx">flags</span>     <span class="kt">uint8</span>   <span class="c1">// map的状态，通过该字段判断当前是否被某个进程进行写操作
</span><span class="c1"></span>	<span class="nx">B</span>         <span class="kt">uint8</span>  <span class="c1">// 2^B 为桶的数量， B为 3 时 2^3 一共 8 个桶
</span><span class="c1"></span>	<span class="nx">noverflow</span> <span class="kt">uint16</span> <span class="c1">// 溢出的桶数量
</span><span class="c1"></span>	<span class="nx">hash0</span>     <span class="kt">uint32</span> <span class="c1">// hash seed
</span><span class="c1"></span>
	<span class="nx">buckets</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 桶的数组
</span><span class="c1"></span>	<span class="nx">oldbuckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 旧桶的数组。map 扩容时 原 buckets 变成 oldbuckets 并将数据逐步迁移，并非一次性迁移
</span><span class="c1"></span>	<span class="nx">nevacuate</span>  <span class="kt">uintptr</span>        <span class="c1">// 扩容进度记录
</span><span class="c1"></span>
	<span class="nx">extra</span> <span class="o">*</span><span class="nx">mapextra</span> <span class="c1">// 额外信息。存储非指针数据（为了优化空间）
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">mapextra</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 为了优化空间 将非指针数据存储在 mapextra里
</span><span class="c1"></span>	<span class="nx">overflow</span>    <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span> <span class="c1">// 对应 hmap.buckets
</span><span class="c1"></span>	<span class="nx">oldoverflow</span> <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span> <span class="c1">// 对应 hmap.oldbuckets
</span><span class="c1"></span>
	<span class="c1">// 指向下一个空闲的 bucket
</span><span class="c1"></span>	<span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
<span class="p">}</span>

<span class="c1">// bucket 即桶
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">bmap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// tophash 存储每个 key 的 tophash 即 key 的前八位，用于判断读取的 key 是否在当前桶里。
</span><span class="c1"></span>    <span class="nx">tophash</span> <span class="p">[</span><span class="nx">bucketCnt</span><span class="p">]</span><span class="kt">uint8</span>
    <span class="c1">// 之后是 key-value 的格子，每个桶最多只能存 8 个且 以 key1...key8value1...value8 的形式存储。
</span><span class="c1"></span>	<span class="c1">// 还有一个 overflow 用于指向下一个桶。
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="读取">读取</h3>
<h4 id="按-key-读取">按 key 读取</h4>
<h4 id="遍历">遍历</h4>
<h3 id="写入">写入</h3>
<h3 id="删除">删除</h3>
<blockquote>
<p>coming soon</p>
</blockquote>
]]></content><category scheme="https://yusank.github.io/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术"/><category scheme="https://yusank.github.io/tags/go/" term="go" label="go"/></entry><entry><title type="text">Go Channel 源码解读</title><link rel="alternate" type="text/html" href="https://yusank.github.io/posts/go-channel/"/><id>https://yusank.github.io/posts/go-channel/</id><updated>2021-07-04T08:33:24+00:00</updated><published>2020-03-06T17:24:41+08:00</published><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><summary type="html">Go 的 channel 作为该语言很重要的特性，作为一个 gopher 有必要详细了解其实现原理。 原理解读 Go 语言的 channel 实现源码在go/src/runtim……</summary><content type="html"><![CDATA[<p>Go 的 <code>channel</code> 作为该语言很重要的特性，作为一个 gopher 有必要详细了解其实现原理。</p>
<h1 id="原理解读">原理解读</h1>
<p>Go 语言的 <code>channel</code> 实现源码在<code>go/src/runtime/chan.go</code> 文件里。（go version ：1.13.4）</p>
<h2 id="数据结构">数据结构</h2>
<p>首先看一下基础数据结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// go 语言的 channel 结构以队列的形式实现
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">hchan</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">qcount</span>   <span class="kt">uint</span>           <span class="c1">// total data in the queue，队列中元素总数
</span><span class="c1"></span>	<span class="nx">dataqsiz</span> <span class="kt">uint</span>           <span class="c1">// size of the circular queue，循环队列的大小
</span><span class="c1"></span>	<span class="nx">buf</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// points to an array of dataqsiz elements， 指向循环队列中元素的指针
</span><span class="c1"></span>	<span class="nx">elemsize</span> <span class="kt">uint16</span> <span class="c1">// 元素 size
</span><span class="c1"></span>	<span class="nx">closed</span>   <span class="kt">uint32</span> <span class="c1">// channel 是否关闭标志
</span><span class="c1"></span>	<span class="nx">elemtype</span> <span class="o">*</span><span class="nx">_type</span> <span class="c1">// element type // channel 元素类型
</span><span class="c1"></span>	<span class="nx">sendx</span>    <span class="kt">uint</span>   <span class="c1">// send index // 写入 channel 元素的索引
</span><span class="c1"></span>	<span class="nx">recvx</span>    <span class="kt">uint</span>   <span class="c1">// receive index // 从 channel 读取的元素索引
</span><span class="c1"></span>	<span class="nx">recvq</span>    <span class="nx">waitq</span>  <span class="c1">// list of recv waiters // 读取 channel 的等待队列（即阻塞的协程）
</span><span class="c1"></span>	<span class="nx">sendq</span>    <span class="nx">waitq</span>  <span class="c1">// list of send waiters // 写入 channel 的等待队列
</span><span class="c1"></span>
	<span class="c1">// lock protects all fields in hchan, as well as several
</span><span class="c1"></span>	<span class="c1">// fields in sudogs blocked on this channel.
</span><span class="c1"></span>	<span class="nx">lock</span> <span class="nx">mutex</span> <span class="c1">// 互斥锁
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 双向链表结构，其中每一个元素代表着等待读取或写入 channel 的协程
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">waitq</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">first</span> <span class="o">*</span><span class="nx">sudog</span>
	<span class="nx">last</span>  <span class="o">*</span><span class="nx">sudog</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>通过源码数据结构，对 go 的 channel 实现有了初步的了解，解答了在我们读取或写入 channel 时，其中元素在哪儿，我们的协程在哪儿等待等数据相关问题。</p>
<ul>
<li>channel 底层实现是以队列作为载体，通过互斥锁保证在同一个时间点，只有一个待读取的协程读元素或待写入的协程写入元素。</li>
<li>如果有多个协程同时读取 channel 时，他们会进入读取等待队列：<code>recvq</code>，反之进入写入等待队列：<code>sendq</code>。</li>
<li><code>buf</code> 作为指针，指向 channel 中存储元素的数组的地址。</li>
<li><code>sendx</code>,<code>recvx</code> 作为channel 队列中写入和读取到元素的索引值。</li>
<li><code>closed</code> 为 channel 当前是否已被关闭标志。</li>
</ul>
<h2 id="主要方法func">主要方法（func）</h2>
<p>以我们常用的 <code>make(chan Type)</code>, 写入元素(<code>chan &lt;- element</code>)和读取元素(<code>&lt;-chan</code>)为例</p>
<h3 id="初始化make">初始化（make）</h3>
<p>在实际使用中 我会用下面的代码初始化一个 channel：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Type</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>其实现源码入下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// t 为 channel 类型，size 为我们传入 channel 大小
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">makechan</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">chantype</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">hchan</span> <span class="p">{</span>
	<span class="nx">elem</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span>

  <span class="c1">// 如果 size 超过声明类型最大值 编译的时候会报错，但是这里多一次判断为了更安全
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span> <span class="p">{</span>
    <span class="c1">// 抛出异常
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;makechan: invalid channel element type&#34;</span><span class="p">)</span>
	<span class="p">}</span>
  <span class="c1">// align 为类型的对齐系数，不同平台上对其系数不完全一样，但是都最大值 maxAlign=8
</span><span class="c1"></span>  <span class="c1">// 不同类型的对齐系数不一样 但是均以 2^N 形式
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">hchanSize</span><span class="o">%</span><span class="nx">maxAlign</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">align</span> <span class="p">&gt;</span> <span class="nx">maxAlign</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;makechan: bad alignment&#34;</span><span class="p">)</span>
	<span class="p">}</span>

  <span class="c1">// 检查是否channel 大小值是否溢出
</span><span class="c1"></span>	<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span><span class="o">-</span><span class="nx">hchanSize</span> <span class="o">||</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;makechan: size out of range&#34;</span><span class="p">))</span>
	<span class="p">}</span>

  <span class="c1">// 根据 size 和原始是否为指针情况，分配内存初始化 channel
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span>
	<span class="k">switch</span> <span class="p">{</span>
    <span class="c1">// channel size 为 0
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">mem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">()</span>
	<span class="k">case</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1">// 元素不包含指针，则将为元素分配内存，并将 buf 指向该地址
</span><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="o">+</span><span class="nx">mem</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">hchanSize</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="c1">// 元素包含指针，buf 指向该指针指向地址
</span><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hchan</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">c</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span> <span class="p">=</span> <span class="nx">elem</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看出，channel 中的元素最终都是以指针的方式存储，即便初始化时 用非指针类型（如 string），在初始化话的时候 会先分配内存 并将 channel 的元素指针字段指向该地址。</p>
<h3 id="写入">写入</h3>
<p>先给出源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// entry point for c &lt;- x from compiled code
</span><span class="c1">// 代码重 `c &lt;- x` 编译时，会编译成该方法从而被调用
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">chansend1</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="nf">getcallerpc</span><span class="p">())</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm"> * generic single channel send/recv
</span><span class="cm"> * If block is not nil,
</span><span class="cm"> * then the protocol will not
</span><span class="cm"> * sleep but return if it could
</span><span class="cm"> * not complete.
</span><span class="cm"> *
</span><span class="cm"> * sleep can wake up with g.param == nil
</span><span class="cm"> * when a channel involved in the sleep has
</span><span class="cm"> * been closed.  it is easiest to loop and re-run
</span><span class="cm"> * the operation; we&#39;ll see that it&#39;s now closed.
</span><span class="cm"> */</span>
<span class="c1">// 向 channel 写入
</span><span class="c1">// c: channel
</span><span class="c1">// ep: 写入元素地址
</span><span class="c1">// block: 表示该 channel 是否被阻塞
</span><span class="c1">// callerpc: 
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// return or panic
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
    <span class="c1">// 不同协程之前竞争写入
</span><span class="c1"></span>		<span class="nf">racereadpc</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">(),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">chansend</span><span class="p">))</span>
	<span class="p">}</span>


  <span class="c1">// 没有阻塞 &amp;&amp; 未关闭 &amp;&amp; （channel 为空且没有协程读取 或 channel 已满，直接返回 false）
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nx">first</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">t0</span> <span class="kt">int64</span>
	<span class="k">if</span> <span class="nx">blockprofilerate</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">t0</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
	<span class="p">}</span>

  <span class="c1">// 上锁 准备写
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

  <span class="c1">// 已关闭 解锁并 panic
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
	<span class="p">}</span>

  <span class="c1">// 从等待读取的队列中 拿出第一个协程，写入并发送到该协程
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Found a waiting receiver. We pass the value we want to send
</span><span class="c1"></span>		<span class="c1">// directly to the receiver, bypassing the channel buffer (if any).
</span><span class="c1"></span>		<span class="nf">send</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

  <span class="c1">// 如果 channel 缓存有空间，则向缓存中写入
</span><span class="c1"></span>  <span class="c1">// 此时是 channel 是有 buffer channel
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
		<span class="c1">// Space is available in the channel buffer. Enqueue the element to send.
</span><span class="c1"></span>		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">)</span>
    <span class="c1">// 应该是协程之间竞争，暂时没有完全搞懂
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">qp</span><span class="p">)</span>
			<span class="nf">racerelease</span><span class="p">(</span><span class="nx">qp</span><span class="p">)</span>
		<span class="p">}</span>
    <span class="c1">// 写入缓存
</span><span class="c1"></span>		<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
    <span class="c1">// 写入位置加一
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="o">++</span>
    <span class="c1">// 如果写完 buffer 满了，将位置置位 0
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
    <span class="c1">// channel 数据总数加一
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">++</span>
    <span class="c1">// 解锁
</span><span class="c1"></span>		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

  <span class="c1">// 如果是非阻塞类型 channel，则只返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

  <span class="c1">// 如果是阻塞类型，则一直阻塞一直到被读取，保证数据在被读取之前不被内存回收
</span><span class="c1"></span>  
	<span class="c1">// Block on the channel. Some receiver will complete our operation for us.
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>

	<span class="nf">KeepAlive</span><span class="p">(</span><span class="nx">ep</span><span class="p">)</span>

	<span class="c1">// someone woke us up.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mysg</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;G waiting list is corrupted&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;chansend: spurious wakeup&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="k">if</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">blockevent</span><span class="p">(</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="读取">读取</h3>
<blockquote>
<p>近期补充。。。</p>
</blockquote>
<h1 id="使用">使用</h1>
<p>Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)。</p>
<p>它的操作符是箭头 <strong>&lt;-</strong> 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">v</span>    
<span class="nx">v</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>  
</code></pre></td></tr></table>
</div>
</div><p>(箭头的指向就是数据的流向)</p>
<p>就像 map 和 slice 数据类型一样, channel必须先创建再使用:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="channel-类型">Channel 类型</h2>
<p>Channel类型的定义格式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ChannelType</span> <span class="p">=</span> <span class="p">(</span> <span class="s">&#34;chan&#34;</span> <span class="p">|</span> <span class="s">&#34;chan&#34;</span> <span class="s">&#34;&lt;-&#34;</span> <span class="p">|</span> <span class="s">&#34;&lt;-&#34;</span> <span class="s">&#34;chan&#34;</span> <span class="p">)</span> <span class="nx">ElementType</span> <span class="p">.</span>
</code></pre></td></tr></table>
</div>
</div><p>它包括三种类型的定义。可选的<code>&lt;-</code>代表channel的方向。如果没有指定方向，那么Channel就是双向的，既可以接收数据，也可以发送数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">chan</span> <span class="nx">T</span>          <span class="c1">// 可以接收和发送类型为 T 的数据
</span><span class="c1"></span><span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">float64</span>  <span class="c1">// 只可以用来发送 float64 类型的数据
</span><span class="c1"></span><span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span>      <span class="c1">// 只可以用来接收 int 类型的数据
</span></code></pre></td></tr></table>
</div>
</div><p><code>&lt;-</code>总是优先和最左边的类型结合。(The &lt;- operator associates with the leftmost chan possible)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">chan</span><span class="o">&lt;-</span> <span class="kd">chan</span> <span class="kt">int</span>    <span class="c1">// 等价 chan&lt;- (chan int)
</span><span class="c1"></span><span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span>  <span class="c1">// 等价 chan&lt;- (&lt;-chan int)
</span><span class="c1"></span><span class="o">&lt;-</span><span class="kd">chan</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span>  <span class="c1">// 等价 &lt;-chan (&lt;-chan int)
</span><span class="c1"></span><span class="kd">chan</span> <span class="p">(</span><span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>使用<code>make</code>初始化Channel,并且可以设置容量:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>容量(capacity)代表Channel容纳的最多的元素的数量，代表Channel的缓存的大小。
如果没有设置容量，或者容量设置为0, 说明Channel没有缓存，只有sender和receiver都准备好了后它们的通讯(communication)才会发生(Blocking)。如果设置了缓存，就有可能不发生阻塞， 只有buffer满了后 send才会阻塞， 而只有缓存空了后receive才会阻塞。一个nil channel不会通信。</p>
<p>可以通过内建的<code>close</code>方法可以关闭Channel。</p>
<p>你可以在多个goroutine从/往 一个channel 中 receive/send 数据, 不必考虑额外的同步措施。</p>
<p>Channel可以作为一个先入先出(FIFO)的队列，接收的数据和发送的数据的顺序是一致的。</p>
<p>channel的 receive支持 <em>multi-valued assignment</em>，如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
</code></pre></td></tr></table>
</div>
</div><p>它可以用来检查Channel是否已经被关闭了。</p>
<ol>
<li><strong>send语句</strong>
send语句用来往Channel中发送数据， 如<code>ch &lt;- 3</code>。
它的定义如下:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">SendStmt</span> <span class="p">=</span> <span class="nx">Channel</span> <span class="s">&#34;&lt;-&#34;</span> <span class="nx">Expression</span> <span class="p">.</span>
<span class="nx">Channel</span>  <span class="p">=</span> <span class="nx">Expression</span> <span class="p">.</span>
</code></pre></td></tr></table>
</div>
</div><p>在通讯(communication)开始前channel和expression必选先求值出来(evaluated)，比如下面的(3+4)先计算出7然后再发送给channel。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span> <span class="p">}()</span>
<span class="nx">i</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">c</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>send被执行前(proceed)通讯(communication)一直被阻塞着。如前所言，无缓存的channel只有在receiver准备好后send才被执行。如果有缓存，并且缓存未满，则send会被执行。</p>
<p>往一个已经被close的channel中继续发送数据会导致<strong>run-time panic</strong>。</p>
<p>往nil channel中发送数据会一致被阻塞着。</p>
<ol>
<li>receive 操作符
<code>&lt;-ch</code>用来从channel ch中接收数据，这个表达式会一直被block,直到有数据可以接收。</li>
</ol>
<p>从一个nil channel中接收数据会一直被block。</p>
<p>从一个被close的channel中接收数据不会被阻塞，而是立即返回，接收完已发送的数据后会返回元素类型的零值(zero value)。</p>
<p>如前所述，你可以使用一个额外的返回参数来检查channel是否关闭。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">x</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
<span class="nx">x</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
<span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="blocking">blocking</h2>
<p>缺省情况下，发送和接收会一直阻塞着，知道另一方准备好。这种方式可以用来在gororutine中进行同步，而不必使用显示的锁或者条件变量。</p>
<p>如官方的例子中<code>x, y := &lt;-c, &lt;-c</code>这句会一直等待计算结果发送到channel中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
<span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">c</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">v</span>
	<span class="p">}</span>
	<span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">sum</span> 
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">sum</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="nx">c</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">sum</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">:],</span> <span class="nx">c</span><span class="p">)</span>
	<span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">,</span> <span class="o">&lt;-</span><span class="nx">c</span> <span class="c1">// receive from c
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="o">+</span><span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="buffered-channels">Buffered Channels</h2>
<p>make的第二个参数指定缓存的大小：<code>ch := make(chan int, 100)</code>。</p>
<p>通过缓存的使用，可以尽量避免阻塞，提供应用的性能。</p>
<h2 id="range">Range</h2>
<p><code>for …… range</code>语句可以处理Channel。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span> <span class="p">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">i</span>
		<span class="p">}</span>
		<span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Finished&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>range c</code>产生的迭代值为Channel中发送的值，它会一直迭代知道channel被关闭。上面的例子中如果把<code>close(c)</code>注释掉，程序会一直阻塞在<code>for …… range</code>那一行。</p>
<h2 id="select">select</h2>
<p><code>select</code>语句选择一组可能的send操作和receive操作去处理。它类似<code>switch</code>,但是只是用来处理通讯(communication)操作。
它的<code>case</code>可以是send语句，也可以是receive语句，亦或者<code>default</code>。</p>
<p><code>receive</code>语句可以将值赋值给一个或者两个变量。它必须是一个receive操作。</p>
<p>最多允许有一个<code>default case</code>,它可以放在case列表的任何位置，尽管我们大部分会将它放在最后。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
<span class="kd">func</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">quit</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">x</span><span class="p">:</span>
			<span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="o">+</span><span class="nx">y</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">quit</span><span class="p">:</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;quit&#34;</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="nx">quit</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">quit</span> <span class="o">&lt;-</span> <span class="mi">0</span>
	<span class="p">}()</span>
	<span class="nf">fibonacci</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">quit</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果有同时多个case去处理,比如同时有多个channel可以接收数据，那么Go会伪随机的选择一个case处理(pseudo-random)。如果没有case需要处理，则会选择<code>default</code>去处理，如果<code>default case</code>存在的情况下。如果没有<code>default case</code>，则<code>select</code>语句会阻塞，直到某个case需要处理。</p>
<p>需要注意的是，nil channel上的操作会一直被阻塞，如果没有default case,只有nil channel的select会一直被阻塞。</p>
<p><code>select</code>语句和<code>switch</code>语句一样，它不是循环，它只会选择一个case来处理，如果想一直处理channel，你可以在外面加一个无限的for循环：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="p">{</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">x</span><span class="p">:</span>
		<span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="o">+</span><span class="nx">y</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">quit</span><span class="p">:</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;quit&#34;</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="timeout">timeout</h3>
<p><code>select</code>有很重要的一个应用就是超时处理。 因为上面我们提到，如果没有case需要处理，select语句就会一直阻塞着。这时候我们可能就需要一个超时操作，用来处理超时的情况。
下面这个例子我们会在2秒后往channel c1中发送一个数据，但是<code>select</code>设置为1秒超时,因此我们会打印出<code>timeout 1</code>,而不是<code>result 1</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;time&#34;</span>
<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">c1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="nx">c1</span> <span class="o">&lt;-</span> <span class="s">&#34;result 1&#34;</span>
    <span class="p">}()</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">res</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">c1</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">1</span><span class="p">):</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;timeout 1&#34;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其实它利用的是<code>time.After</code>方法，它返回一个类型为<code>&lt;-chan Time</code>的单向的channel，在指定的时间发送一个当前时间给返回的channel中。</p>
<h2 id="timer-和-ticker">Timer 和 Ticker</h2>
<p>我们看一下关于时间的两个Channel。
timer是一个定时器，代表未来的一个单一事件，你可以告诉timer你要等待多长时间，它提供一个Channel，在将来的那个时间那个Channel提供了一个时间值。下面的例子中第二行会阻塞2秒钟左右的时间，直到时间到了才会继续执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">timer1</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="o">&lt;-</span><span class="nx">timer1</span><span class="p">.</span><span class="nx">C</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Timer 1 expired&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>当然如果你只是想单纯的等待的话，可以使用<code>time.Sleep</code>来实现。</p>
<p>你还可以使用<code>timer.Stop</code>来停止计时器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">timer2</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
	<span class="o">&lt;-</span><span class="nx">timer2</span><span class="p">.</span><span class="nx">C</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Timer 2 expired&#34;</span><span class="p">)</span>
<span class="p">}()</span>
<span class="nx">stop2</span> <span class="o">:=</span> <span class="nx">timer2</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">stop2</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Timer 2 stopped&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>ticker</code>是一个定时触发的计时器，它会以一个间隔(interval)往Channel发送一个事件(当前时间)，而Channel的接收者可以以固定的时间间隔从Channel中读取事件。下面的例子中ticker每500毫秒触发一次，你可以观察输出的时间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ticker</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">500</span><span class="p">)</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">t</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ticker</span><span class="p">.</span><span class="nx">C</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Tick at&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}()</span>
</code></pre></td></tr></table>
</div>
</div><p>类似timer, ticker也可以通过<code>Stop</code>方法来停止。一旦它停止，接收者不再会从channel中接收数据了。</p>
<h2 id="close">close</h2>
<p>内建的close方法可以用来关闭channel。</p>
<p>总结一下channel关闭后sender的receiver操作。
如果channel c已经被关闭,继续往它发送数据会导致<code>panic: send on closed channel</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;time&#34;</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
	<span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span>
	<span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">2</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">3</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>但是从这个关闭的channel中不但可以读取出已发送的数据，还可以不断的读取零值:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span>
<span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">2</span>
<span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">)</span> <span class="c1">//1
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">)</span> <span class="c1">//2
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">)</span> <span class="c1">//0
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">)</span> <span class="c1">//0
</span></code></pre></td></tr></table>
</div>
</div><p>但是如果通过<code>range</code>读取，channel关闭后for循环会跳出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span>
<span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">2</span>
<span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过<code>i, ok := &lt;-c</code>可以查看Channel的状态，判断值是零值还是正常读取的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>

<span class="nx">i</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">c</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d, %t&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">ok</span><span class="p">)</span> <span class="c1">//0, false
</span></code></pre></td></tr></table>
</div>
</div><h2 id="同步">同步</h2>
<p>channel可以用在goroutine之间的同步。
下面的例子中main goroutine通过done channel等待worker完成任务。 worker做完任务后只需往channel发送一个数据就可以通知main goroutine任务完成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">done</span> <span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="c1">// 通知任务已完成
</span><span class="c1"></span>	<span class="nx">done</span> <span class="o">&lt;-</span> <span class="kc">true</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span>
	<span class="c1">// 等待任务完成
</span><span class="c1"></span>	<span class="o">&lt;-</span><span class="nx">done</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>[参考资料]：</strong></p>
<ol>
<li><a href="https://gobyexample.com/channels">https://gobyexample.com/channels</a></li>
<li><a href="https://tour.golang.org/concurrency/2">https://tour.golang.org/concurrency/2</a></li>
<li><a href="https://golang.org/ref/spec#Select_statements">https://golang.org/ref/spec#Select_statements</a></li>
<li><a href="https://github.com/a8m/go-lang-cheat-sheet">https://github.com/a8m/go-lang-cheat-sheet</a></li>
<li><a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/">http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/</a></li>
</ol>
]]></content><category scheme="https://yusank.github.io/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术"/><category scheme="https://yusank.github.io/tags/go/" term="go" label="go"/><category scheme="https://yusank.github.io/tags/channel/" term="channel" label="channel"/></entry><entry><title type="text">新的篇章</title><link rel="alternate" type="text/html" href="https://yusank.github.io/posts/my-first-post/"/><id>https://yusank.github.io/posts/my-first-post/</id><updated>2021-07-04T08:33:24+00:00</updated><published>2020-03-06T16:14:29+08:00</published><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><summary type="html">由于上一个博客项目的原文件丢失，无法继续更新，只会重新开启新的博客项目，重新做起~ 技术原因原博客已下线，原博客技术文档会……</summary><content type="html">&lt;p>由于上一个博客项目的原文件丢失，无法继续更新，只会重新开启新的博客项目，重新做起~&lt;/p>
&lt;p>技术原因原博客已下线，原博客技术文档会逐步同步到新博客上。&lt;/p></content></entry><entry><title type="text">Go Image</title><link rel="alternate" type="text/html" href="https://yusank.github.io/posts/go-image/"/><id>https://yusank.github.io/posts/go-image/</id><updated>2021-07-04T08:33:24+00:00</updated><published>2017-08-22T12:20:00+08:00</published><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><summary type="html">用 GO 实现图片处理和文字合成 Go 的图片处理 最近需要一个合成明信片的工具，即往背景图的固定位置上添加一个图片和一段文字， 最后合……</summary><content type="html"><![CDATA[<p>用 GO 实现图片处理和文字合成</p>
<h1 id="go-的图片处理">Go 的图片处理</h1>
<p>最近需要一个合成明信片的工具，即往背景图的固定位置上添加一个图片和一段文字， 最后合成一张图片。由于是 go 程序的一个子功能，所以我想我只加拿 go 写好了，正好有 go 的 <code>image</code> 库，拿来练练。</p>
<h2 id="图片合成">图片合成</h2>
<p>图片合成我用到了这个库  <code>github.com/disintegration/imaging</code></p>
<p>代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;image&#34;</span>

    <span class="s">&#34;github.com/disintegration/imaging&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">HandleUserImage</span><span class="p">(</span><span class="nx">fileName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">imaging</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;target.jpg&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;open file failed&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">bm</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">imaging</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;bg.jpg&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;open file failed&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 图片按比例缩放
</span><span class="c1"></span>	<span class="nx">dst</span> <span class="o">:=</span> <span class="nx">imaging</span><span class="p">.</span><span class="nf">Resize</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="nx">imaging</span><span class="p">.</span><span class="nx">Lanczos</span><span class="p">)</span>
	<span class="c1">// 将图片粘贴到背景图的固定位置
</span><span class="c1"></span>	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">imaging</span><span class="p">.</span><span class="nf">Overlay</span><span class="p">(</span><span class="nx">bm</span><span class="p">,</span> <span class="nx">dst</span><span class="p">,</span> <span class="nx">image</span><span class="p">.</span><span class="nf">Pt</span><span class="p">(</span><span class="mi">120</span><span class="p">,</span> <span class="mi">140</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

	<span class="nx">fileName</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%d.jpg&#34;</span><span class="p">,</span> <span class="nx">fileName</span><span class="p">)</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">imaging</span><span class="p">.</span><span class="nf">Save</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">fileName</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">fileName</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>以上是将 <code>target.jpg</code> 文件先进行缩放，再贴到 <code>bg.jpg</code> 文件的 （120，140）位置，最后保存成文件。</p>
<h2 id="图片上写文字">图片上写文字</h2>
<p>以下是写文字和贴图的一块用的实例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;image&#34;</span>
	<span class="s">&#34;image/color&#34;</span>
	<span class="s">&#34;io/ioutil&#34;</span>

	<span class="s">&#34;github.com/disintegration/imaging&#34;</span>
	<span class="s">&#34;github.com/golang/freetype&#34;</span>
	<span class="s">&#34;github.com/golang/freetype/truetype&#34;</span>
	<span class="s">&#34;golang.org/x/image/font&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">HandleUserImage</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// HandleUserImage paste user image onto background
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">HandleUserImage</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">imaging</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;target.png&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;open file failed&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">bm</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">imaging</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;bg.jpg&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;open file failed&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 图片按比例缩放
</span><span class="c1"></span>	<span class="nx">dst</span> <span class="o">:=</span> <span class="nx">imaging</span><span class="p">.</span><span class="nf">Resize</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="nx">imaging</span><span class="p">.</span><span class="nx">Lanczos</span><span class="p">)</span>
	<span class="c1">// 将图片粘贴到背景图的固定位置
</span><span class="c1"></span>	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">imaging</span><span class="p">.</span><span class="nf">Overlay</span><span class="p">(</span><span class="nx">bm</span><span class="p">,</span> <span class="nx">dst</span><span class="p">,</span> <span class="nx">image</span><span class="p">.</span><span class="nf">Pt</span><span class="p">(</span><span class="mi">120</span><span class="p">,</span> <span class="mi">140</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nf">writeOnImage</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>

	<span class="nx">fileName</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%d.jpg&#34;</span><span class="p">,</span> <span class="mi">1234</span><span class="p">)</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">imaging</span><span class="p">.</span><span class="nf">Save</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">fileName</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">fileName</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">dpi</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">Float64</span><span class="p">(</span><span class="s">&#34;dpi&#34;</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="s">&#34;screen resolution&#34;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">writeOnImage</span><span class="p">(</span><span class="nx">target</span> <span class="o">*</span><span class="nx">image</span><span class="p">.</span><span class="nx">NRGBA</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">freetype</span><span class="p">.</span><span class="nf">NewContext</span><span class="p">()</span>

	<span class="nx">c</span><span class="p">.</span><span class="nf">SetDPI</span><span class="p">(</span><span class="o">*</span><span class="nx">dpi</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">SetClip</span><span class="p">(</span><span class="nx">target</span><span class="p">.</span><span class="nf">Bounds</span><span class="p">())</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">SetDst</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">SetHinting</span><span class="p">(</span><span class="nx">font</span><span class="p">.</span><span class="nx">HintingFull</span><span class="p">)</span>

        <span class="c1">// 设置文字颜色、字体、字大小
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nf">SetSrc</span><span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nf">NewUniform</span><span class="p">(</span><span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="nx">R</span><span class="p">:</span> <span class="mi">240</span><span class="p">,</span> <span class="nx">G</span><span class="p">:</span> <span class="mi">240</span><span class="p">,</span> <span class="nx">B</span><span class="p">:</span> <span class="mi">245</span><span class="p">,</span> <span class="nx">A</span><span class="p">:</span> <span class="mi">180</span><span class="p">}))</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">SetFontSize</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
	<span class="nx">fontFam</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">getFontFamily</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;get font family error&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">SetFont</span><span class="p">(</span><span class="nx">fontFam</span><span class="p">)</span>

	<span class="nx">pt</span> <span class="o">:=</span> <span class="nx">freetype</span><span class="p">.</span><span class="nf">Pt</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span>

	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">DrawString</span><span class="p">(</span><span class="s">&#34;我是水印&#34;</span><span class="p">,</span> <span class="nx">pt</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;draw error: %v \n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="nf">getFontFamily</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">truetype</span><span class="p">.</span><span class="nx">Font</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 这里需要读取中文字体，否则中文文字会变成方格
</span><span class="c1"></span>	<span class="nx">fontBytes</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="s">&#34;Hei.ttc&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;read file error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="nx">truetype</span><span class="p">.</span><span class="nx">Font</span><span class="p">{},</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">freetype</span><span class="p">.</span><span class="nf">ParseFont</span><span class="p">(</span><span class="nx">fontBytes</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;parse font error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="nx">truetype</span><span class="p">.</span><span class="nx">Font</span><span class="p">{},</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span>
</code></pre></td></tr></table>
</div>
</div><p>最后来一张效果图
<img src="http://oid1xlj7h.bkt.clouddn.com/image/jpg/1234.jpg" alt=""></p>
<h2 id="总结">总结</h2>
<p>做的过程中，合作这一块比较好做，但是图片上写文字，相对比较麻烦，而且 <code>freetype</code> 库并没有默认的中英文字体，如果不指定字体会报错，而且字体格式只限制于 <code>ttf</code> 和 <code>ttc</code> 两种。</p>
]]></content><category scheme="https://yusank.github.io/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术"/><category scheme="https://yusank.github.io/tags/go/" term="go" label="go"/><category scheme="https://yusank.github.io/tags/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/" term="图片处理" label="图片处理"/></entry><entry><title type="text">Go UDP Socket</title><link rel="alternate" type="text/html" href="https://yusank.github.io/posts/go-udp/"/><id>https://yusank.github.io/posts/go-udp/</id><updated>2021-07-04T08:33:24+00:00</updated><published>2017-08-02T19:00:01+08:00</published><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><summary type="html">udp 和 tcp 的简单比较和用 go 实现最简单的 udp 客户端和服务端 ...... 用 go 实现简单的 udp 用户数据包协议（英语：User Datagram Protocol，缩……</summary><content type="html"><![CDATA[<p>udp 和 tcp 的简单比较和用 go 实现最简单的 udp 客户端和服务端 ......</p>
<h1 id="用-go-实现简单的-udp">用 go 实现简单的 udp</h1>
<p>用户数据包协议（英语：User Datagram Protocol，缩写为UDP），又称用户数据报文协议，是一个简单的面向数据报的传输层协议，正式规范为RFC 768。
在TCP/IP模型中，UDP为网络层以上和应用层以下提供了一个简单的接口。UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议）。UDP在IP数据报的头部仅仅加入了复用和数据校验（字段）。</p>
<h2 id="udp-与-tcp-的比较">UDP 与 TCP 的比较</h2>
<ul>
<li>
<p>UDP -- 用户数据协议包，是一个简单的面向数据报的运输层协议。UDP 不提供可靠性，它只是把应用程序给 IP 层的数据报发送出去，但是并不能保证他们能达到目的地。由于 UDP 在传输数据报之前不用在客户端和服务端之间建立连接，且没有超时机制，故而传输速度很快。</p>
</li>
<li>
<p>TCP -- 传输控制协议，提供的是面向连接，可靠的字节流服务。当客户端和服务端彼此交换数据前，必须先在双方之间建立 TCP 连接，之后才能传输数据。TCP 提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一段传到另一端。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>-</th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否连接</td>
<td>面向连接</td>
<td>面向非连接</td>
</tr>
<tr>
<td>传输可靠性</td>
<td>可靠</td>
<td>会丢包，不可靠</td>
</tr>
<tr>
<td>应用场景</td>
<td>传输数据量大</td>
<td>传输数据量小</td>
</tr>
<tr>
<td>速度</td>
<td>慢</td>
<td>快</td>
</tr>
</tbody>
</table>
<h2 id="tcp-与-udp-的选择">TCP 与 UDP 的选择</h2>
<p>当数据传输的性能必须让位于数据传输的完整性、可控制性和可靠性时，TCP协议是当然的选择。当强调传输性能而不是传输的完整性时，如：音频和多媒体应用，UDP是最好的选择。在数据传输时间很短，以至于此前的连接过程成为整个流量主体的情况下，UDP也是一个好的选择，如：DNS交换。把SNMP建立在UDP上的部分原因是设计者认为当发生网络阻塞时，UDP较低的开销使其有更好的机会去传送管理数据。TCP丰富的功能有时会导致不可预料的性能低下，但是我们相信在不远的将来，TCP可靠的点对点连接将会用于绝大多数的网络应用。</p>
<h2 id="udp-使用场景">UDP 使用场景</h2>
<p>在选择使用协议的时候，选择UDP必须要谨慎。在网络质量令人十分不满意的环境下，UDP协议数据包丢失会比较严重。但是由于UDP的特性：它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。而且如果在内网的情况下，丢包率也很低，所以内网的数据传输也可以用 UDP 协议。我们常用的 QQ，一部分数据传输功能也是用 UDP协议来实现的。</p>
<h2 id="实现">实现</h2>
<p>下面分别是服务端和客户端实现代码：
服务端代码 <code>server.go</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;net&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 解析地址
</span><span class="c1"></span>	<span class="nx">addr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">ResolveUDPAddr</span><span class="p">(</span><span class="s">&#34;udp&#34;</span><span class="p">,</span> <span class="s">&#34;:3017&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Can&#39;t resolve addr:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 监听端口
</span><span class="c1"></span>	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">ListenUDP</span><span class="p">(</span><span class="s">&#34;udp&#34;</span><span class="p">,</span> <span class="nx">addr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;listen error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nf">handlerClient</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">handlerClient</span><span class="p">(</span><span class="nx">conn</span> <span class="o">*</span><span class="nx">net</span><span class="p">.</span><span class="nx">UDPConn</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
	<span class="c1">// 从 UDP 中读取内容并写到 data
</span><span class="c1"></span>	<span class="nx">_</span><span class="p">,</span> <span class="nx">remoteAddr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">ReadFromUDP</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;read udp msg failed with:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 给收到消息的 client 写回信息
</span><span class="c1"></span>	<span class="nx">conn</span><span class="p">.</span><span class="nf">WriteToUDP</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">),</span> <span class="nx">remoteAddr</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>客户端代码<code>client.go</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">client</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;net&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="c1">// Connection *net.UDPConn
</span><span class="c1"></span>	<span class="nx">Connection</span> <span class="p">[]</span><span class="o">*</span><span class="nx">net</span><span class="p">.</span><span class="nx">UDPConn</span>
<span class="p">)</span>

<span class="c1">// Client 创建一个 UDP 连接
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Client</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">addr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">ResolveUDPAddr</span><span class="p">(</span><span class="s">&#34;udp&#34;</span><span class="p">,</span> <span class="s">&#34;127.0.0.1:3017&#34;</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Can&#39;t resolve address: &#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>

		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">DialUDP</span><span class="p">(</span><span class="s">&#34;udp&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">addr</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Can&#39;t dial: &#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>

		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">Connection</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">Connection</span><span class="p">,</span> <span class="nx">conn</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// WriteTo 像传入参数 conn 写数据
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">WriteTo</span><span class="p">(</span><span class="nx">conn</span> <span class="o">*</span><span class="nx">net</span><span class="p">.</span><span class="nx">UDPConn</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hello from the other site&#34;</span><span class="p">))</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;failed:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;failed to read UDP msg because of &#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="总结">总结</h2>
<p>以上是一个最简单的 UDP 客户端服务器的代码，只有启动服务和收发消息的功能，但实际应用 UDP 协议到具体需求的时候，需要考虑的问题很多，比如包的设计，包头的设计，错误处理，丢包处理，包顺序调换处理等。所以需要用到传输数据协议的时候，请考虑好需求和可能遇到的问题，以及对问题的处理方案。</p>
]]></content><category scheme="https://yusank.github.io/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术"/><category scheme="https://yusank.github.io/tags/go/" term="go" label="go"/><category scheme="https://yusank.github.io/tags/udp/" term="udp" label="udp"/><category scheme="https://yusank.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" term="网络编程" label="网络编程"/></entry><entry><title type="text">Go TCP Socket</title><link rel="alternate" type="text/html" href="https://yusank.github.io/posts/go-tcp/"/><id>https://yusank.github.io/posts/go-tcp/</id><updated>2021-07-04T08:33:24+00:00</updated><published>2017-07-31T10:00:01+08:00</published><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><summary type="html">转载文章 Go语言TCP Socket编程 文章原始地址: http://tonybai.com/2015/11/17/tcp-programming-in-golang/ Golang的主要 设计目标之一就是面向大规模后端服务程序，网络通信……</summary><content type="html"><![CDATA[<p><code>转载文章</code></p>
<h1 id="go语言tcp-socket编程">Go语言TCP Socket编程</h1>
<p><strong>文章原始地址:</strong> <a href="http://tonybai.com/2015/11/17/tcp-programming-in-golang/">http://tonybai.com/2015/11/17/tcp-programming-in-golang/</a></p>
<p><a href="http://tonybai.com/tag/go">Golang</a>的主要 设计目标之一就是面向大规模后端服务程序，网络通信这块是服务端 程序必不可少也是至关重要的一部分。在日常应用中，我们也可以看到Go中的net以及其subdirectories下的包均是“高频+刚需”，而TCP socket则是网络编程的主流，即便您没有直接使用到net中有关TCP Socket方面的接口，但net/http总是用到了吧，http底层依旧是用tcp socket实现的。</p>
<p>网络编程方面，我们最常用的就是tcp socket编程了，在posix标准出来后，socket在各大主流OS平台上都得到了很好的支持。关于tcp programming，最好的资料莫过于<a href="http://en.wikipedia.org/wiki/W._Richard_Stevens">W. Richard Stevens</a> 的网络编程圣经《<a href="http://book.douban.com/subject/4859464/">UNIX网络 编程 卷1：套接字联网API</a>》 了，书中关于tcp socket接口的各种使用、行为模式、异常处理讲解的十分细致。Go是自带runtime的跨平台编程语言，Go中暴露给语言使用者的tcp socket api是建立OS原生tcp socket接口之上的。由于Go runtime调度的需要，golang tcp socket接口在行为特点与异常处理方面与OS原生接口有着一些差别。这篇博文的目标就是整理出关于Go tcp socket在各个场景下的使用方法、行为特点以及注意事项。</p>
<h2 id="一模型">一、模型</h2>
<p>从tcp socket诞生后，网络编程架构模型也几经演化，大致是：“每进程一个连接” –&gt; “每线程一个连接” –&gt; “Non-Block + I/O多路复用(linux epoll/windows iocp/freebsd darwin kqueue/solaris Event Port)”。伴随着模型的演化，服务程序愈加强大，可以支持更多的连接，获得更好的处理性能。</p>
<p>目前主流web server一般均采用的都是”Non-Block + I/O多路复用”（有的也结合了多线程、多进程）。不过I/O多路复用也给使用者带来了不小的复杂度，以至于后续出现了许多高性能的I/O多路复用框架， 比如<a href="http://libevent.org/">libevent</a>、<a href="http://software.schmorp.de/pkg/libev.html">libev</a>、<a href="https://github.com/joyent/libuv">libuv</a>等，以帮助开发者简化开发复杂性，降低心智负担。不过Go的设计者似乎认为I/O多路复用的这种通过回调机制割裂控制流 的方式依旧复杂，且有悖于“一般逻辑”设计，为此Go语言将该“复杂性”隐藏在Runtime中了：Go开发者无需关注socket是否是 non-block的，也无需亲自注册文件描述符的回调，只需在每个连接对应的goroutine中以**“block I/O”**的方式对待socket处理即可，这可以说大大降低了开发人员的心智负担。一个典型的Go server端程序大致如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go-tcpsock/server.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// read from the connection
</span><span class="c1"></span>        <span class="c1">// ... ...
</span><span class="c1"></span>        <span class="c1">// write to the connection
</span><span class="c1"></span>        <span class="c1">//... ...
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">l</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:8888&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;listen error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">c</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;accept error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="c1">// start a new goroutine to handle
</span><span class="c1"></span>        <span class="c1">// the new connection.
</span><span class="c1"></span>        <span class="k">go</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>用户层眼中看到的goroutine中的“block socket”，实际上是通过Go runtime中的netpoller通过Non-block socket + I/O多路复用机制“模拟”出来的，真实的underlying socket实际上是non-block的，只是runtime拦截了底层socket系统调用的错误码，并通过netpoller和goroutine 调度让goroutine“阻塞”在用户层得到的Socket fd上。比如：当用户层针对某个socket fd发起read操作时，如果该socket fd中尚无数据，那么runtime会将该socket fd加入到netpoller中监听，同时对应的goroutine被挂起，直到runtime收到socket fd 数据ready的通知，runtime才会重新唤醒等待在该socket fd上准备read的那个Goroutine。而这个过程从Goroutine的视角来看，就像是read操作一直block在那个socket fd上似的。具体实现细节在后续场景中会有补充描述。</p>
<h2 id="二tcp连接的建立">二、TCP连接的建立</h2>
<p>众所周知，TCP Socket的连接的建立需要经历客户端和服务端的三次握手的过程。连接建立过程中，服务端是一个标准的Listen + Accept的结构(可参考上面的代码)，而在客户端Go语言使用net.Dial或DialTimeout进行连接建立：</p>
<p>阻塞Dial：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;google.com:80&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">//handle error
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// read or write on conn
</span></code></pre></td></tr></table>
</div>
</div><p>或是带上超时机制的Dial：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">DialTimeout</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">//handle error
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// read or write on conn
</span><span class="c1"></span>
</code></pre></td></tr></table>
</div>
</div><p>对于客户端而言，连接的建立会遇到如下几种情形：</p>
<h3 id="1网络不可达或对方服务未启动">1、网络不可达或对方服务未启动</h3>
<p>如果传给Dial的Addr是可以立即判断出网络不可达，或者Addr中端口对应的服务没有启动，端口未被监听，Dial会几乎立即返回错误，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go-tcpsock/conn_establish/client1.go
</span><span class="c1"></span><span class="o">...</span> <span class="o">...</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;begin dial...&#34;</span><span class="p">)</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:8888&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;dial error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;dial ok&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果本机8888端口未有服务程序监听，那么执行上面程序，Dial会很快返回错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">$go</span> run client1.go
2015/11/16 14:37:41 begin dial...
2015/11/16 14:37:41 dial error: dial tcp :8888: getsockopt: connection refused
</code></pre></td></tr></table>
</div>
</div><h3 id="2对方服务的listen-backlog满">2、对方服务的listen backlog满</h3>
<p>还有一种场景就是对方服务器很忙，瞬间有大量client端连接尝试向server建立，server端的listen backlog队列满，server accept不及时((即便不accept，那么在backlog数量范畴里面，connect都会是成功的，因为new conn已经加入到server side的listen queue中了，accept只是从queue中取出一个conn而已)，这将导致client端Dial阻塞。我们还是通过例子感受Dial的行为特点：</p>
<p>服务端代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go-tcpsock/conn_establish/server2.go
</span><span class="c1"></span><span class="o">...</span> <span class="o">...</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">l</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:8888&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;error listen:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;listen ok&#34;</span><span class="p">)</span>

    <span class="kd">var</span> <span class="nx">i</span> <span class="kt">int</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Accept</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;accept error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="nx">i</span><span class="o">++</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d: accept a new connection\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>客户端代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go-tcpsock/conn_establish/client2.go
</span><span class="c1"></span><span class="o">...</span> <span class="o">...</span>
<span class="kd">func</span> <span class="nf">establishConn</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span> <span class="p">{</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:8888&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d: dial error: %s&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="s">&#34;:connect to server ok&#34;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">conn</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">sl</span> <span class="p">[]</span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">conn</span> <span class="o">:=</span> <span class="nf">establishConn</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">conn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">sl</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">sl</span><span class="p">,</span> <span class="nx">conn</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">10000</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从程序可以看出，服务端在listen成功后，每隔10s钟accept一次。客户端则是串行的尝试建立连接。这两个程序在Darwin下的执行 结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">$go</span> run server2.go
2015/11/16 21:55:41 listen ok
2015/11/16 21:55:51 1: accept a new connection
2015/11/16 21:56:01 2: accept a new connection
... ...

<span class="nv">$go</span> run client2.go
2015/11/16 21:55:44 <span class="m">1</span> :connect to server ok
2015/11/16 21:55:44 <span class="m">2</span> :connect to server ok
2015/11/16 21:55:44 <span class="m">3</span> :connect to server ok
... ...

2015/11/16 21:55:44 <span class="m">126</span> :connect to server ok
2015/11/16 21:55:44 <span class="m">127</span> :connect to server ok
2015/11/16 21:55:44 <span class="m">128</span> :connect to server ok

2015/11/16 21:55:52 <span class="m">129</span> :connect to server ok
2015/11/16 21:56:03 <span class="m">130</span> :connect to server ok
2015/11/16 21:56:14 <span class="m">131</span> :connect to server ok
... ...
</code></pre></td></tr></table>
</div>
</div><p>可以看出Client初始时成功地一次性建立了128个连接，然后后续每阻塞近10s才能成功建立一条连接。也就是说在server端 backlog满时(未及时accept)，客户端将阻塞在Dial上，直到server端进行一次accept。至于为什么是128，这与darwin 下的默认设置有关：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">$sysctl</span> -a<span class="p">|</span>grep kern.ipc.somaxconn
kern.ipc.somaxconn: <span class="m">128</span>
</code></pre></td></tr></table>
</div>
</div><p>如果我在ubuntu 14.04上运行上述server程序，我们的client端初始可以成功建立499条连接。</p>
<p>如果server一直不accept，client端会一直阻塞么？我们去掉accept后的结果是：在Darwin下，client端会阻塞大 约1分多钟才会返回timeout：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">2015/11/16 22:03:31 <span class="m">128</span> :connect to server ok
2015/11/16 22:04:48 129: dial error: dial tcp :8888: getsockopt: operation timed out
</code></pre></td></tr></table>
</div>
</div><p>而如果server运行在ubuntu 14.04上，client似乎一直阻塞，我等了10多分钟依旧没有返回。 阻塞与否看来与server端的网络实现和设置有关。</p>
<h3 id="3网络延迟较大dial阻塞并超时">3、网络延迟较大，Dial阻塞并超时</h3>
<p>如果网络延迟较大，TCP握手过程将更加艰难坎坷（各种丢包），时间消耗的自然也会更长。Dial这时会阻塞，如果长时间依旧无法建立连接，则Dial也会返回“ getsockopt: operation timed out”错误。</p>
<p>在连接建立阶段，多数情况下，Dial是可以满足需求的，即便阻塞一小会儿。但对于某些程序而言，需要有严格的连接时间限定，如果一定时间内没能成功建立连接，程序可能会需要执行一段“异常”处理逻辑，为此我们就需要DialTimeout了。下面的例子将Dial的最长阻塞时间限制在2s内，超出这个时长，Dial将返回timeout error：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go-tcpsock/conn_establish/client3.go
</span><span class="c1"></span><span class="o">...</span> <span class="o">...</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;begin dial...&#34;</span><span class="p">)</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">DialTimeout</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;104.236.176.96:80&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;dial error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;dial ok&#34;</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>执行结果如下（需要模拟一个延迟较大的网络环境）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">$go</span> run client3.go
2015/11/17 09:28:34 begin dial...
2015/11/17 09:28:36 dial error: dial tcp 104.236.176.96:80: i/o timeout
</code></pre></td></tr></table>
</div>
</div><h2 id="三socket读写">三、Socket读写</h2>
<p>连接建立起来后，我们就要在conn上进行读写，以完成业务逻辑。前面说过Go runtime隐藏了I/O多路复用的复杂性。语言使用者只需采用goroutine+Block I/O的模式即可满足大部分场景需求。Dial成功后，方法返回一个net.Conn接口类型变量值，这个接口变量的动态类型为一个*TCPConn：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//$GOROOT/src/net/tcpsock_posix.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">TCPConn</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">conn</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>TCPConn内嵌了一个unexported类型：conn，因此TCPConn”继承”了conn的Read和Write方法，后续通过Dial返回值调用的Write和Read方法均是net.conn的方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//$GOROOT/src/net/net.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">conn</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">fd</span> <span class="o">*</span><span class="nx">netFD</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">conn</span><span class="p">)</span> <span class="nf">ok</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">}</span>

<span class="c1">// Implementation of the Conn interface.
</span><span class="c1"></span>
<span class="c1">// Read implements the Conn Read method.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">conn</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nf">ok</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EINVAL</span>
    <span class="p">}</span>
    <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">OpError</span><span class="p">{</span><span class="nx">Op</span><span class="p">:</span> <span class="s">&#34;read&#34;</span><span class="p">,</span> <span class="nx">Net</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">net</span><span class="p">,</span> <span class="nx">Source</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">laddr</span><span class="p">,</span> <span class="nx">Addr</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">raddr</span><span class="p">,</span> <span class="nx">Err</span><span class="p">:</span> <span class="nx">err</span><span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="c1">// Write implements the Conn Write method.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">conn</span><span class="p">)</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nf">ok</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EINVAL</span>
    <span class="p">}</span>
    <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">OpError</span><span class="p">{</span><span class="nx">Op</span><span class="p">:</span> <span class="s">&#34;write&#34;</span><span class="p">,</span> <span class="nx">Net</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">net</span><span class="p">,</span> <span class="nx">Source</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">laddr</span><span class="p">,</span> <span class="nx">Addr</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">raddr</span><span class="p">,</span> <span class="nx">Err</span><span class="p">:</span> <span class="nx">err</span><span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>下面我们先来通过几个场景来总结一下conn.Read的行为特点。</p>
<h3 id="1socket中无数据">1、Socket中无数据</h3>
<p>连接建立后，如果对方未发送数据到socket，接收方(Server)会阻塞在Read操作上，这和前面提到的“模型”原理是一致的。执行该Read操作的goroutine也会被挂起。runtime会监视该socket，直到其有数据才会重新
调度该socket对应的Goroutine完成read。由于篇幅原因，这里就不列代码了，例子对应的代码文件：go-tcpsock/read_write下的client1.go和server1.go。</p>
<h3 id="2socket中有部分数据">2、Socket中有部分数据</h3>
<p>如果socket中有部分数据，且长度小于一次Read操作所期望读出的数据长度，那么Read将会成功读出这部分数据并返回，而不是等待所有期望数据全部读取后再返回。</p>
<p>Client端：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go-tcpsock/read_write/client2.go
</span><span class="c1"></span><span class="o">...</span> <span class="o">...</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;usage: go run client2.go YOUR_CONTENT&#34;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;begin dial...&#34;</span><span class="p">)</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:8888&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;dial error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;dial ok&#34;</span><span class="p">)</span>

    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
    <span class="nx">data</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span>

    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">10000</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>Server端：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go-tcpsock/read_write/server2.go
</span><span class="c1"></span><span class="o">...</span> <span class="o">...</span>
<span class="kd">func</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// read from the connection
</span><span class="c1"></span>        <span class="kd">var</span> <span class="nx">buf</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;start to read from conn&#34;</span><span class="p">)</span>
        <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;conn read error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;read %d bytes, content is %s\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">]))</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="o">...</span> <span class="o">...</span>

</code></pre></td></tr></table>
</div>
</div><p>我们通过<code>client2.go</code>发送”hi”到Server端：
运行结果:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">$go</span> run client2.go hi
2015/11/17 13:30:53 begin dial...
2015/11/17 13:30:53 dial ok

<span class="nv">$go</span> run server2.go
2015/11/17 13:33:45 accept a new connection
2015/11/17 13:33:45 start to <span class="nb">read</span> from conn
2015/11/17 13:33:47 <span class="nb">read</span> <span class="m">2</span> bytes, content is hi
...
</code></pre></td></tr></table>
</div>
</div><p>Client向socket中写入两个字节数据(“hi”)，Server端创建一个len = 10的slice，等待Read将读取的数据放入slice；Server随后读取到那两个字节：”hi”。Read成功返回，n =2 ，err = nil。</p>
<h3 id="3socket中有足够数据">3、Socket中有足够数据</h3>
<p>如果socket中有数据，且长度大于等于一次Read操作所期望读出的数据长度，那么Read将会成功读出这部分数据并返回。这个情景是最符合我们对Read的期待的了：Read将用Socket中的数据将我们传入的slice填满后返回：n = 10, err = nil。</p>
<p>我们通过client2.go向Server2发送如下内容：abcdefghij12345，执行结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">$go</span> run client2.go abcdefghij12345
2015/11/17 13:38:00 begin dial...
2015/11/17 13:38:00 dial ok

<span class="nv">$go</span> run server2.go
2015/11/17 13:38:00 accept a new connection
2015/11/17 13:38:00 start to <span class="nb">read</span> from conn
2015/11/17 13:38:02 <span class="nb">read</span> <span class="m">10</span> bytes, content is abcdefghij
2015/11/17 13:38:02 start to <span class="nb">read</span> from conn
2015/11/17 13:38:02 <span class="nb">read</span> <span class="m">5</span> bytes, content is <span class="m">12345</span>
</code></pre></td></tr></table>
</div>
</div><p>client端发送的内容长度为15个字节，Server端Read buffer的长度为10，因此Server Read第一次返回时只会读取10个字节；Socket中还剩余5个字节数据，Server再次Read时会把剩余数据读出（如：情形2）。</p>
<h3 id="4socket关闭">4、Socket关闭</h3>
<p>如果client端主动关闭了socket，那么Server的Read将会读到什么呢？这里分为“有数据关闭”和“无数据关闭”。</p>
<p>“有数据关闭”是指在client关闭时，socket中还有server端未读取的数据，我们在go-tcpsock/read_write/client3.go和server3.go中模拟这种情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">$go</span> run client3.go hello
2015/11/17 13:50:57 begin dial...
2015/11/17 13:50:57 dial ok

<span class="nv">$go</span> run server3.go
2015/11/17 13:50:57 accept a new connection
2015/11/17 13:51:07 start to <span class="nb">read</span> from conn
2015/11/17 13:51:07 <span class="nb">read</span> <span class="m">5</span> bytes, content is hello
2015/11/17 13:51:17 start to <span class="nb">read</span> from conn
2015/11/17 13:51:17 conn <span class="nb">read</span> error: EOF
</code></pre></td></tr></table>
</div>
</div><p>从输出结果来看，当client端close socket退出后，server3依旧没有开始Read，10s后第一次Read成功读出了5个字节的数据，当第二次Read时，由于client端 socket关闭，Read返回EOF error。</p>
<p>通过上面这个例子，我们也可以猜测出“无数据关闭”情形下的结果，那就是Read直接返回EOF error。</p>
<h3 id="5读取操作超时">5、读取操作超时</h3>
<p>有些场合对Read的阻塞时间有严格限制，在这种情况下，Read的行为到底是什么样的呢？在返回超时错误时，是否也同时Read了一部分数据了呢？这个实验比较难于模拟，下面的测试结果也未必能反映出所有可能结果。我们编写了<code>client4.go</code>和<code>server4.go</code>来模拟这一情形。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go-tcpsock/read_write/client4.go
</span><span class="c1"></span><span class="o">...</span> <span class="o">...</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;begin dial...&#34;</span><span class="p">)</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:8888&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;dial error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;dial ok&#34;</span><span class="p">)</span>

    <span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">65536</span><span class="p">)</span>
    <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>

    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">10000</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//go-tcpsock/read_write/server4.go
</span><span class="c1"></span><span class="o">...</span> <span class="o">...</span>
<span class="kd">func</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// read from the connection
</span><span class="c1"></span>        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
        <span class="kd">var</span> <span class="nx">buf</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">65536</span><span class="p">)</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;start to read from conn&#34;</span><span class="p">)</span>
        <span class="nx">c</span><span class="p">.</span><span class="nf">SetReadDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Microsecond</span> <span class="o">*</span> <span class="mi">10</span><span class="p">))</span>
        <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;conn read %d bytes,  error: %s&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">nerr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Error</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">nerr</span><span class="p">.</span><span class="nf">Timeout</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">continue</span>
            <span class="p">}</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;read %d bytes, content is %s\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">]))</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>在Server端我们通过Conn的SetReadDeadline方法设置了10微秒的读超时时间，Server的执行结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">$go</span> run server4.go

2015/11/17 14:21:17 accept a new connection
2015/11/17 14:21:27 start to <span class="nb">read</span> from conn
2015/11/17 14:21:27 conn <span class="nb">read</span> <span class="m">0</span> bytes,  error: <span class="nb">read</span> tcp 127.0.0.1:8888-&gt;127.0.0.1:60970: i/o timeout
2015/11/17 14:21:37 start to <span class="nb">read</span> from conn
2015/11/17 14:21:37 <span class="nb">read</span> <span class="m">65536</span> bytes, content is

</code></pre></td></tr></table>
</div>
</div><p>虽然每次都是10微秒超时，但结果不同，第一次Read超时，读出数据长度为0；第二次读取所有数据成功，没有超时。反复执行了多次，没能出现“读出部分数据且返回超时错误”的情况。</p>
<p>和读相比，Write遇到的情形一样不少，我们也逐一看一下。</p>
<h3 id="1成功写">1、成功写</h3>
<p>前面例子着重于Read，client端在Write时并未判断Write的返回值。所谓“成功写”指的就是Write调用返回的n与预期要写入的数据长度相等，且error = nil。这是我们在调用Write时遇到的最常见的情形，这里不再举例了。</p>
<h3 id="2写阻塞">2、写阻塞</h3>
<p>TCP连接通信两端的OS都会为该连接保留数据缓冲，一端调用Write后，实际上数据是写入到OS的协议栈的数据缓冲的。TCP是全双工通信，因此每个方向都有独立的数据缓冲。当发送方将对方的接收缓冲区以及自身的发送缓冲区写满后，Write就会阻塞。我们来看一个例子：client5.go和server.go。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go-tcpsock/read_write/client5.go
</span><span class="c1"></span><span class="o">...</span> <span class="o">...</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;begin dial...&#34;</span><span class="p">)</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:8888&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;dial error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;dial ok&#34;</span><span class="p">)</span>

    <span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">65536</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">total</span> <span class="kt">int</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">total</span> <span class="o">+=</span> <span class="nx">n</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;write %d bytes, error:%s\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="nx">total</span> <span class="o">+=</span> <span class="nx">n</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;write %d bytes this time, %d bytes in total\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">total</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;write %d bytes in total\n&#34;</span><span class="p">,</span> <span class="nx">total</span><span class="p">)</span>
    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">10000</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//go-tcpsock/read_write/server5.go
</span><span class="c1"></span><span class="o">...</span> <span class="o">...</span>
<span class="kd">func</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// read from the connection
</span><span class="c1"></span>        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
        <span class="kd">var</span> <span class="nx">buf</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">60000</span><span class="p">)</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;start to read from conn&#34;</span><span class="p">)</span>
        <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;conn read %d bytes,  error: %s&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">nerr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Error</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">nerr</span><span class="p">.</span><span class="nf">Timeout</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">continue</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;read %d bytes, content is %s\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">]))</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="o">...</span> <span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><p>Server5在前10s中并不Read数据，因此当client5一直尝试写入时，写到一定量后就会发生阻塞：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">$go</span> run client5.go

2015/11/17 14:57:33 begin dial...
2015/11/17 14:57:33 dial ok
2015/11/17 14:57:33 write <span class="m">65536</span> bytes this time, <span class="m">65536</span> bytes in total
2015/11/17 14:57:33 write <span class="m">65536</span> bytes this time, <span class="m">131072</span> bytes in total
2015/11/17 14:57:33 write <span class="m">65536</span> bytes this time, <span class="m">196608</span> bytes in total
2015/11/17 14:57:33 write <span class="m">65536</span> bytes this time, <span class="m">262144</span> bytes in total
2015/11/17 14:57:33 write <span class="m">65536</span> bytes this time, <span class="m">327680</span> bytes in total
2015/11/17 14:57:33 write <span class="m">65536</span> bytes this time, <span class="m">393216</span> bytes in total
2015/11/17 14:57:33 write <span class="m">65536</span> bytes this time, <span class="m">458752</span> bytes in total
2015/11/17 14:57:33 write <span class="m">65536</span> bytes this time, <span class="m">524288</span> bytes in total
2015/11/17 14:57:33 write <span class="m">65536</span> bytes this time, <span class="m">589824</span> bytes in total
2015/11/17 14:57:33 write <span class="m">65536</span> bytes this time, <span class="m">655360</span> bytes in total

</code></pre></td></tr></table>
</div>
</div><p>在Darwin上，这个size大约在679468bytes。后续当server5每隔5s进行Read时，OS socket缓冲区腾出了空间，client5就又可以写入了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">$go</span> run server5.go
2015/11/17 15:07:01 accept a new connection
2015/11/17 15:07:16 start to <span class="nb">read</span> from conn
2015/11/17 15:07:16 <span class="nb">read</span> <span class="m">60000</span> bytes, content is
2015/11/17 15:07:21 start to <span class="nb">read</span> from conn
2015/11/17 15:07:21 <span class="nb">read</span> <span class="m">60000</span> bytes, content is
2015/11/17 15:07:26 start to <span class="nb">read</span> from conn
2015/11/17 15:07:26 <span class="nb">read</span> <span class="m">60000</span> bytes, content is
....

client端：

2015/11/17 15:07:01 write <span class="m">65536</span> bytes this time, <span class="m">720896</span> bytes in total
2015/11/17 15:07:06 write <span class="m">65536</span> bytes this time, <span class="m">786432</span> bytes in total
2015/11/17 15:07:16 write <span class="m">65536</span> bytes this time, <span class="m">851968</span> bytes in total
2015/11/17 15:07:16 write <span class="m">65536</span> bytes this time, <span class="m">917504</span> bytes in total
2015/11/17 15:07:27 write <span class="m">65536</span> bytes this time, <span class="m">983040</span> bytes in total
2015/11/17 15:07:27 write <span class="m">65536</span> bytes this time, <span class="m">1048576</span> bytes in total
.... ...

</code></pre></td></tr></table>
</div>
</div><h3 id="3写入部分数据">3、写入部分数据</h3>
<p>Write操作存在写入部分数据的情况，比如上面例子中，当client端输出日志停留在“write 65536 bytes this time, 655360 bytes in total”时，我们杀掉server5，这时我们会看到client5输出以下日志：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">...
2015/11/17 15:19:14 write <span class="m">65536</span> bytes this time, <span class="m">655360</span> bytes in total
2015/11/17 15:19:16 write <span class="m">24108</span> bytes, error:write tcp 127.0.0.1:62245-&gt;127.0.0.1:8888: write: broken pipe
2015/11/17 15:19:16 write <span class="m">679468</span> bytes in total
</code></pre></td></tr></table>
</div>
</div><p>显然Write并非在655360这个地方阻塞的，而是后续又写入24108后发生了阻塞，server端socket关闭后，我们看到Wrote返回er != nil且n = 24108，程序需要对这部分写入的24108字节做特定处理。</p>
<h3 id="4写入超时">4、写入超时</h3>
<p>如果非要给Write增加一个期限，那我们可以调用SetWriteDeadline方法。我们copy一份client5.go，形成client6.go，在client6.go的Write之前增加一行timeout设置代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">conn</span><span class="p">.</span><span class="nf">SetWriteDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Microsecond</span> <span class="o">*</span> <span class="mi">10</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>启动server6.go，启动client6.go，我们可以看到写入超时的情况下，Write的返回结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">$go</span> run client6.go
2015/11/17 15:26:34 begin dial...
2015/11/17 15:26:34 dial ok
2015/11/17 15:26:34 write <span class="m">65536</span> bytes this time, <span class="m">65536</span> bytes in total
... ...
2015/11/17 15:26:34 write <span class="m">65536</span> bytes this time, <span class="m">655360</span> bytes in total
2015/11/17 15:26:34 write <span class="m">24108</span> bytes, error:write tcp 127.0.0.1:62325-&gt;127.0.0.1:8888: i/o timeout
2015/11/17 15:26:34 write <span class="m">679468</span> bytes in total
</code></pre></td></tr></table>
</div>
</div><p>可以看到在写入超时时，依旧存在部分数据写入的情况。</p>
<p>综上例子，虽然Go给我们提供了阻塞I/O的便利，但在调用Read和Write时依旧要综合需要方法返回的n和err的结果，以做出正确处理。net.conn实现了io.Reader和io.Writer接口，因此可以试用一些wrapper包进行socket读写，比如bufio包下面的Writer和Reader、io/ioutil下的函数等。</p>
<h3 id="goroutine-safe">Goroutine safe</h3>
<p>基于goroutine的网络架构模型，存在在不同goroutine间共享conn的情况，那么conn的读写是否是goroutine safe的呢？在深入这个问题之前，我们先从应用意义上来看read操作和write操作的goroutine-safe必要性。</p>
<p>对于read操作而言，由于TCP是面向字节流，conn.Read无法正确区分数据的业务边界，因此多个goroutine对同一个conn进行read的意义不大，goroutine读到不完整的业务包反倒是增加了业务处理的难度。对与Write操作而言，倒是有多个goroutine并发写的情况。不过conn读写是否goroutine-safe的测试不是很好做，我们先深入一下runtime代码，先从理论上给这个问题定个性：</p>
<p>net.conn只是*netFD的wrapper结构，最终Write和Read都会落在其中的fd上：</p>
<pre><code>type conn struct {
    fd *netFD
}

</code></pre><p>netFD在不同平台上有着不同的实现，我们以net/fd_unix.go中的netFD为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Network file descriptor.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">netFD</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// locking/lifetime of sysfd + serialize access to Read and Write methods
</span><span class="c1"></span>    <span class="nx">fdmu</span> <span class="nx">fdMutex</span>

    <span class="c1">// immutable until Close
</span><span class="c1"></span>    <span class="nx">sysfd</span>       <span class="kt">int</span>
    <span class="nx">family</span>      <span class="kt">int</span>
    <span class="nx">sotype</span>      <span class="kt">int</span>
    <span class="nx">isConnected</span> <span class="kt">bool</span>
    <span class="nx">net</span>         <span class="kt">string</span>
    <span class="nx">laddr</span>       <span class="nx">Addr</span>
    <span class="nx">raddr</span>       <span class="nx">Addr</span>

    <span class="c1">// wait server
</span><span class="c1"></span>    <span class="nx">pd</span> <span class="nx">pollDesc</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>我们看到netFD中包含了一个runtime实现的fdMutex类型字段，从注释上来看，该fdMutex用来串行化对该netFD对应的sysfd的Write和Read操作。从这个注释上来看，所有对conn的Read和Write操作都是有fdMutex互斥的，从netFD的Read和Write方法的实现也证实了这一点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">fd</span> <span class="o">*</span><span class="nx">netFD</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fd</span><span class="p">.</span><span class="nf">readLock</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">fd</span><span class="p">.</span><span class="nf">readUnlock</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">pd</span><span class="p">.</span><span class="nf">PrepareRead</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">sysfd</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">n</span> <span class="p">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EAGAIN</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">pd</span><span class="p">.</span><span class="nf">WaitRead</span><span class="p">();</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                    <span class="k">continue</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">fd</span><span class="p">.</span><span class="nf">eofError</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">break</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">Errno</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">NewSyscallError</span><span class="p">(</span><span class="s">&#34;read&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">fd</span> <span class="o">*</span><span class="nx">netFD</span><span class="p">)</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">nn</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fd</span><span class="p">.</span><span class="nf">writeLock</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">fd</span><span class="p">.</span><span class="nf">writeUnlock</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">pd</span><span class="p">.</span><span class="nf">PrepareWrite</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">n</span> <span class="kt">int</span>
        <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">sysfd</span><span class="p">,</span> <span class="nx">p</span><span class="p">[</span><span class="nx">nn</span><span class="p">:])</span>
        <span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">nn</span> <span class="o">+=</span> <span class="nx">n</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">nn</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EAGAIN</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">pd</span><span class="p">.</span><span class="nf">WaitWrite</span><span class="p">();</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="k">continue</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">err</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">ErrUnexpectedEOF</span>
            <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">Errno</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">NewSyscallError</span><span class="p">(</span><span class="s">&#34;write&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">nn</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>每次Write操作都是受lock保护，直到此次数据全部write完。因此在应用层面，要想保证多个goroutine在一个conn上write操作的Safe，需要一次write完整写入一个“业务包”；一旦将业务包的写入拆分为多次write，那就无法保证某个Goroutine的某“业务包”数据在conn发送的连续性。</p>
<p>同时也可以看出即便是Read操作，也是lock保护的。多个Goroutine对同一conn的并发读不会出现读出内容重叠的情况，但内容断点是依 runtime调度来随机确定的。存在一个业务包数据，1/3内容被goroutine-1读走，另外2/3被另外一个goroutine-2读 走的情况。比如一个完整包：world，当goroutine的read slice size &lt; 5时，存在可能：一个goroutine读到 “worl”,另外一个goroutine读出”d”。</p>
<h2 id="四socket属性">四、Socket属性</h2>
<p>原生Socket API提供了丰富的sockopt设置接口，但Golang有自己的网络架构模型，golang提供的socket options接口也是基于上述模型的必要的属性设置。包括</p>
<ul>
<li>SetKeepAlive</li>
<li>SetKeepAlivePeriod</li>
<li>SetLinger</li>
<li>SetNoDelay （默认no delay）</li>
<li>SetWriteBuffer</li>
<li>SetReadBuffer</li>
</ul>
<p>不过上面的Method是TCPConn的，而不是Conn的，要使用上面的Method的，需要type assertion：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">tcpConn</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.(</span><span class="o">*</span><span class="nx">TCPConn</span><span class="p">)</span>
<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="c1">//error handle
</span><span class="c1"></span><span class="p">}</span>

<span class="nx">tcpConn</span><span class="p">.</span><span class="nf">SetNoDelay</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>对于listener socket, golang默认采用了 SO_REUSEADDR，这样当你重启 listener程序时，不会因为address in use的错误而启动失败。而listen backlog的默认值是通过获取系统的设置值得到的。不同系统不同：mac 128, linux 512等。</p>
<h2 id="五关闭连接">五、关闭连接</h2>
<p>和前面的方法相比，关闭连接算是最简单的操作了。由于socket是全双工的，client和server端在己方已关闭的socket和对方关闭的socket上操作的结果有不同。看下面例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go-tcpsock/conn_close/client1.go
</span><span class="c1"></span><span class="o">...</span> <span class="o">...</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;begin dial...&#34;</span><span class="p">)</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:8888&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;dial error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;close ok&#34;</span><span class="p">)</span>

    <span class="kd">var</span> <span class="nx">buf</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
    <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;read error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;read % bytes, content is %s\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">]))</span>
    <span class="p">}</span>

    <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;write error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;write % bytes, content is %s\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">]))</span>
    <span class="p">}</span>

    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//go-tcpsock/conn_close/server1.go
</span><span class="c1"></span><span class="o">...</span> <span class="o">...</span>
<span class="kd">func</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="c1">// read from the connection
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">buf</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;start to read from conn&#34;</span><span class="p">)</span>
    <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;conn read error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;read %d bytes, content is %s\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">]))</span>
    <span class="p">}</span>

    <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;conn write error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;write %d bytes, content is %s\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">]))</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="o">...</span> <span class="o">...</span>

</code></pre></td></tr></table>
</div>
</div><p>上述例子的执行结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">$go</span> run server1.go
2015/11/17 17:00:51 accept a new connection
2015/11/17 17:00:51 start to <span class="nb">read</span> from conn
2015/11/17 17:00:51 conn <span class="nb">read</span> error: EOF
2015/11/17 17:00:51 write <span class="m">10</span> bytes, content is

<span class="nv">$go</span> run client1.go
2015/11/17 17:00:51 begin dial...
2015/11/17 17:00:51 close ok
2015/11/17 17:00:51 <span class="nb">read</span> error: <span class="nb">read</span> tcp 127.0.0.1:64195-&gt;127.0.0.1:8888: use of closed network connection
2015/11/17 17:00:51 write error: write tcp 127.0.0.1:64195-&gt;127.0.0.1:8888: use of closed network connection
</code></pre></td></tr></table>
</div>
</div><p>从client1的结果来看，在己方已经关闭的socket上再进行read和write操作，会得到”use of closed network connection” error；
从server1的执行结果来看，在对方关闭的socket上执行read操作会得到EOF error，但write操作会成功，因为数据会成功写入己方的内核socket缓冲区中，即便最终发不到对方socket缓冲区了，因为己方socket并未关闭。因此当发现对方socket关闭后，己方应该正确合理处理自己的socket，再继续write已经无任何意义了。</p>
<h2 id="六小结">六、小结</h2>
<p>本文比较基础，但却很重要，毕竟golang是面向大规模服务后端的，对通信环节的细节的深入理解会大有裨益。另外Go的goroutine+阻塞通信的网络通信模型降低了开发者心智负担，简化了通信的复杂性，这点尤为重要。</p>
<p>本文代码实验环境：go 1.5.1 on Darwin amd64以及部分在ubuntu 14.04 amd64。</p>
<p>本文demo代码在<a href="https://github.com/bigwhite/experiments/tree/master/go-tcpsock">这里</a>可以找到。</p>
<p>© 2015, <a href="http://tonybai.com/">bigwhite</a>. 版权所有.</p>
]]></content><category scheme="https://yusank.github.io/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术"/><category scheme="https://yusank.github.io/tags/go/" term="go" label="go"/><category scheme="https://yusank.github.io/tags/tcp/" term="tcp" label="tcp"/><category scheme="https://yusank.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" term="网络编程" label="网络编程"/></entry><entry><title type="text">Docker 基础知识和基本操作</title><link rel="alternate" type="text/html" href="https://yusank.github.io/posts/docker/"/><id>https://yusank.github.io/posts/docker/</id><updated>2021-07-04T08:33:24+00:00</updated><published>2017-07-17T15:52:00+08:00</published><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><summary type="html">关于 容器、Docker 的基础知识、基础操作和常用的命令。 Docker 基础知识和使用 关于Docker 容器技术 对于容器，目前并没有一个……</summary><content type="html"><![CDATA[<p>关于 容器、Docker 的基础知识、基础操作和常用的命令。</p>
<h1 id="docker-基础知识和使用">Docker 基础知识和使用</h1>
<h2 id="关于docker">关于Docker</h2>
<h3 id="容器技术">容器技术</h3>
<p>对于容器，目前并没有一个严格的定义，但是普遍被认可的说法是，它首先必须是一个相对独立的环境，在这一点上有点类似虚拟机，但是没有虚拟机那么彻底。另外，在一个容器环境中，应该最小化其对外界的影响，比如不能在容器中吧host上的资源耗尽，这就是资源的控制。</p>
<p>容器技术之所以受欢迎，一个重要的原因是它已经集成到了 Linux 内核中，已经被当作 Linux 内核原生提供的特征。当然其他平台也有相应的容器技术，但是我们讨论的以及Docker涉及的都是指 Linux 平台上的容器技术。</p>
<p>一般来说，容器技术主要包括Namespace和Cgroup两个内核特征。</p>
<ul>
<li>Namespace 命名空间，它主要做的是访问隔离。其原理是对一类资源进行抽象，并将其封装在一起提供给容器使用，对于这类资源，因为每个容器都有自己的抽象，而他们彼此之间是不可见的，所以就做到访问隔离。</li>
<li>Cgroup是 control group 的简称，又称为控制组，它主要是控制资源控制。其原理是将一组进程放在一个控制组里，通过给这个控制组分配指定的可用资源，达到控制这一组进程可用资源的目的。</li>
</ul>
<p>容器最核心技术是 Namespace+Cgroup，但是光有这两个抽象的技术概念是无法组成一个完整的容器的。
对于 linux 容器的最小组成，是由一下四个部分构成：</p>
<ul>
<li>Cgroup： 资源控制。</li>
<li>Namespace： 访问隔离。</li>
<li>rootfs： 系统文件隔离。</li>
<li>容器引擎： 生命周期控制。</li>
</ul>
<h3 id="容器的创建原理">容器的创建原理</h3>
<p>代码一</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">pid</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">clone_arg</span><span class="p">);</span>

<span class="p">(</span><span class="nl">flags</span><span class="p">:</span> <span class="n">CLONE_NEWPID</span> <span class="o">|</span> <span class="n">CLONE_NEWNS</span> <span class="o">|</span>
     <span class="n">CLONE_NEWUSER</span> <span class="o">|</span> <span class="n">CLONE_NEWNET</span> <span class="o">|</span>
     <span class="n">CLONE_NEWIPC</span> <span class="o">|</span> <span class="n">CLONE_NEWUTS</span> <span class="o">|</span>
        <span class="p">...)</span>

</code></pre></td></tr></table>
</div>
</div><ul>
<li>对于以上代码，通过clone系统调用，并传入各个Namespace对应的clone flag，创建了一个新的子进程，该进程拥有自己的Namespace。从上面的代码可以看出，该进程拥有自己的pid,mount,user,net,ipc,uts namespace 。</li>
</ul>
<p>代码二：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">echo</span> <span class="nv">$pid</span> &gt; /sys/fs/cgroup/cpu/tasks
<span class="nb">echo</span> <span class="nv">$pid</span> &gt; /sys/fs/cgroup/cpuset/tasks
<span class="nb">echo</span> <span class="nv">$pid</span> &gt; /sys/fs/cgroup/blkio/tasks
<span class="nb">echo</span> <span class="nv">$pid</span> &gt; /sys/fs/cgroup/memory/tasks
<span class="nb">echo</span> <span class="nv">$pid</span> &gt; /sys/fs/cgroup/devices/tasks
<span class="nb">echo</span> <span class="nv">$pid</span> &gt; /sys/fs/cgroup/freezer/tasks
</code></pre></td></tr></table>
</div>
</div><ul>
<li>对于代码二，将代码一中的pid写入各个Cgroup子系统中，这样该进程就可以受到相应Cgroup子系统的控制。</li>
</ul>
<p>代码三：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">fun <span class="o">()</span>
<span class="o">{</span>
    ...
    
    pivot_root<span class="o">(</span><span class="s2">&#34;path_of_rootfs/&#34;</span>, path<span class="o">)</span><span class="p">;</span>
    ...
    
    exec<span class="o">(</span><span class="s2">&#34;/bin/bash&#34;</span><span class="o">)</span><span class="p">;</span>
    ...
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>对于代码三，该fun函数由上面生成的新进程执行，在fun函数中，通过<code>pivot_root</code>系统调用，使进程进入新的<code>rootfs</code>，之后通过<code>exec</code>系统调用，在新的<code>Namespace</code>,<code>Cgroup</code>,<code>rootfs</code>中执行<code>&quot;/bin/bash&quot;</code>程序。</li>
</ul>
<p>通过以上操作，成功在一个“容器”中运行了一个bash程序。对于Cgroup和Namespace的技术细节，我们下一节详细描述</p>
<h3 id="cgroup">Cgroup</h3>
<h4 id="cgroup-是什么">Cgroup 是什么</h4>
<p>Cgroup是control group 的简写，属于 Linux 内核提供的一个特性，用于限制和隔离一组进程对系统资源的使用。这些资源主要包括 CPU， 内存， block I/O（数据块 I/O） 和网络宽带。
Cgroup 从 2.6.24版本进入内核主线，目前各大发行版linux都默认打开了 Cgroup 特性</p>
<p>从实现的角度来看，Cgroup 实现了一个通用的进程分组的框架，而不同资源的具体管理则是由各个 Cgroup 子系统实现的。截止内核4.1版本，Cgroup 中实现的子系统的及其作用如下：</p>
<ul>
<li>devices： 设备权限控制</li>
<li>cpuset： 分配指定的CPU和内存节点</li>
<li>cpu： 控制 CPU 占用率</li>
<li>cpuacct： 统计 CPU 使用情况</li>
<li>memory： 限制内存的使用上限</li>
<li>freezer： 冻结（暂停）Cgroup 中的进程</li>
<li>net_cls： 配合tc（traffic controller）限制网络宽带</li>
<li>net_prio： 设置进程的网络流量优先级</li>
<li>huge_tlb： 限制HugeTLB（块表缓冲区）的使用</li>
<li>perf_event： 允许 Perf 工具基于Cgroup分组做性能测试</li>
</ul>
<h3 id="namespace">Namespace</h3>
<h4 id="namespace-是什么">Namespace 是什么</h4>
<p>Namespace 是将内核的全局资源做封装，使得每个Namespace都有有一份独立的资源，因此不同的进程各自的 Namespace 内对同一个资源的使用不会互相干扰。
举个例子，执行 sethostname 这个系统调用时，可以改变系统的主机名，这个主机名就是一个内核的全局资源。内核通过实现 UTS Namespace，可以将不同的进程分隔在不同的 UTS Namespace 中，在某个 Namespace 修改主机名时，另一个 Namespace 的主机名还是保持不变。</p>
<p>目前 Linux 内核总共实现了6种 Namespace：</p>
<ul>
<li>IPC： 隔离 System V IPC 和 POSIX 消息队列</li>
<li>Network： 隔离网络资源</li>
<li>Mount： 隔离文件系统挂载点</li>
<li>PID： 隔离进程 ID</li>
<li>UTS： 隔离主机名和域名</li>
<li>User： 隔离用户 ID 和 组 ID</li>
</ul>
<p>Namespace 和 Cgroup 的使用是灵活的，同时也有不少需要注意的地方，因此直接操作 Namespace 和 Cgroup 并不是很容易。正是因为这些原因，Docker 通过 Libcontainer 来处理这些底层的事情。这样一来，Docker 只需简单地调用 Libcontainer 的 API ，就能将完整的容器搭建起来。而作为 Docker 的用户，就更不用操心这些事情了。</p>
<h3 id="容器造就-docker">容器造就 Docker</h3>
<p>关于容器是否是 Docker 的技术核心技术，业界一直存在着争议。</p>
<p>在理解了容器，理解了容器的核心技术 Cgroup 和 Namespace，理解了容器技术如何巧妙且轻量地实现“容器”本身的资源控制和访问隔离之后，可以看到 Docker 和容器是一种完美的融合和辅助相成的关系，它们不是唯一的搭配，但一定是最完美的结合（目前来说）。与其说是容器造就了 Docker ， 不如说是它们造就了彼此，容器技术让 Docker 得到更多的应用和推广，Docker 也使得容器技术被更多人熟知。</p>
<h2 id="基本操作">基本操作</h2>
<h3 id="启动容器">启动容器</h3>
<h4 id="新建并启动">新建并启动</h4>
<p>所需的命令是 <code>docker run</code></p>
<p>例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker run ubuntu:14.04 /bin/echo <span class="s1">&#39;hello, worl&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>容器执行后面的命令直接就会终止 .</p>
<p>下面的命令会启动容器并起一个 bash 终端,允许用户进行交互</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker run -t -i ubuntu:14.04 /bin/bash
</code></pre></td></tr></table>
</div>
</div><p>其中 <code>-t</code>  让 Docker 分配一个伪终端 (pseudo-tty) 并绑定到容器的标准输入上, <code>-i</code> 则让容器的标准输入保持打开 .</p>
<p>利用 docker run 来创建容器是, Docker 在后台运行的标准操作包括:</p>
<ul>
<li>检查本地是否存在指定的镜像,不存在就从共有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统并在只读的镜像层外面挂载一层可读写层</li>
<li>在宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器终止</li>
</ul>
<h4 id="启动已终止容器">启动已终止容器</h4>
<p>可以利用 <code>docker start</code> 命令,直接将一个已经终止的容器启动运行 .</p>
<p>可以通过 <code>docker ps -a</code> 查看所有的容器和其状态</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS                     PORTS                    NAMES
aada74689bf7        cockroachdb/cockroach   <span class="s2">&#34;/cockroach/cockro...&#34;</span>   <span class="m">3</span> weeks ago         Exited <span class="o">(</span>137<span class="o">)</span> <span class="m">3</span> weeks ago                            roach_master
2e9eb6cf3f66        owncloud                <span class="s2">&#34;/entrypoint.sh ap...&#34;</span>   <span class="m">3</span> weeks ago         Up <span class="m">3</span> weeks                 0.0.0.0:80-&gt;80/tcp       owncloud
91290c737c73        postgres                <span class="s2">&#34;docker-entrypoint...&#34;</span>   <span class="m">3</span> weeks ago         Up <span class="m">3</span> weeks                 5432/tcp                 owncloud-postgres
8f546ec65e61        mysql                   <span class="s2">&#34;docker-entrypoint...&#34;</span>   <span class="m">3</span> weeks ago         Up <span class="m">3</span> weeks                 0.0.0.0:3306-&gt;3306/tcp   mysql
</code></pre></td></tr></table>
</div>
</div><p>不难发现 name 为 roch_master 的容器已经终止了,想重新启动它,可以执行下面的命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker start aada74689bf7
</code></pre></td></tr></table>
</div>
</div><p>参数为容器的 id .</p>
<h3 id="后台-background-运行">后台( background )运行</h3>
<p>在很多时候,我们需要让 docker 在后台运行而并不是把执行结果直接输出出来.</p>
<p>这个时候我们可以添加 <code>-d</code> 参数来实现</p>
<p>如果使用 <code>-d</code> 参数运行容器</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker run -d mysql:5.7.17
77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a
</code></pre></td></tr></table>
</div>
</div><p>只会输出运行的容器 id, 而输出结果可以用 docker logs 查看 .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker logs <span class="o">[</span>container ID or NAMES<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="终止容器">终止容器</h3>
<p>可以使用 <code>docker stop</code>  来终止正在运行的容器 .</p>
<p>此外,当 Docker 容器中指定的应用终结时, 容器也自动终止 . 例如运行一个容器时,指定了一个终端后,当退出终端的时候,所创建的容器也会立刻终止 .</p>
<p>终止状态的容器, 可以通过 <code>docker start</code> 来重新启动 .</p>
<p>此外,<code>docker restart</code> 命令会将一个运行态的容器终止,然后重新启动它 .</p>
<h3 id="进入容器">进入容器</h3>
<p>在使用 <code>-d</code> 参数时, docker 容器会在后台运行. 有些时候需要进入容器,如运行数据库时,需要进入增删改查库里的内容. 进入容器有很多种办法.</p>
<h4 id="attach-命令">attach 命令</h4>
<p><code>docker attach</code> 是 Docker 自带的命令,用法</p>
<p>但是使用 <code>attach</code> 命令有个缺陷,即多个窗口同时用 attach 命令到同一个容器的时候,所有的窗口都是同步显示的,如果其中一个窗口阻塞的时候,其他窗口也无法使用 .</p>
<h4 id="nsenter-命令">nsenter 命令</h4>
<p>这个工具需要用如下命令安装</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker run --rm -v /usr/local/bin:/target jpetazzo/nsenter
</code></pre></td></tr></table>
</div>
</div><p>使用方法也比较简单,首先是你要进入的容器的 ID</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nv">PID</span><span class="o">=</span><span class="k">$(</span>docker inspect --format <span class="o">{{</span>.State.Pid<span class="o">}}</span> &lt;container ID or NAMES&gt;<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>然后通过这个 PID 进入容器</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ nsenter --target <span class="nv">$PID</span> --mount --uts --ipc --net --pid
</code></pre></td></tr></table>
</div>
</div><p>如果无法通过上述的命令连接到容器,有可能是因为宿主的默认 shell 在容器中并不存在,比如 zsh, 可以使用如下命令显示地使用 bash .</p>
<h4 id="exec-命令">exec 命令</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">$docker</span> <span class="nb">exec</span> -it <span class="o">[</span>container ID or NAMES<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p><code>-i</code> <code>-t</code> 前面说过为了标准输入输出保持打开 .</p>
<h3 id="导出和导入容器">导出和导入容器</h3>
<h4 id="导出容器">导出容器</h4>
<p>如果要导出本地某个容器,可以使用 <code>docker export</code> 命令 .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker <span class="nb">export</span> <span class="o">[</span>container ID or NAMES<span class="o">]</span> &gt; target.tar
</code></pre></td></tr></table>
</div>
</div><p>这样将导出容器快照到本地文件 .</p>
<h4 id="导入容器快照">导入容器快照</h4>
<p>可以使用 <code>docker import</code> 从容器快照文件导入镜像,</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ cat target.tar <span class="p">|</span> docker import - test/mysql:v1.0
$ sudo docker images
REPOSITORY  TAG  IMAGE ID 		CREATED 			VIRTUAL SIZE
test/ubuntu v1.0 9d37a6082e97 	About a minute ago 	171.3 MB
</code></pre></td></tr></table>
</div>
</div><p>此外,还可以通过指定 URL 或者某个目录来导入</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker import http://example.com/exampleimage.tgz example/imagerepo
</code></pre></td></tr></table>
</div>
</div><p>*注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库,也可以使用 docker import 来导入一个容器快照到本地镜像库 .这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态）,而镜像存储文件将保存完整记录,体积也要大 .此外,从容器快照文件导入时可以重新指定标签等元数据信息 .</p>
<h3 id="删除容器">删除容器</h3>
<h4 id="单独删除">单独删除</h4>
<p>可以使用 <code>docker rm</code> 来删除一个处于终止状态的容器 .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker rm <span class="o">[</span>container ID or NAMES<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>如果要删除一个运行中的容器,可以添加 <code>-f</code> 参数 .Docker 会发送 <code>SIGKILL</code> 信号给容器 .</p>
<h4 id="清理所有处于终止状态的容器">清理所有处于终止状态的容器</h4>
<p>用  <code>docker ps -a</code>  命令可以查看所有已创建的包括终止状态的容器,如果想批量删除多个容器的话(当然是终止状态的容器) ,可以用这个命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker rm <span class="k">$(</span>docker ps -a -q<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>*注意：这个命令其实会试图删除所有的包括还在运行中的容器,不过就像上面提过的 docker rm 默认并不会删除运行中的容器 .</p>
<h2 id="访问仓库">访问仓库</h2>
<p>仓库（Repository）是集中存放镜像的地方 .</p>
<p>一个容易混淆的概念是注册服务器（Registry） .实际上注册服务器是管理仓库的具体服务器,每个服务器上可以有多个仓库,而每个仓库下面有多个镜像 .从这方面来说,仓库可以被认为是一个具体的项目或目录 .例如对于仓库地址dl.dockerpool.com/ubuntu 来说, dl.dockerpool.com 是注册服务器地址, ubuntu 是仓库名 .</p>
<p>大部分时候,并不需要严格区分这两者的概念 .</p>
<h3 id="docker-hub">Docker Hub</h3>
<p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/explore/">Docker Hub</a>,   但是开始把阵地移到 <a href="https://store.docker.com/">Docker Store</a> 这个平台上,其上能找到几乎所有的能想得到的容器, 不可小觑 .</p>
<h4 id="登录">登录</h4>
<p>可以通过执行 docker login 命令来输入用户名、密码和邮箱来完成注册和登录 . 注册成功后,本地用户目录的.dockercfg 中将保存用户的认证信息 .</p>
<h4 id="基本操作-1">基本操作</h4>
<p>用户无需登录即可通过 <code>docker search</code> 命令来查找官方仓库中的镜像, 并利用 <code>docker pull</code> 命令来将它下载到本地 .</p>
<p>以搜索 mongo 为关键字搜索:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker search mongo
NAME                           DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mongo                          MongoDB document databases provide high av...   <span class="m">3427</span>      <span class="o">[</span>OK<span class="o">]</span>
mongo-express                  Web-based MongoDB admin interface, written...   <span class="m">168</span>       <span class="o">[</span>OK<span class="o">]</span>
mvertes/alpine-mongo           light MongoDB container                         <span class="m">51</span>                   			<span class="o">[</span>OK<span class="o">]</span>
mongoclient/mongoclient        Official docker image <span class="k">for</span> Mongoclient, fea...   <span class="m">29</span>                   			<span class="o">[</span>OK<span class="o">]</span>
torusware/speedus-mongo        Always updated official MongoDB docker ima...   <span class="m">9</span>                    			<span class="o">[</span>OK<span class="o">]</span>
mongooseim/mongooseim-docker   MongooseIM server the latest stable version     <span class="m">9</span>                    			<span class="o">[</span>OK<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>​搜索结果可以看到很多包含关键字的镜像,其中包括镜像名字、描述、星数（表示该镜像的受欢迎程度）、是否官方创建、是否自动创建 . 官方的镜像说明是官方项目组创建和维护的,automated 资源允许用户验证镜像的来源和内容 .</p>
<p>​根据是否为官方提供, 镜像资源可分为两类 . 一类是累类似 mongo这样的基础镜像 . 这些镜像由 Docker 的用户创建、验证、支持、提供  . 这样的镜像往往是使用单个单词作为名字  .</p>
<p>另一种类型,比如<code>mvertes/alpine-mongo</code> 镜像,它是由 Docker 的用户创建并维护的,往往带有用户名称前缀  . 可以通过前缀 <code>user_name/</code> 来指定使用某个用户提供的镜像  .</p>
<p>另外,在查找的时候通过 <code>-s N</code> 参数可以指定仅显示星数为 N 以上的镜像 （新版本的 Docker 推荐使用 <code>--flter=stars=N</code> 参数） .</p>
<p>下载镜像到本地</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo docker pull centos
Pulling repository centos
0b443ba03958: Download <span class="nb">complete</span>
539c0211cd76: Download <span class="nb">complete</span>
511136ea3c5a: Download <span class="nb">complete</span>
7064731afe90: Download <span class="nb">complete</span>
</code></pre></td></tr></table>
</div>
</div><p>用户也可以登录之后通过 <code>docker push</code> 命令来讲镜像推送到 Docker Hub  .</p>
<h4 id="自动创建">自动创建</h4>
<p>​自动创建（automated builds）功能对于需要经常升级镜像内程序来说,十分方便 .有时候,用户创建了镜像安装了某个软件,如果软件发布新版本则需要手动更新镜像 . .而自动创建允许用户通过 Docker Hub 指定跟踪一个目标网站（目前支持 GitHub或 BitBucket）上的项目,一旦项目发生新的提交,则自动执行创建 .</p>
<p>要配置自动创建,包括如下的步骤：</p>
<ul>
<li>创建并登录 Docker Hub,以及目标网站；</li>
<li>在目标网站中连接帐户到 Docker Hub；</li>
<li>在 Docker Hub 中 配置一个自动创建；</li>
<li>选取一个目标网站中的项目（需要含 Dockerfile）和分支；</li>
<li>指定 Dockerfile 的位置,并提交创建 .</li>
</ul>
<p>之后,可以 在Docker Hub 的 自动创建页面 中跟踪每次创建的状态 .</p>
<h3 id="私有仓库">私有仓库</h3>
<p>有时候使用 Docker Hub 这样的公共仓库由于网络等原因可能不方便,用户可以创建一个本地仓库供私人使用 .</p>
<p>需要用到 <code>docker-registry</code> 工具 .</p>
<p><code>docker-registry</code> 是官方提供的工具,可以用于构建私有的镜像仓库  .</p>
<h4 id="安装运行-docker-registry">安装运行 docker-registry</h4>
<h5 id="容器运行">容器运行</h5>
<p>在安装了 Docker 后,可以通过获取官方 registry 镜像来运行  .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker run -d -p 5000:5000 registry
</code></pre></td></tr></table>
</div>
</div><p>这将使用官方的 registry 镜像来启动本地的私有仓库 .用户可以通过制定参数来配置私有仓库位置,例如配置镜像存储到 Amazon S3 服务  .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo docker run <span class="se">\
</span><span class="se"></span>-e <span class="nv">SETTINGS_FLAVOR</span><span class="o">=</span>s3 <span class="se">\
</span><span class="se"></span>-e <span class="nv">AWS_BUCKET</span><span class="o">=</span>acme-docker <span class="se">\
</span><span class="se"></span>-e <span class="nv">STORAGE_PATH</span><span class="o">=</span>/registry <span class="se">\
</span><span class="se"></span>-e <span class="nv">AWS_KEY</span><span class="o">=</span>AKIAHSHB43HS3J92MXZ <span class="se">\
</span><span class="se"></span>-e <span class="nv">AWS_SECRET</span><span class="o">=</span>xdDowwlK7TJajV1Y7EoOZrmuPEJlHYcNP2k4j49T
<span class="se">\
</span><span class="se"></span>-e <span class="nv">SEARCH_BACKEND</span><span class="o">=</span>sqlalchemy <span class="se">\
</span><span class="se"></span>-p 5000:5000 <span class="se">\
</span><span class="se"></span>registry
</code></pre></td></tr></table>
</div>
</div><p>此外,还可以指定本地路径（如<code>/home/user/registry-conf</code> ）下的配置文件  .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo docker run -d -p 5000:5000 -v /home/user/registry-conf:/r
egistry-conf -e <span class="nv">DOCKER_REGISTRY_CONFIG</span><span class="o">=</span>/registry-conf/config.yml
registry
</code></pre></td></tr></table>
</div>
</div><p>默认情况下,仓库会被创建在容器的 <code>/var/lib/registry</code> 下 .可以通过 <code>-v</code>  参数来将镜像文件存放在本地的指定路径  . 例如下面的例子将上传的镜像放到 <code>/opt/data/registy</code> 目录  .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo docker run -d -p 5000:5000 -v /opt/data/registry:/var/lib
/registry registry
</code></pre></td></tr></table>
</div>
</div><h4 id="本地安装">本地安装</h4>
<p>对于 Ubuntu 或 CentOS 等发行版,可以直接安装  .</p>
<ul>
<li>Ubuntu</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo apt-get install -y build-essential python-dev libevent-dev python-pip liblzma-dev
$ sudo pip install docker-registry
</code></pre></td></tr></table>
</div>
</div><ul>
<li>CentOS</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo yum install -y python-devel libevent-devel python-pip gcc xz-devel
$ sudo python-pip install docker-registry
</code></pre></td></tr></table>
</div>
</div><p>也可以从 docker-registry 项目下载源码进行安装  .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo apt-get install build-essential python-dev libevent-dev python-pip libssl-dev liblzma-dev libffi-dev
$ git clone https://github.com/docker/docker-registry.git
$ <span class="nb">cd</span> docker-registry
$ sudo python setup.py install
</code></pre></td></tr></table>
</div>
</div><p>然后修改配置文件,主要修改 dev 模板段的 <code>storage_path</code> 到本地的存储仓库的路径  .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ cp config/config_sample.yml config/config.yml
</code></pre></td></tr></table>
</div>
</div><p>之后启动 web 服务  .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo gunicorn -c contrib/gunicorn.py docker_registry.wsgi:application
</code></pre></td></tr></table>
</div>
</div><p>或者</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo gunicorn --access-logfile - --error-logfile - -k gevent -b 0.0.0.0:5000 -w <span class="m">4</span> --max-requests <span class="m">100</span> docker_registry.wsgi:application
</code></pre></td></tr></table>
</div>
</div><p>此时使用 crul 访问本地的 5000 端口,看到输出 docker-registry 的版本信息说明运行成功  .</p>
<p>*注 ： <code>config/config_sample.yml</code> 文件时示例配置文件</p>
<h4 id="在私有仓库上传下载搜索镜像">在私有仓库上传、下载、搜索镜像</h4>
<p>创建好私有仓库之后,就可以使用 <code>docker tag</code> 来标记一个镜像,然后推送它到仓库,别的机器上就可以下载了 .如 私有仓库地址为 <code>1192.168.7.26:5000</code></p>
<p>先在本机上查看已有的镜像  .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker images
REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE
node                    latest              f93ba6280cbd        <span class="m">3</span> weeks ago         667MB
cockroachdb/cockroach   latest              404f7ee26d38        <span class="m">4</span> weeks ago         163MB
postgres                latest              ca3a55649cfc        <span class="m">7</span> weeks ago         269MB
tomcat                  latest              0785a1d16826        <span class="m">7</span> weeks ago         367MB
owncloud                latest              2327c8d59618        <span class="m">8</span> weeks ago         572MB
mysql                   latest              e799c7f9ae9c        <span class="m">2</span> months ago        407MB
</code></pre></td></tr></table>
</div>
</div><p>使用 <code>docker tag</code> 将 <code>tomcat</code>  这个镜像标记为 <code>192.168.7.26：5000/test</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@vultr ~<span class="o">]</span><span class="c1"># docker tag tomcat 192.168.7.26:5000/test</span>
<span class="o">[</span>root@vultr ~<span class="o">]</span><span class="c1"># docker images</span>
REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE
node                     latest              f93ba6280cbd        <span class="m">3</span> weeks ago         667MB
cockroachdb/cockroach    latest              404f7ee26d38        <span class="m">4</span> weeks ago         163MB
postgres                 latest              ca3a55649cfc        <span class="m">7</span> weeks ago         269MB
192.168.7.26:5000/test   latest              0785a1d16826        <span class="m">7</span> weeks ago         367MB
tomcat                   latest              0785a1d16826        <span class="m">7</span> weeks ago         367MB
owncloud                 latest              2327c8d59618        <span class="m">8</span> weeks ago         572MB
mysql                    latest              e799c7f9ae9c        <span class="m">2</span> months ago        407MB
</code></pre></td></tr></table>
</div>
</div><p>用 <code>docker push</code>  上传标记的镜像  .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker push 192.168.7.26:5000/test
The push refers to a repository <span class="o">[</span>192.168.7.26:5000/test<span class="o">]</span> <span class="o">(</span>len: 1<span class="o">)</span>
Sending image list
Pushing repository 192.168.7.26:5000/test <span class="o">(</span><span class="m">1</span> tags<span class="o">)</span>
Image 511136ea3c5a already pushed, skipping
Image 9bad880da3d2 already pushed, skipping
Image 25f11f5fb0cb already pushed, skipping
Image ebc34468f71d already pushed, skipping
Image 2318d26665ef already pushed, skipping
Image ba5877dc9bec already pushed, skipping
Pushing tag <span class="k">for</span> rev <span class="o">[</span>ba5877dc9bec<span class="o">]</span> on <span class="o">{</span>http://192.168.7.26:5000/
v1/repositories/test/tags/latest<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>用 <code>curl</code> 查看仓库中的镜像</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">curl http://192.168.7.26:5000/v1/search
<span class="o">{</span><span class="s2">&#34;num_results&#34;</span>: 7, <span class="s2">&#34;query&#34;</span>: <span class="s2">&#34;&#34;</span>, <span class="s2">&#34;results&#34;</span>: <span class="o">[{</span><span class="s2">&#34;description&#34;</span>: <span class="s2">&#34;&#34;</span>,<span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;library/miaxis_j2ee&#34;</span><span class="o">}</span>, <span class="o">{</span><span class="s2">&#34;description&#34;</span>: <span class="s2">&#34;&#34;</span>, <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;library/tomcat&#34;</span><span class="o">}</span>, <span class="o">{</span><span class="s2">&#34;description&#34;</span>: <span class="s2">&#34;&#34;</span>, <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;library/ubuntu&#34;</span><span class="o">}</span>, <span class="o">{</span><span class="s2">&#34;description&#34;</span>: <span class="s2">&#34;&#34;</span>, <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;library/ubuntu_office&#34;</span><span class="o">}</span>, <span class="o">{</span><span class="s2">&#34;description&#34;</span>: <span class="s2">&#34;&#34;</span>, <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;library/desktop_ubu&#34;</span><span class="o">}</span>, <span class="o">{</span><span class="s2">&#34;description&#34;</span>: <span class="s2">&#34;&#34;</span>, <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;dockerfile/ubuntu&#34;</span><span class="o">}</span>, <span class="o">{</span><span class="s2">&#34;description&#34;</span>: <span class="s2">&#34;&#34;</span>, <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;library/test&#34;</span><span class="o">}]}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里可以看到 <code>{&quot;description&quot;: &quot;&quot;, &quot;name&quot;: &quot;library/test&quot;}</code> ,表面镜像已经上传成功了  .</p>
<p>下载可以用另一台机器去下载这个镜像  .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker pull 192.168.7.26:5000/test
Pulling repository 192.168.7.26:5000/test
ba5877dc9bec: Download <span class="nb">complete</span>
511136ea3c5a: Download <span class="nb">complete</span>
9bad880da3d2: Download <span class="nb">complete</span>
25f11f5fb0cb: Download <span class="nb">complete</span>
ebc34468f71d: Download <span class="nb">complete</span>
2318d26665ef: Download <span class="nb">complete</span>
$ docker images
REPOSITORY 		TAG 		IMAGE ID
CREATED 		VIRTUAL SIZE
192.168.7.26:5000/test latest ba5877dc9bec 
<span class="m">6</span> weeks ago 		192.7 MB
</code></pre></td></tr></table>
</div>
</div><h3 id="仓库配置文件">仓库配置文件</h3>
<p>Docker 的 registry 利用配置文件提供 了一些仓库的模板（flavor）,用户可以直接使用它们来进行开发或身产环境  .</p>
<h4 id="模板">模板</h4>
<p>在 <code>config_sample.yml</code> 文件中,可以看到一些现成的模板段：</p>
<ul>
<li><code>common</code> ：基础配置</li>
<li><code>local</code> ：存储数据到本地文件系统</li>
<li><code>s3</code> ：存储数据到 AWS S3 中</li>
<li><code>dev</code> ：使用 local 模板的基本配置</li>
<li><code>test</code> ：单元测试使用</li>
<li><code>prod</code> ：生产环境配置（基本上跟s3配置类似）</li>
<li><code>gcs</code> ：存储数据到 Google 的云存储</li>
<li><code>swift</code> ：存储数据到 OpenStack Swift 服务</li>
<li><code>glance</code> ：存储数据到 OpenStack Glance 服务,本地文件系统为后备</li>
<li><code>glance-swift </code>：存储数据到 OpenStack Glance 服务,Swift 为后备</li>
<li><code>elliptics</code> ：存储数据到 Elliptics key/value 存储</li>
</ul>
<p>用户可以添加自定义的模板段  .</p>
<p>默认情况下使用的模板是 <code>dev</code> ,要是使用某个模板作为默认值,可以添加 <code>SETTING-FLAVOR</code> 到环境变量中去,</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">export</span> <span class="nv">SETTING_FLAVOR</span><span class="o">=</span>dev
</code></pre></td></tr></table>
</div>
</div><p>另外,配置文件中支持从环境变量中加载,语法格式为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">_env:VARIABLENAME<span class="o">[</span>:DEFAULT<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="示例配置">示例配置</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">common:
loglevel: info
search_backend: <span class="s2">&#34;_env:SEARCH_BACKEND:&#34;</span>
sqlalchemy_index_database:
<span class="s2">&#34;_env:SQLALCHEMY_INDEX_DATABASE:sqlite:////tmp/docker-re
</span><span class="s2">gistry.db&#34;</span>
prod:
loglevel: warn
storage: s3
s3_access_key: _env:AWS_S3_ACCESS_KEY
s3_secret_key: _env:AWS_S3_SECRET_KEY
s3_bucket: _env:AWS_S3_BUCKET
boto_bucket: _env:AWS_S3_BUCKET
storage_path: /srv/docker
smtp_host: localhost
from_addr: docker@myself.com
to_addr: my@myself.com
dev:
loglevel: debug
storage: <span class="nb">local</span>
storage_path: /home/myself/docker
test:
storage: <span class="nb">local</span>
storage_path: /tmp/tmpdockertmp
</code></pre></td></tr></table>
</div>
</div><h2 id="docker-数据管理">Docker 数据管理</h2>
<p>在容器管理中数据主要有两种方式：</p>
<ul>
<li>数据卷 （Data volumes）</li>
<li>数据卷容器 （Data volume containers）</li>
</ul>
<h3 id="数据卷">数据卷</h3>
<p>数据卷是一个可提供一个或多个容器使用的特殊目录,它绕过 UFS, 可以提供很多有用的特征：</p>
<ul>
<li>数据卷可以再荣期间共享和重用</li>
<li>对数据卷的修改立马生效</li>
<li>对数据及的更新,不会影响镜像</li>
<li>数据卷默认会一直存在,即使容器被删除</li>
</ul>
<p><em>注：数据卷的使用,类似于Linux 下对目录或文件进行 mount, 镜像中的被指定为挂载点的目录中的文件会隐藏掉,能显示看的是挂载的数据卷</em></p>
<h4 id="创建一个数据卷">创建一个数据卷</h4>
<p>​在使用 <code>docker run </code> 命令的时候,使用 <code>-v</code> 参数来创建一个数据卷并挂载到容器里 .在一次 run 中可以挂载多个数据卷  .</p>
<p>下面创建一个名为 web 的容器,并加载一个数据卷到容器的 <code>/webapp</code> 目录  .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker run -d -p --name web -v /webapp training/webapp python app.py
</code></pre></td></tr></table>
</div>
</div><p><em>注：也可以在 Docker 中使用 <code>volume</code> 来添加一个或多个新的卷到有该镜像创建的任意容器  .</em></p>
<h4 id="删除数据卷">删除数据卷</h4>
<p>数据卷是被设计用来持久化数据的,它的生命周期独立于容器,Docker 不会在容器被删除后自动删除数据卷,并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷 .日光需要在删除容器的同时移除数据卷,可以再删除容器的时候使用 <code>docker rm -v</code> 这个命令 .</p>
<h4 id="挂载一个主句目录作为数据卷">挂载一个主句目录作为数据卷</h4>
<p>使用 <code>-v</code> 参数也可以指定挂载一个本地主机的目录到容器中去  .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py
</code></pre></td></tr></table>
</div>
</div><p>​	上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/opt/webapp</code> 目录 .这个功能在进行测试的时候十分方便,比如用户可以放置一些程序到本地目录中,来查看容器是否正常工作 .本地目录的路径必须是绝对路径,如果目录不存在 Docker会自动为你创建它 .</p>
<p><em>注：Dockerfile 中不支持这种用法,因为 Dockerfile 是为了移植和分享用的  . 然而,不同的操作系统的路径格式不一样,所以目前还不支持</em></p>
<p>Docker 挂载数据卷的默认权限是读写, 用户也可以通过 <code>:ro</code> 指定为只读</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py
</code></pre></td></tr></table>
</div>
</div><p>加了 <code>:ro</code> 之后,就挂载为只读了 .</p>
<h4 id="查看数据卷的具体信息">查看数据卷的具体信息</h4>
<p>在主机里使用以下命令可以查看指定容器的信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker inspect web
...
</code></pre></td></tr></table>
</div>
</div><p>在输出的内容中找到其中和数据卷相关的部分,可以看到所有的数据卷都是创建在主句的 <code>/var/lib/docker/volumes/</code> 下面的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="s2">&#34;Volumes&#34;</span>: <span class="o">{</span>
<span class="s2">&#34;/webapp&#34;</span>: <span class="s2">&#34;/var/lib/docker/volumes/fac362...80535&#34;</span>
<span class="o">}</span>,
<span class="s2">&#34;VolumesRW&#34;</span>: <span class="o">{</span>
<span class="s2">&#34;/webapp&#34;</span>: <span class="nb">true</span>
<span class="o">}</span>
...
</code></pre></td></tr></table>
</div>
</div><p><em>注：从 Docker 1.8.0 起,数据卷配置在 “Mounts” Key 下面, 可以看到所有的数据卷都是创建在主机的 <code>/mnt/sda1/var/lib/docker/volumes/...</code> 下面了  .</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-json" data-lang="json"><span class="s2">&#34;Mounts&#34;</span><span class="err">:</span> <span class="p">[</span>
<span class="p">{</span>
<span class="nt">&#34;Name&#34;</span><span class="p">:</span> <span class="s2">&#34;b53ebd40054dae599faf7c9666acfe205c3e922
</span><span class="s2">fc3e8bc3f2fd178ed788f1c29&#34;</span><span class="p">,</span>
<span class="nt">&#34;Source&#34;</span><span class="p">:</span> <span class="s2">&#34;/mnt/sda1/var/lib/docker/volumes/b53e
</span><span class="s2">bd40054dae599faf7c9666acfe205c3e922fc3e8bc3f2fd178ed788f1c29/_data&#34;</span><span class="p">,</span>
<span class="nt">&#34;Destination&#34;</span><span class="p">:</span> <span class="s2">&#34;/webapp&#34;</span><span class="p">,</span>
<span class="nt">&#34;Driver&#34;</span><span class="p">:</span> <span class="s2">&#34;local&#34;</span><span class="p">,</span>
<span class="nt">&#34;Mode&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
<span class="nt">&#34;RW&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
<span class="nt">&#34;Propagation&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span>
<span class="p">}</span>
<span class="p">]</span>
<span class="err">...</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="挂载一个本地主机文件作为数据卷">挂载一个本地主机文件作为数据卷</h4>
<p><code>-v</code> 参数也可以从主机挂载单个文件到文件到容器中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash
</code></pre></td></tr></table>
</div>
</div><p>这样就可以记录在容器输入过得命令了  .</p>
<h3 id="数据卷容器">数据卷容器</h3>
<p>如果你有一些持续更新的数据需要在容器之间共享,最好创建数据卷容器  .</p>
<p>数据卷容器,其实就是一个正常的容器,专门用来提供数据卷供其他容器挂载的  .</p>
<p>首先,创建一个名为 dbdata 的数据卷容器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo docker run -d -v /dbdata --name dbdata training/postgres <span class="nb">echo</span> Data-only container <span class="k">for</span> postgres
</code></pre></td></tr></table>
</div>
</div><p>然后,在其他容器中使用 <code>--volumes-from</code> 来挂载 dbdata 容器中的数据卷  .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo docker run -d --volumes-form dbdata --name db1 training/postgres
$ sudo docker run -d --volumes-form dbdata --name db2 training/postgres
</code></pre></td></tr></table>
</div>
</div><p>可以使用超过一个的<code>--volumes-from</code> 参数来指定从多个容器挂载不同的数据卷  . 也可以从其他已经挂载了数据卷的容器来级联挂载数据卷  .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker run -d --name db3 --volumes-from db1 training/postgres
</code></pre></td></tr></table>
</div>
</div><p><em>注：使用 <code>--volumes-from</code>  参数所挂载数据卷的容器自己并不需要保持运行状态</em></p>
<p>如果删除了挂载的容器（包括 dbdata、db1 和 db2 ）,数据卷并不会被自动删除 .如果删除一个数据卷,必须在删除最后一个还挂着它的容器时使用 <code>docker rm -v</code> 命令来指定同时删除关联的容器 .这可以让用户在容器之间升级和移到数据卷 .</p>
<h4 id="利用数据卷容器来备份恢复迁移数据卷">利用数据卷容器来备份、恢复、迁移数据卷</h4>
<p>可以利用数据卷对其中的数据进行备份、恢复和迁移 .</p>
<h5 id="备份">备份</h5>
<p>首先使用 <code>--volumes-from</code> 标记来创建一个加载 dbdata 数据卷的容器,并从主机挂载当前目录到容器的 /backup 目录 .命令如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo docker run --volumes-from dbdata -v<span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>:/backup ubuntu tar cvf /backup/backup.tar /dbdata
</code></pre></td></tr></table>
</div>
</div><p>容器启动后,使用了 <code>tar</code> 命令来将 dbdata 卷备份为容器中 /backup/backup.tar 文件,也就是主机当前目录下的名为 backup.tar 的文件  .</p>
<h5 id="恢复">恢复</h5>
<p>如果要恢复数据到一个容器,首先创建一个带有空数据卷的容器 dbdata2  .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker run -v /dbdata --name dbdata2 ubuntu /bin/bash
</code></pre></td></tr></table>
</div>
</div><p>然后创建另一个容器,挂载 dbdata2 容器卷中的数据卷,并使用 <code>untar</code>  解压备份文件到挂载的容器卷中 .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo docker run --volumes-form dbdata2 -v <span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>:/backup busybox tar xvf
/backup/backup.tar
</code></pre></td></tr></table>
</div>
</div><p>为了查看/验证恢复的数据,可以再启动一个容器挂载同样的容器卷来查看</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker run --volumes-from dbdata2 busybox /bin/ls dbdata
</code></pre></td></tr></table>
</div>
</div><h5 id="迁移数据卷">迁移数据卷</h5>
<p>代写 . . .</p>
<h1 id="docker-中的网络">Docker 中的网络</h1>
<p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务  .</p>
<h2 id="外部访问容器">外部访问容器</h2>
<p>容器中可以与运行一些网络应用,要让外部也可以访问这些应用,可以通过 <code>-P</code>  或 <code>-p</code> 参数来指定端口映射 .</p>
<p>当使用 <code>-P</code> 参数时,Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口 .</p>
<p>使用 <code>docker ps</code> 可以看到,本地主机的49155 被映射到了容器的5000 端口  .</p>
<p>此时访问本机的49155 端口即可访问容器内 web 应用提供的界面 .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo docker run -d -P training/webapp python app.py
$ sudo docker ps -l
CONTAINER ID 		IMAGE 					COMMAND 		CREATED
STATUS 			PORTS 					NAMES
bc533791f3f5 		training/webapp:latest 	python app.py 	<span class="m">5</span> seconds ag
o Up <span class="m">2</span> seconds 	0.0.0.0:49155-&gt;5000/tcp nostalgic_morse
</code></pre></td></tr></table>
</div>
</div><p><code>-P</code> （小写）则可以指定要映射的端口,并且在一个指定端口上只可以绑定一个容器 .支持的格式有</p>
<ul>
<li><code>ip:HostPort:containerPort</code></li>
<li><code>ip::containerPort</code></li>
<li><code>hostPort:containerPort</code></li>
</ul>
<h3 id="映射所有接口地址">映射所有接口地址</h3>
<p>使用 <code>hostPort ：containerPort</code> 格式本地的5000端口映射到容器的5000端口,可以执行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker run -d -p 5000:5000 training/webapp python app.py
</code></pre></td></tr></table>
</div>
</div><p>此时默认会绑定本地所有接口上的所有接口 .</p>
<h3 id="映射到指定地址的指定端口">映射到指定地址的指定端口</h3>
<p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址,比如 localhost 地址 127.0.0.1</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py
</code></pre></td></tr></table>
</div>
</div><h3 id="查看映射端口配置">查看映射端口配置</h3>
<p>使用 <code>docker port </code> 来查看当前映射的端口配置,也可以查看到绑定的地址</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker port gogs
22/tcp -&gt; 0.0.0.0:10022
3000/tcp -&gt; 0.0.0.0:10080
</code></pre></td></tr></table>
</div>
</div><p>可以看到 <code>gogs</code> 有两个容器内的端口 22, 3000 分别映射主机的10022,10080 端口  .</p>
<p><em>注： -p 可以多次使用来绑定多个端口,也就是说一条命令可以有多个 -p ,如：上面👆的 gogs 容器就绑定了俩端口</em></p>
<h2 id="容器互联">容器互联</h2>
<p>容器的连接（linking）系统是除了端口映射外,另一种跟容器中应用交互的方式 .该系统会在源和接受容器之间创建一个通道,接受容器可以看到源容器指定的信息 .</p>
<h3 id="自定义容器命名">自定义容器命名</h3>
<p>连接系统依据容器的名称来执行 .因此,首先需要自定义一个好记的容器命名 .</p>
<p>虽然创建容器的时候,系统默认会分配给一个名字 .但是自定义命名容器的话,第一,好记,第二,可以作为有用的参考的 .</p>
<p>使用 <code>--name</code> 参数可以为容器自定义命名 .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker run -d -p 8181:4040 --name own-cloud owncloud
</code></pre></td></tr></table>
</div>
</div><p>使用 <code>docker ps</code> 来查看正运行的容器</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                            NAMES
2c2e766e86fd        owncloud            <span class="s2">&#34;/entrypoint.sh ap...&#34;</span>   <span class="m">23</span> hours ago        Up <span class="m">23</span> hours         80/tcp, 0.0.0.0:8181-&gt;4040/tcp                   own-cloud
</code></pre></td></tr></table>
</div>
</div><p>使用 <code>docker inspect</code> 命令来查看容器名字</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker inspect -f <span class="s2">&#34;{{.Name}}&#34;</span> 2c2e766e86fd
/own-cloud
</code></pre></td></tr></table>
</div>
</div><p><em>注：容器的名称是唯一的 .如果已经命名了一个叫 own-cloud 的容器,当你再次使用这个名词的时候,需要先把之前的的同名容器删除</em></p>
<p><em>tips：在执行  <code>docker run</code>  的时候可以添加  <code>—rm</code>  参数,这样容器在终止后立刻删除 .注意,<code>—rm</code> 和  <code>-d</code> 参数不能同时使用  .</em></p>
<h3 id="容器互联-1">容器互联</h3>
<p>使用 <code>--link</code> 参数可以让容器之间安全的进行交互 .</p>
<p>下面是,运行 <code>Nginx</code> 容器的时候把 <code>gogs</code> 这个容器连接上</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">docker run -d --name my_nginx --link gogs:app --link own-cloud:app2 -p 80:80 -v /root/nginx/config:/etc/nginx/conf.d nginx
</code></pre></td></tr></table>
</div>
</div><p>此时,gogs 容器和 my_nginx 容器建立互联关系</p>
<p><code>--link</code> 参数的格式为 <code>--link name:alias</code> ,其中 name 是要连接的容器名称, alias 是这个连接的别名  .</p>
<p>可以通过 <code>docker inspect </code> 命令查看 my_nginx 容器信息,就会发现有这么一段信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="s2">&#34;Links&#34;</span>: <span class="o">[</span>
                <span class="s2">&#34;/gogs:/trusting_brown/app&#34;</span>,
                <span class="s2">&#34;/own-cloud:/trusting_brown/app2&#34;</span>
            <span class="o">]</span>,
</code></pre></td></tr></table>
</div>
</div><p>表面此容器已经连上两个容器, gogs 和 own-cloud,trusting_brown 是系统分配给 Nginx 的名称,连接名称分别是 app 和 app2  .</p>
<p>Docker 在两个互联的容器之间创建了一个安全的隧道,而且不用映射到它们的端口到主机上 .在启动被连接的容器的时候不用添加 -p 或 -P 参数,从而避免暴露端口到外部网络上 .</p>
<p>连接之后,在 Nginx 容器里,就会发生两个变化  .</p>
<p>一是环境变量 .在 Nginx 容器中会出现6个新增的环境变量,这些环境变量的名称分贝时由被连接的服务别名、端口等拼接而成的 .</p>
<p><em>由于起得 gogs 容器有两个端口,所以其中 APP_PORT、APP_NAME、APP_ENV_GOGS_CUSTOM 是公用的,其它8个变量每四个的分别对应22, 3000 端口</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># env | grep APP</span>
<span class="nv">APP_PORT_3000_TCP</span><span class="o">=</span>tcp://172.17.0.2:3000
<span class="nv">APP_PORT_22_TCP_PROTO</span><span class="o">=</span>tcp
<span class="nv">APP_ENV_GOGS_CUSTOM</span><span class="o">=</span>/data/gogs
<span class="nv">APP_PORT_3000_TCP_ADDR</span><span class="o">=</span>172.17.0.2
<span class="nv">APP_PORT_3000_TCP_PROTO</span><span class="o">=</span>tcp
<span class="nv">APP_PORT_22_TCP_PORT</span><span class="o">=</span><span class="m">22</span>
<span class="nv">APP_PORT_3000_TCP_PORT</span><span class="o">=</span><span class="m">3000</span>
<span class="nv">APP_PORT</span><span class="o">=</span>tcp://172.17.0.2:22
<span class="nv">APP_NAME</span><span class="o">=</span>/my_nginx/app
<span class="nv">APP_PORT_22_TCP</span><span class="o">=</span>tcp://172.17.0.2:22
<span class="nv">APP_PORT_22_TCP_ADDR</span><span class="o">=</span>172.17.0.2
</code></pre></td></tr></table>
</div>
</div><p>二是 hosts 文件 .在 Nginx 容器的 hosts 文件看到下面的记录 .这就是说,一切访问 连接别名（app）、容器 ID（ac4c0cf35adf）和容器名（gogs）的请求都会被重新导向到实时实际的 app 的 ip 地址上 .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># cat /etc/hosts | grep app</span>
172.17.0.2	app ac4c0cf35adf gogs
</code></pre></td></tr></table>
</div>
</div><h2 id="高级网络配置">高级网络配置</h2>
<p>当 Docker 启动时,会自动的主机上创建一个 <code>docker0</code> 虚拟网桥,实际上是 Linux 的一个 bridge,可以理解为一个软件交换机 .它会挂载到它的网口之间进行转发 .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ ip addr <span class="p">|</span> grep docker0
docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP
    link/ether 02:42:23:c6:3f:1c brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:23ff:fec6:3f1c/64 scope link
       valid_lft forever preferred_lft forever
</code></pre></td></tr></table>
</div>
</div><p>同时,Docker 随机分一个本地未占用的私有网段（在 <a href="https://tools.ietf.org/html/rfc1918">RFC1919</a> 中定义）中的一个地址给 <code>docker0</code> 接口 .比如我的主机上的 docker0 ip 为 <code>172.17.0.1</code> ,掩码为 <code>255.255.0.0</code>  .此后启动的容器内的网口也会自动分配有个一个同一网段（<code>172.17.0.0/16</code>）的地址 .</p>
<p>当创建一个 Docker 容器的时候,同时会创建一对 <code>vath pair</code> 接口（当数据包发送到一个接口,另一个接口也可以收到相同的数据包） .这对接口一段在容器内,即 <code>eth0</code> ；另一端在本地并挂载到 docker0 网桥,名称以 <code>veth</code> 开头  .通过这种方式,主机可以跟容器通信,容器之间也可以相互通信 . Docker 就创建了在主机和所有容器之间一个虚拟共享网络 .</p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/network.png" alt="Docker 网络"></p>
<p>​											图 i.i docker 网络</p>
<p>接下来部分将介绍在一些场景中,Docker 所有的网络定制配置 .以及通过 Linux 命令来调整、补充、甚至替换 Docker 默认的网络配置 .</p>
<h3 id="快速配置">快速配置</h3>
<p>下面是一个跟 Docker 网络相关的命令列表 .</p>
<p>其中有些命令选项只有在 Docker 服务启动的时候才能配置,而且不能马上生效 .</p>
<ul>
<li><code>-b BRIDGE or --bridge==BRIDGE</code> --指定容器挂载的网桥</li>
<li><code>--bip=CIDR</code> — 定制 docker0 的掩码</li>
<li><code>-H SOCKET... or --host=SOCKET…</code> —Docker 服务端接受命令的通道</li>
<li><code>--icc=true|false</code> --是否支持容器之间进行通信</li>
<li><code>--ip-forward=true|false</code> —容器是否能访问外网（详细解析请看下文的容器通信）</li>
<li><code>--iptables=true|false</code> --是否允许 Docker 添加 iptables 规则</li>
<li><code>--mtu=BYTES</code> —容器网络中的 MTU</li>
</ul>
<p>下面的两个命令既可以在服务启动时指定,也可以 Docker 容器启动（docker run ）时候指定 .</p>
<p>在 Docker 服务启动的时候指定则会成为默认值,后面执行<code>docker run </code>时可以覆盖设置的默认值 .</p>
<ul>
<li><code>--dns=IP_ADDRESS…</code> —使用指定的 DNS 服务器</li>
<li><code>--dns-search=DOMAIN...</code> 指定 DNS 搜索域</li>
</ul>
<p>最后这些选项只有在 docker run 执行时使用,因为它是针对容器的特性内容 .</p>
<ul>
<li><code>-h HOSTNAME or --hostname=HOSTNAME</code> --配置容器主机名</li>
<li><code>--link=CONRATAINER_NAME:ALIAS</code> —添加到另一个容器的连接</li>
</ul>
]]></content><category scheme="https://yusank.github.io/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术"/><category scheme="https://yusank.github.io/tags/go/" term="go" label="go"/><category scheme="https://yusank.github.io/tags/docker/" term="docker" label="docker"/></entry><entry><title type="text">GO interface</title><link rel="alternate" type="text/html" href="https://yusank.github.io/posts/go-interface/"/><id>https://yusank.github.io/posts/go-interface/</id><updated>2021-07-04T08:33:24+00:00</updated><published>2017-06-08T15:07:00+08:00</published><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><summary type="html">go 的 interface 的实现和原理。 Go interface interface 在 Golang 中 interface 是一个很重要的概念和特性。 什么是 interface？ In object-oriented programming, a protocol or interface is a common means for unrelated objects to communicate with……</summary><content type="html"><![CDATA[<p>go 的 interface 的实现和原理。</p>
<h1 id="go-interface">Go interface</h1>
<h2 id="interface">interface</h2>
<p>在 Golang 中 interface 是一个很重要的概念和特性。</p>
<h3 id="什么是-interface">什么是 interface？</h3>
<blockquote>
<p>In <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">object-oriented programming</a>, a <strong>protocol</strong> or <strong>interface</strong> is a common means for unrelated <a href="https://en.wikipedia.org/wiki/Object_(computer_science)">objects</a> to communicate with each other. These are definitions of <a href="https://en.wikipedia.org/wiki/Method_(computer_science)">methods</a> and values which the objects agree upon in order to co-operate. — wikipedia</p>
</blockquote>
<p>这是 wikipedia 关于 protocal 的定义，将 interface 类比如 protocal 是一种非常助于理解的方式。protocol，中文一般叫做协议，比如网络传输中的 TCP 协议。protocol 可以认为是一种双方为了交流而做出的约定，interface 可以类比如此。</p>
<p>在 Golang 中，interface 是一种抽象类型，相对于抽象类型的是具体类型（concrete type）：int，string。如下是 io 包里面的例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Writer is the interface that wraps the basic Write method.
</span><span class="c1">//
</span><span class="c1">// Write writes len(p) bytes from p to the underlying data stream.
</span><span class="c1">// It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))
</span><span class="c1">// and any error encountered that caused the write to stop early.
</span><span class="c1">// Write must return a non-nil error if it returns n &lt; len(p).
</span><span class="c1">// Write must not modify the slice data, even temporarily.
</span><span class="c1">//
</span><span class="c1">// Implementations must not retain p.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Closer is the interface that wraps the basic Close method.
</span><span class="c1">//
</span><span class="c1">// The behavior of Close after the first call is undefined.
</span><span class="c1">// Specific implementations may document their own behavior.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Closer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在 Golang 中，interface 是一组 method 的集合，是 <a href="https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B">duck-type programming</a> (鸭子类型)的一种体现。不关心属性（数据），只关心行为（方法）。具体使用中你可以自定义自己的 struct，并提供特定的 interface 里面的 method 就可以把它当成 interface 来使用。下面是一种 interface 的典型用法，定义函数的时候参数定义成 interface，调用函数的时候就可以做到非常的灵活。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MyInterface</span> <span class="kd">interface</span><span class="p">{</span>
    <span class="nf">Print</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">TestFunc</span><span class="p">(</span><span class="nx">x</span> <span class="nx">MyInterface</span><span class="p">)</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">MyStruct</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">me</span> <span class="nx">MyStruct</span><span class="p">)</span> <span class="nf">Print</span><span class="p">()</span> <span class="p">{}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">me</span> <span class="nx">MyStruct</span>
    <span class="nf">TestFunc</span><span class="p">(</span><span class="nx">me</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="为什么-interface">为什么 interface</h3>
<p>Gopher China 上给出了下面的三个理由：</p>
<ul>
<li>writing generic algorithm （泛型编程）</li>
<li>hiding implementation detail （隐藏具体实现）</li>
<li>providing interception points （提供监听点/拦截点？）</li>
</ul>
<h4 id="write-generic-algorithm">write generic algorithm</h4>
<p>严格来说，在 Golang 中并不支持泛型编程。在 C++ 等高级语言中使用泛型编程非常的简单，所以泛型编程一直是 Golang 诟病最多的地方。但是使用 interface 我们可以实现泛型编程，我这里简单说一下，具体可以参考我前面给出来的那篇文章。比如我们现在要写一个泛型算法，形参定义采用 interface 就可以了，以标准库的 sort 为例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">sort</span>

<span class="c1">// A type, typically a collection, that satisfies sort.Interface can be
</span><span class="c1">// sorted by the routines in this package.  The methods require that the
</span><span class="c1">// elements of the collection be enumerated by an integer index.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Interface</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Len is the number of elements in the collection.
</span><span class="c1"></span>    <span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span>
    <span class="c1">// Less reports whether the element with
</span><span class="c1"></span>    <span class="c1">// index i should sort before the element with index j.
</span><span class="c1"></span>    <span class="nf">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span>
    <span class="c1">// Swap swaps the elements with indexes i and j.
</span><span class="c1"></span>    <span class="nf">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>

<span class="o">...</span>

<span class="c1">// Sort sorts data.
</span><span class="c1">// It makes one call to data.Len to determine n, and O(n*log(n)) calls to
</span><span class="c1">// data.Less and data.Swap. The sort is not guaranteed to be stable.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Sort</span><span class="p">(</span><span class="nx">data</span> <span class="nx">Interface</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
</span><span class="c1"></span>    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span>
    <span class="nx">maxDepth</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="nx">maxDepth</span><span class="o">++</span>
    <span class="p">}</span>
    <span class="nx">maxDepth</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="nf">quickSort</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">maxDepth</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Sort 函数的形参是一个 interface，包含了三个方法：<code>Len()</code>，<code>Less(i,j int)</code>，<code>Swap(i, j int)</code>。使用的时候不管数组的元素类型是什么类型（int, float, string…），只要我们实现了这三个方法就可以使用 Sort 函数，这样就实现了“泛型编程”。有一点比较麻烦的是，我们需要将数组自定义一下。下面是一个例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Name</span> <span class="kt">string</span>
    <span class="nx">Age</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Person</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s: %d&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Age</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ByAge implements sort.Interface for []Person based on
</span><span class="c1">// the Age field.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ByAge</span> <span class="p">[]</span><span class="nx">Person</span> <span class="c1">//自定义
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="nx">ByAge</span><span class="p">)</span> <span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span>           <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="nx">ByAge</span><span class="p">)</span> <span class="nf">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>      <span class="p">{</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="nx">ByAge</span><span class="p">)</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Age</span> <span class="p">&lt;</span> <span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">Age</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">people</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">Person</span><span class="p">{</span>
        <span class="p">{</span><span class="s">&#34;Bob&#34;</span><span class="p">,</span> <span class="mi">31</span><span class="p">},</span>
        <span class="p">{</span><span class="s">&#34;John&#34;</span><span class="p">,</span> <span class="mi">42</span><span class="p">},</span>
        <span class="p">{</span><span class="s">&#34;Michael&#34;</span><span class="p">,</span> <span class="mi">17</span><span class="p">},</span>
        <span class="p">{</span><span class="s">&#34;Jenny&#34;</span><span class="p">,</span> <span class="mi">26</span><span class="p">},</span>
    <span class="p">}</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">people</span><span class="p">)</span>
    <span class="nx">sort</span><span class="p">.</span><span class="nf">Sort</span><span class="p">(</span><span class="nf">ByAge</span><span class="p">(</span><span class="nx">people</span><span class="p">))</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">people</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>另外 Gopher China 上还提到了一个比较有趣的东西和大家分享一下。在我们设计函数的时候，下面是一个比较好的准则。</p>
<blockquote>
<p>Be <strong>conservative</strong> in what you send, be <strong>liberal</strong> in what you accept. — Robustness Principle</p>
</blockquote>
<p>对应到 Golang 就是：</p>
<blockquote>
<p>Return <strong>concrete types</strong>, receive <strong>interfaces</strong> as parameter. — Robustness Principle applied to Go</p>
</blockquote>
<p>话说这么说，但是当我们翻阅 Golang 源码的时候，有些函数的返回值也是 interface。</p>
<h4 id="hiding-implement-detail">hiding implement detail</h4>
<p>隐藏具体实现，这个很好理解。比如我设计一个函数给你返回一个 interface，那么你只能通过 interface 里面的方法来做一些操作，但是内部的具体实现是完全不知道的。Francesc 举了个 context 的例子。 context 最先由 google 提供，现在已经纳入了标准库，而且在原有 context 的基础上增加了：cancelCtx，timerCtx，valueCtx。语言的表达有时候略显苍白无力，看一下 context 包的代码吧。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">ctx</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">cancel</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nf">newCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
    <span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>表明上 WithCancel 函数返回的还是一个 Context interface，但是这个 interface 的具体实现是 cancelCtx struct。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// newCancelCtx returns an initialized cancelCtx.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newCancelCtx</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">)</span> <span class="nx">cancelCtx</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">cancelCtx</span><span class="p">{</span>
        <span class="nx">Context</span><span class="p">:</span> <span class="nx">parent</span><span class="p">,</span>
        <span class="nx">done</span><span class="p">:</span>    <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// A cancelCtx can be canceled. When canceled, it also cancels any children
</span><span class="c1">// that implement canceler.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">cancelCtx</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Context</span>     <span class="c1">//注意一下这个地方
</span><span class="c1"></span>
    <span class="nx">done</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="c1">// closed by the first cancel call.
</span><span class="c1"></span>    <span class="nx">mu</span>       <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
    <span class="nx">children</span> <span class="kd">map</span><span class="p">[</span><span class="nx">canceler</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}</span> <span class="c1">// set to nil by the first cancel call
</span><span class="c1"></span>    <span class="nx">err</span>      <span class="kt">error</span>                 <span class="c1">// set to non-nil by the first cancel call
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">)</span> <span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">done</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">)</span> <span class="nf">Err</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%v.WithCancel&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>尽管内部实现上下面三个函数返回的具体 struct （都实现了 Context interface）不同，但是对于使用者来说是完全无感知的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">ctx</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">cancel</span> <span class="nx">CancelFunc</span><span class="p">)</span>    <span class="c1">//返回 cancelCtx
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="c1">//返回 timerCtx
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">WithValue</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">Context</span>    <span class="c1">//返回 valueCtx
</span></code></pre></td></tr></table>
</div>
</div><h4 id="providing-interception-points">providing interception points</h4>
<p>这里的 interception 想表达的意思应该是 wrapper 或者装饰器，他给出了一个例子如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">header</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">rt</span>  <span class="nx">http</span><span class="p">.</span><span class="nx">RoundTripper</span>
    <span class="nx">v</span>   <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">header</span><span class="p">)</span> <span class="nf">RoundTrip</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Response</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">h</span><span class="p">.</span><span class="nx">v</span> <span class="p">{</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span><span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">h</span><span class="p">.</span><span class="nx">rt</span><span class="p">.</span><span class="nf">RoundTrip</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过 interface，我们可以通过类似这种方式实现动态分配 (dynamic dispatch)。</p>
<h3 id="非侵入式">非侵入式</h3>
<p>什么是侵入式呢？比如 Java 的 interface 实现需要显示的声明。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyWriter</span> <span class="kd">implements</span> <span class="n">io</span><span class="o">.</span><span class="na">Writer</span> <span class="o">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>这样就意味着如果要实现多个 interface 需要显示地写很多遍，同时 package 的依赖还需要进行管理。Dependency is evil。比如我要实现 io 包里面的 Reader，Writer，ReadWriter 接口，代码可以像下面这样写。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MyIO</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">io</span> <span class="o">*</span><span class="nx">MyIO</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">io</span> <span class="o">*</span><span class="nx">MyIO</span><span class="p">)</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>

<span class="c1">// io package
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Reader</span>
    <span class="nx">Writer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这种写法真的很方便，而且不用去显示的 import io package，interface 底层实现的时候会动态的检测。这样也会引入一些问题：</p>
<ol>
<li>性能下降。使用 interface 作为函数参数，runtime 的时候会动态的确定行为。而使用 struct 作为参数，编译期间就可以确定了。</li>
<li>不知道 struct 实现哪些 interface。这个问题可以使用 guru 工具来解决。</li>
</ol>
<p>综上，Golang interface 的这种非侵入实现真的很难说它是好，还是坏。但是可以肯定的一点是，对开发人员来说代码写起来更简单了。</p>
<h3 id="interface-type-assertion">interface type assertion</h3>
<p>interface 像其他类型转换的时候一般我们称作断言，举个例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">do</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.(</span><span class="kt">int</span><span class="p">)</span>    <span class="c1">// might panic
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这样写的坏处在于：一旦断言失败，程序将会 panic。一种避免 panic 的写法是使用 type assertion。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">do</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="nx">n</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.(</span><span class="kt">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="c1">// 断言失败处理
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>对于 interface 的操作可以使用 reflect 包来处理，关于 reflect 包的原理和使用可以参考我的文章。</p>
<h3 id="总结">总结</h3>
<p>interface 是 Golang 的一种重要的特性，但是这是以 runtime 为代价的，也就意味着性能的损失（关于 interface 的底层实现之后有时间再写）。抛开性能不谈，interface 对于如何设计我们的代码确实给了一个很好的思考。</p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="http://legendtkl.com/2015/11/25/go-generic-programming/">Golang “泛型编程”</a></li>
<li><a href="http://legendtkl.com/2015/11/28/go-interface-reflect/">谈一谈 Golang 的 interface 和 reflect</a></li>
<li><a href="https://www.youtube.com/watch?v=F4wUrj6pmSI&amp;t=2319s">understanding golang interface(Gopher China) — youtube</a></li>
<li><a href="https://github.com/gopherchina/conference/blob/master/2017/1.4%20interface.presented.pdf">understanding golang interface(Gopher China) — slide</a></li>
</ol>
]]></content><category scheme="https://yusank.github.io/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术"/><category scheme="https://yusank.github.io/tags/go/" term="go" label="go"/></entry><entry><title type="text">Go Format</title><link rel="alternate" type="text/html" href="https://yusank.github.io/posts/go-format/"/><id>https://yusank.github.io/posts/go-format/</id><updated>2021-07-04T08:33:24+00:00</updated><published>2017-06-04T17:59:00+08:00</published><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><summary type="html">go 代码的一些规范和命名规则...... Golang 代码规范 项目目录结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 PROJECT_NAME ├── README.md 介绍软件及文档入口 ├─……</summary><content type="html"><![CDATA[<p>go 代码的一些规范和命名规则......</p>
<h1 id="golang-代码规范">Golang 代码规范</h1>
<h2 id="项目目录结构">项目目录结构</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">PROJECT_NAME
├── README.md 介绍软件及文档入口
├── bin 编译好的二进制文件,执行./build.sh自动生成，该目录也用于程序打包
├── build.sh 自动编译的脚本
├── doc 该项目的文档
├── pack 打包后的程序放在此处
├── pack.sh 自动打包的脚本，生成类似xxxx.20170713_14:45:35.tar.gz的文件，放在pack文件下
└── src 该项目的源代码
    ├── main 项目主函数
    ├── model 项目代码
    ├── research 在实现该项目中探究的一些程序
    └── vendor 存放go的库
        ├── github.com/xxx 第三方库
        └── xxx.com/obc 公司内部的公共库
</code></pre></td></tr></table>
</div>
</div><p>项目的目录结构尽量做到简明、层次明确。</p>
<h2 id="命名规范">命名规范</h2>
<h3 id="文件名命名规范">文件名命名规范</h3>
<p>用小写，尽量见名思义，看见文件名就可以知道这个文件下的大概内容，对于源代码里的文件，文件名要很好的代表了一个模块实现的功能。</p>
<h3 id="包名">包名</h3>
<p>包名用小写，使用短命名，尽量不要和标准库冲突。</p>
<h3 id="接口名">接口名</h3>
<p>单个函数的接口以 <code>er</code> 作为后缀，如 Reader， Writer</p>
<p>接口的实现则去掉后缀</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>两个函数的接口名综合两个函数名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">WriteFlusher</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nf">Flush</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>三个以上函数的接口名，类似于结构体名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Car</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Start</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span> 
    <span class="nf">Stop</span><span class="p">()</span> <span class="kt">error</span>
    <span class="nf">Recover</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="变量">变量</h3>
<p>全局变量：采用驼峰命名法，仅限在包内的全局变量，包外引用需要写接口，提供调用；</p>
<p>局部变量：驼峰式，第一个单词的首字母小写，如有两个以上单词组成的变量名，第二个单词开始首字母大写。</p>
<h3 id="常量">常量</h3>
<p>全局：驼峰命名，每个单词的首字母大写</p>
<p>局部：与变量的风格一样</p>
<h2 id="函数名">函数名</h2>
<p>函数名采用驼峰命名法，不要使用下划线。</p>
<h2 id="import-规范">import 规范</h2>
<p>import在多行的情况下，goimports 会自动帮你格式化，在一个文件里面引入了一个package，建议采用如下格式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">{</span>
    <span class="s">&#34;net&#34;</span>
    <span class="s">&#34;strings&#34;</span>

    <span class="s">&#34;github.com/astaxie/beego&#34;</span>
    <span class="s">&#34;gopkg.in/mgo.v2&#34;</span>

    <span class="s">&#34;myproject/models&#34;</span>
    <span class="s">&#34;myproject/utils&#34;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>项目中最好不要使用相对路径导入包：</p>
<p>// 这是不好的导入</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="err">“</span><span class="p">..</span><span class="o">/</span><span class="nx">net</span><span class="err">”</span>
</code></pre></td></tr></table>
</div>
</div><p>// 这是正确的做法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="err">“</span><span class="nx">xxxx</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">proj</span><span class="o">/</span><span class="nx">net</span><span class="err">”</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="错误处理">错误处理</h2>
<p>error作为函数的值返回,必须尽快对error进行处理</p>
<p>采用独立的错误流进行处理</p>
<p>不要采用这种方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// error handling
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// normal code
</span><span class="c1"></span>    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>而采用以下方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// error handling
</span><span class="c1"></span>        <span class="k">return</span> <span class="c1">// or continue, etc.
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="c1">// normal code
</span></code></pre></td></tr></table>
</div>
</div><p>如果返回值需要初始化，则采用以下方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">x</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">f</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// error handling
</span><span class="c1"></span>    <span class="k">return</span>
<span class="p">}</span>
<span class="c1">// use x
</span></code></pre></td></tr></table>
</div>
</div><h3 id="panic">panic</h3>
<p>在逻辑处理中禁用panic</p>
<p>在 main 包中只有当实在不可运行的情况采用 panic，例如文件无法打开，数据库无法连接导致程序无法 正常运行，但是对于其他的 package 对外的接口不能有 panic，只能在包内采用。 建议在 main 包中使用 log.Fatal 来记录错误，这样就可以由 log 来结束程序。</p>
<h2 id="recover">Recover</h2>
<p>recover 用于捕获 runtime 的异常，禁止滥用 recover，在开发测试阶段尽量不要用 recover，recover 一般放在你认为会有不可预期的异常的地方。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">server</span><span class="p">(</span><span class="nx">workChan</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">Work</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">work</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">workChan</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nf">safelyDo</span><span class="p">(</span><span class="nx">work</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">safelyDo</span><span class="p">(</span><span class="nx">work</span> <span class="o">*</span><span class="nx">Work</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;work failed:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="c1">// do 函数可能会有不可预期的异常
</span><span class="c1"></span>    <span class="nf">do</span><span class="p">(</span><span class="nx">work</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="defer">Defer</h2>
<p>defer 在函数 return 之前执行，对于一些资源的回收用 defer 是好的，但也禁止滥用 defer，defer 是需要消耗性能的,所以频繁调用的函数尽量不要使用 defer。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Contents returns the file&#39;s contents as a string.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Contents</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>  <span class="c1">// f.Close will run when we&#39;re finished.
</span><span class="c1"></span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">byte</span>
    <span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:])</span>
        <span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">n</span><span class="p">]</span><span class="o">...</span><span class="p">)</span> <span class="c1">// append is discussed later.
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>  <span class="c1">// f will be closed if we return here.
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">result</span><span class="p">),</span> <span class="kc">nil</span> <span class="c1">// f will be closed if we return here.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="控制结构">控制结构</h2>
<h3 id="if">if</h3>
<p>if接受初始化语句，约定如下方式建立局部变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Chmod</span><span class="p">(</span><span class="mo">0664</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="for">for</h3>
<p>采用短声明建立局部变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="range">range</h3>
<p>如果只需要第一项（key），就丢弃第二个：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">key</span><span class="p">.</span><span class="nf">expired</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">delete</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果只需要第二项，则把第一项置为下划线</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">array</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">value</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="return">return</h3>
<p>尽早return：一旦有错误发生，马上返回</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="nx">d</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Stat</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="nf">codeUsing</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="方法接收器">方法接收器</h2>
<p>名称一般采用 struct 的第一个字母且为小写， 而不是 this，me 或 self</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Transfer</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transfer</span><span class="p">)</span> <span class="nf">Get</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果接收者是 map， slice 或者 chan，不要用指针传递</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//Map
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">mp</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">mp</span><span class="p">)</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
    <span class="nx">m</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;k&#34;</span><span class="p">,</span> <span class="s">&#34;v&#34;</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//Channel
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">ch</span><span class="p">)</span> <span class="nf">Push</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">i</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">ch</span><span class="p">)</span> <span class="nf">Pop</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&lt;-</span><span class="nx">c</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nx">c</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="s">&#34;i&#34;</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">Pop</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果需要对 slice 进行修改，通过返回值的方式重新复制</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//Slice
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">slice</span> <span class="p">[]</span><span class="kt">byte</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">addOne</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">slice</span><span class="p">)</span> <span class="nf">addOne</span><span class="p">(</span><span class="nx">b</span> <span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果接收者是含有 sync.Mutex 或者类似同步字段的结构体，必须使用指针传递避免复制</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">m</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">lock</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm">Wrong !!!
</span><span class="cm">func (t T) lock() {
</span><span class="cm">    t.m.Lock()
</span><span class="cm">}
</span><span class="cm">*/</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">t</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
    <span class="nx">t</span><span class="p">.</span><span class="nf">lock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果接收者是大的结构体或者数组，使用指针传递会更有效率。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">data</span> <span class="p">[</span><span class="mi">1024</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Get</span><span class="p">()</span> <span class="kt">byte</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">t</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">Get</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="一键代码规范">一键代码规范</h2>
<p>使用 JetBrain 系列 IDE 的同学，可以按快捷键或者鼠标右键来一键使用 go 提供的 <code>format</code> 命令;</p>
<p>快捷键：</p>
<p>cmd + option + shift + f 对当前文件进行 format</p>
<p>cmd + option + shift + p 对当前项目所有 go 文件进行 format</p>
<p>鼠标右键：</p>
<p>在 IDE 内点击鼠标右键，选择 <code>Go Tools</code>,然后可以选择对单个文件或项目进行 format。</p>
<p>用 vscode 的同学，在设置里面加上以下语句即可以保存文件后自动进行 format</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-json" data-lang="json"><span class="s2">&#34;go.formatOnSave&#34;</span><span class="err">:</span> <span class="kc">true</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="总结">总结</h2>
<p>代码风格和代码规范是体现一个程序员的基本素质的一项指标，也是对自己的代码和他人的一个最基本的尊重。</p>
]]></content><category scheme="https://yusank.github.io/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术"/><category scheme="https://yusank.github.io/tags/go/" term="go" label="go"/><category scheme="https://yusank.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" term="代码规范" label="代码规范"/></entry><entry><title type="text">GO test</title><link rel="alternate" type="text/html" href="https://yusank.github.io/posts/go-test/"/><id>https://yusank.github.io/posts/go-test/</id><updated>2021-07-04T08:33:24+00:00</updated><published>2017-06-01T15:07:00+08:00</published><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><summary type="html">Go 测试用例 开发程序其中很重要的一点是测试，我们如何保证代码的质量，如何保证每个函数是可运行，运行结果是正确的，又如何保证……</summary><content type="html"><![CDATA[<h1 id="go-测试用例">Go 测试用例</h1>
<p>开发程序其中很重要的一点是测试，我们如何保证代码的质量，如何保证每个函数是可运行，运行结果是正确的，又如何保证写出来的代码性能是好的，我们知道单元测试的重点在于发现程序设计或实现的逻辑错误，使问题及早暴露，便于问题的定位解决，而性能测试的重点在于发现程序设计上的一些问题，让线上的程序能够在高并发的情况下还能保持稳定。本小节将带着这一连串的问题来讲解Go语言中如何来实现单元测试和性能测试。</p>
<p>Go语言中自带有一个轻量级的测试框架<code>testing</code>和自带的<code>go test</code>命令来实现单元测试和性能测试，<code>testing</code>框架和其他语言中的测试框架类似，你可以基于这个框架写针对相应函数的测试用例，也可以基于该框架写相应的压力测试用例，那么接下来让我们一一来看一下怎么写。</p>
<p>另外建议安装<a href="https://github.com/cweill/gotests">gotests</a>插件自动生成测试代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">go get -u -v github.com/cweill/gotests/...
</code></pre></td></tr></table>
</div>
</div><h2 id="如何编写测试用例">如何编写测试用例</h2>
<p>由于<code>go test</code>命令只能在一个相应的目录下执行所有文件，所以我们接下来新建一个项目目录<code>gotest</code>,这样我们所有的代码和测试代码都在这个目录下。</p>
<p>接下来我们在该目录下面创建两个文件：gotest.go和gotest_test.go</p>
<ol>
<li>gotest.go:这个文件里面我们是创建了一个包，里面有一个函数实现了除法运算:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">gotest</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;errors&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">Division</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">(</span><span class="kt">float64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;除数不能为0&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">a</span> <span class="o">/</span> <span class="nx">b</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>gotest_test.go:这是我们的单元测试文件，但是记住下面的这些原则：</li>
</ol>
<ul>
<li>文件名必须是<code>_test.go</code>结尾的，这样在执行<code>go test</code>的时候才会执行到相应的代码</li>
<li>你必须import <code>testing</code>这个包</li>
<li>所有的测试用例函数必须是<code>Test</code>开头</li>
<li>测试用例会按照源代码中写的顺序依次执行</li>
<li>测试函数<code>TestXxx()</code>的参数是<code>testing.T</code>，我们可以使用该类型来记录错误或者是测试状态</li>
<li>测试格式：<code>func TestXxx (t *testing.T)</code>,<code>Xxx</code>部分可以为任意的字母数字的组合，但是首字母不能是小写字母[a-z]，例如<code>Testintdiv</code>是错误的函数名。</li>
<li>函数中通过调用<code>testing.T</code>的<code>Error</code>, <code>Errorf</code>, <code>FailNow</code>, <code>Fatal</code>, <code>FatalIf</code>方法，说明测试不通过，调用<code>Log</code>方法用来记录测试的信息。</li>
</ul>
<p>下面是我们的测试用例的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">gotest</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">Test_Division_1</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nf">Division</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">3</span> <span class="o">||</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">//try a unit test on function
</span><span class="c1"></span>	    <span class="nx">t</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="s">&#34;除法函数测试没通过&#34;</span><span class="p">)</span> <span class="c1">// 如果不是如预期的那么就报错
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">&#34;第一个测试通过了&#34;</span><span class="p">)</span> <span class="c1">//记录一些你期望记录的信息
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Test_Division_2</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">t</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="s">&#34;就是不通过&#34;</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>我们在项目目录下面执行<code>go test</code>,就会显示如下信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">--- FAIL: Test_Division_2 <span class="o">(</span>0.00 seconds<span class="o">)</span>
    gotest_test.go:16: 就是不通过
	FAIL
	<span class="nb">exit</span> status <span class="m">1</span>
	FAIL	gotest	0.013s	
</code></pre></td></tr></table>
</div>
</div><p>从这个结果显示测试没有通过，因为在第二个测试函数中我们写死了测试不通过的代码<code>t.Error</code>，那么我们的第一个函数执行的情况怎么样呢？默认情况下执行<code>go test</code>是不会显示测试通过的信息的，我们需要带上参数<code>go test -v</code>，这样就会显示如下信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">===</span> RUN Test_Division_1
--- PASS: Test_Division_1 <span class="o">(</span>0.00 seconds<span class="o">)</span>
	gotest_test.go:11: <span class="nv">第一个测试通过了</span>
<span class="o">===</span> RUN Test_Division_2
--- FAIL: Test_Division_2 <span class="o">(</span>0.00 seconds<span class="o">)</span>
	gotest_test.go:16: 就是不通过
FAIL
<span class="nb">exit</span> status <span class="m">1</span>
FAIL	gotest	0.012s
</code></pre></td></tr></table>
</div>
</div><p>上面的输出详细的展示了这个测试的过程，我们看到测试函数1<code>Test_Division_1</code>测试通过，而测试函数2<code>Test_Division_2</code>测试失败了，最后得出结论测试不通过。接下来我们把测试函数2修改成如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Test_Division_2</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nf">Division</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="nx">e</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">//try a unit test on function
</span><span class="c1"></span>		<span class="nx">t</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="s">&#34;Division did not work as expected.&#34;</span><span class="p">)</span> <span class="c1">// 如果不是如预期的那么就报错
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">&#34;one test passed.&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span> <span class="c1">//记录一些你期望记录的信息
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后我们执行<code>go test -v</code>，就显示如下信息，测试通过了：</p>
<pre><code>=== RUN Test_Division_1
--- PASS: Test_Division_1 (0.00 seconds)
	gotest_test.go:11: 第一个测试通过了
=== RUN Test_Division_2
--- PASS: Test_Division_2 (0.00 seconds)
	gotest_test.go:20: one test passed. 除数不能为0
PASS
ok  gotest    0.013s
</code></pre><h2 id="如何编写压力测试">如何编写压力测试</h2>
<p>压力测试用来检测函数(方法）的性能，和编写单元功能测试的方法类似,此处不再赘述，但需要注意以下几点：</p>
<ul>
<li>压力测试用例必须遵循如下格式，其中XXX可以是任意字母数字的组合，但是首字母不能是小写字母</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BenchmarkXXX</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>go test</code>不会默认执行压力测试的函数，如果要执行压力测试需要带上参数<code>-test.bench</code>，语法:<code>-test.bench=&quot;test_name_regex&quot;</code>,例如<code>go test -test.bench=&quot;.*&quot;</code>表示测试全部的压力测试函数</li>
<li>在压力测试用例中,请记得在循环体内使用<code>testing.B.N</code>,以使测试可以正常的运行</li>
<li>文件名也必须以<code>_test.go</code>结尾</li>
</ul>
<p>下面我们新建一个压力测试文件webbench_test.go，代码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">gotest</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">Benchmark_Division</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span> <span class="c1">//use b.N for looping 
</span><span class="c1"></span>		<span class="nf">Division</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Benchmark_TimeConsumingFunction</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nf">StopTimer</span><span class="p">()</span> <span class="c1">//调用该函数停止压力测试的时间计数
</span><span class="c1"></span>
	<span class="c1">//做一些初始化的工作,例如读取文件数据,数据库连接之类的,
</span><span class="c1"></span>	<span class="c1">//这样这些时间不影响我们测试函数本身的性能
</span><span class="c1"></span>	
	<span class="nx">b</span><span class="p">.</span><span class="nf">StartTimer</span><span class="p">()</span> <span class="c1">//重新开始时间
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nf">Division</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>我们执行命令<code>go test -file webbench_test.go -test.bench=&quot;.*&quot;</code>，可以看到如下结果：</p>
<pre><code>PASS
Benchmark_Division	500000000	         7.76 ns/op
Benchmark_TimeConsumingFunction	500000000	         7.80 ns/op
ok  	gotest	9.364s
</code></pre><p>上面的结果显示我们没有执行任何<code>TestXXX</code>的单元测试函数，显示的结果只执行了压力测试函数，第一条显示了<code>Benchmark_Division</code>执行了500000000次，每次的执行平均时间是7.76纳秒，第二条显示了<code>Benchmark_TimeConsumingFunction</code>执行了500000000，每次的平均执行时间是7.80纳秒。最后一条显示总共的执行时间。</p>
<h2 id="小结">小结</h2>
<p>通过上面对单元测试和压力测试的学习，我们可以看到<code>testing</code>包很轻量，编写单元测试和压力测试用例非常简单，配合内置的<code>go test</code>命令就可以非常方便的进行测试，这样在我们每次修改完代码,执行一下go test就可以简单的完成回归测试了。</p>
]]></content><category scheme="https://yusank.github.io/tags/go/" term="go" label="go"/></entry><entry><title type="text">Go 文件操作</title><link rel="alternate" type="text/html" href="https://yusank.github.io/posts/go-file/"/><id>https://yusank.github.io/posts/go-file/</id><updated>2021-07-04T08:33:24+00:00</updated><published>2017-05-22T12:20:00+08:00</published><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><summary type="html">GO 文件操作 在任何计算机设备中，文件是都是必须的对象，而在Web编程中,文件的操作一直是Web程序员经常遇到的问题,文件操……</summary><content type="html"><![CDATA[<h1 id="go-文件操作">GO 文件操作</h1>
<p>在任何计算机设备中，文件是都是必须的对象，而在Web编程中,文件的操作一直是Web程序员经常遇到的问题,文件操作在Web应用中是必须的,非常有用的,我们经常遇到生成文件目录,文件(夹)编辑等操作,现在我们来看看 go 对文件是怎么操作的。</p>
<h2 id="目录操作">目录操作</h2>
<p>文件操作的大多数函数都是在os包里面，下面列举了几个目录操作的：</p>
<ul>
<li><code>func Mkdir(name string, perm FileMode) error</code></li>
</ul>
<p>创建名称为name的目录，权限设置是perm，例如0777</p>
<ul>
<li><code>func MkdirAll(path string, perm FileMode) error</code></li>
</ul>
<p>根据path创建多级子目录，例如 test/test1/test2。</p>
<ul>
<li><code>func Remove(name string) error</code></li>
</ul>
<p>删除名称为name的目录，当目录下有文件或者其他目录时会出错</p>
<ul>
<li><code>func RemoveAll(path string) error</code></li>
</ul>
<p>根据path删除多级子目录，如果path是单个名称，那么该目录下的子目录全部删除。</p>
<p>以下是简单的使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">os</span><span class="p">.</span><span class="nf">Mkdir</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="mo">0777</span><span class="p">)</span>
	<span class="nx">os</span><span class="p">.</span><span class="nf">MkdirAll</span><span class="p">(</span><span class="s">&#34;test/test1/test2&#34;</span><span class="p">,</span> <span class="mo">0777</span><span class="p">)</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;crash with error %v \n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">os</span><span class="p">.</span><span class="nf">RemoveAll</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="文件操作">文件操作</h2>
<h3 id="建立与打开文件">建立与打开文件</h3>
<p>新建文件可以通过如下两个方法</p>
<ul>
<li><code>func Create(name string) (file *File, err Error)</code></li>
</ul>
<p>根据提供的文件名创建新的文件，返回一个文件对象，默认权限是0666的文件，返回的文件对象是可读写的。</p>
<ul>
<li><code>func NewFile(fd uintptr, name string) *File</code></li>
</ul>
<p>根据文件描述符创建相应的文件，返回一个文件对象</p>
<p>通过如下两个方法来打开文件：</p>
<ul>
<li><code>func Open(name string) (file *File, err Error)</code></li>
</ul>
<p>该方法打开一个名称为name的文件，但是是只读方式，内部实现其实调用了OpenFile。</p>
<ul>
<li><code>func OpenFile(name string, flag int, perm uint32) (file *File, err Error)</code></li>
</ul>
<p>打开名称为name的文件，flag是打开的方式，只读、读写等，perm是权限</p>
<h3 id="写文件">写文件</h3>
<p>写文件函数：</p>
<ul>
<li><code>func (file *File) Write(b []byte) (n int, err Error)</code></li>
</ul>
<p>写入byte类型的信息到文件</p>
<ul>
<li><code>func (file *File) WriteAt(b []byte, off int64) (n int, err Error)</code></li>
</ul>
<p>在指定位置开始写入byte类型的信息</p>
<ul>
<li><code>func (file *File) WriteString(s string) (ret int, err Error)</code></li>
</ul>
<p>写入string信息到文件</p>
<p>写文件的示例代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">userFile</span> <span class="o">:=</span> <span class="s">&#34;yusank.txt&#34;</span>
	<span class="nx">fout</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="nx">userFile</span><span class="p">)</span>		
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">userFile</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">fout</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">fout</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="s">&#34;Just a test!\r\n&#34;</span><span class="p">)</span>
		<span class="nx">fout</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;Just a test!\r\n&#34;</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="读文件">读文件</h3>
<p>读文件函数：</p>
<ul>
<li><code>func (file *File) Read(b []byte) (n int, err Error)</code></li>
</ul>
<p>读取数据到b中</p>
<ul>
<li><code>func (file *File) ReadAt(b []byte, off int64) (n int, err Error)</code></li>
</ul>
<p>从 off 开始读取数据到 b 中</p>
<p>读文件的示例代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">userFile</span> <span class="o">:=</span> <span class="s">&#34;yusank.txt&#34;</span>
	<span class="nx">fl</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">userFile</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">userFile</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">fl</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">n</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">fl</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
		<span class="k">if</span> <span class="mi">0</span> <span class="o">==</span> <span class="nx">n</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">])</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="删除文件">删除文件</h3>
<p>Go语言里面删除文件和删除文件夹是同一个函数</p>
<ul>
<li><code>func Remove(name string) Error</code></li>
</ul>
<p>调用该函数就可以删除文件名为name的文件</p>
<h3 id="计算文件哈希值">计算文件哈希值</h3>
<p>在网络上传输文件完成后，往往都会有一步文件的校验。需要确认传过来的文件是否是损坏的。</p>
<h4 id="小文件">小文件</h4>
<p>代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;crypto/md5&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;io&#34;</span>
    <span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">testFile</span> <span class="o">:=</span> <span class="s">&#34;/path/to/file&#34;</span>
    <span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">testFile</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// 以上是为了获的 os.File 对象
</span><span class="c1"></span>
    <span class="nx">md5h</span> <span class="o">:=</span> <span class="nx">md5</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">md5h</span><span class="p">,</span> <span class="nx">file</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%x&#34;</span><span class="p">,</span> <span class="nx">md5h</span><span class="p">.</span><span class="nf">Sum</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)))</span> <span class="c1">// 打印出来的是 MD5 算法下的哈希结果
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="大文件">大文件</h4>
<p>代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;crypto/md5&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;io&#34;</span>
    <span class="s">&#34;math&#34;</span>
    <span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">filechunk</span> <span class="p">=</span> <span class="mi">8192</span> <span class="c1">// 假定 8KB 以上为大文件
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;utf8.txt&#34;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
    <span class="p">}</span>

    <span class="k">defer</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="c1">// 计算大小
</span><span class="c1"></span>    <span class="nx">info</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Stat</span><span class="p">()</span>

    <span class="nx">filesize</span> <span class="o">:=</span> <span class="nx">info</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span>

    <span class="nx">blocks</span> <span class="o">:=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Ceil</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">filesize</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">filechunk</span><span class="p">)))</span>

    <span class="nx">hash</span> <span class="o">:=</span> <span class="nx">md5</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint64</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">blocks</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">blocksize</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Min</span><span class="p">(</span><span class="nx">filechunk</span><span class="p">,</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">filesize</span><span class="o">-</span><span class="nb">int64</span><span class="p">(</span><span class="nx">i</span><span class="o">*</span><span class="nx">filechunk</span><span class="p">))))</span>
        <span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">blocksize</span><span class="p">)</span>

        <span class="nx">file</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
        <span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">hash</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buf</span><span class="p">))</span> <span class="c1">// append into the hash
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s checksum is %x\n&#34;</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="nx">hash</span><span class="p">.</span><span class="nf">Sum</span><span class="p">(</span><span class="kc">nil</span><span class="p">))</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>代码内容是打开本地文件分块读取进行哈希计算，在网络传输中，可以每次传入一包的文件，先用 io.WriteString() 方法添加到哈希并在最后进行 hash.Sum() 操作</p>
]]></content><category scheme="https://yusank.github.io/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术"/><category scheme="https://yusank.github.io/tags/go/" term="go" label="go"/></entry><entry><title type="text">Unix 网络编程</title><link rel="alternate" type="text/html" href="https://yusank.github.io/posts/unix-network/"/><id>https://yusank.github.io/posts/unix-network/</id><updated>2021-07-04T08:33:24+00:00</updated><published>2017-04-22T16:52:00+08:00</published><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><summary type="html">Unix 网络编程 ​ 卷II - 进程间通信 IPC是进程间通信（interprocess communication）的简称。传统上该术……</summary><content type="html"><![CDATA[<h1 id="unix-网络编程">Unix 网络编程</h1>
<p>​																		<strong>卷II - 进程间通信</strong></p>
<p>IPC是进程间通信（interprocess communication）的简称。传统上该术语描述的是运行在某个操作系统之上的不同进程间各种消息传递（<em>message passing</em>）的方式。</p>
<p>进程间的通信一般是一下四种形式：</p>
<ul>
<li>消息传递（管道、FIFO和消息队列）；</li>
<li>同步（互斥量、条件变量、读写锁、文件和记录锁、信号量）；</li>
<li>共享内存（匿名的和具名的）；</li>
<li>远程过程调用（Solaris 门和 Sun RPC）。</li>
</ul>
<h1 id="消息队列">消息队列</h1>
<p><strong>消息传递：</strong></p>
<ul>
<li>管道和FIFO；</li>
<li>Posix 消息队列；</li>
<li>System V消息队列。</li>
</ul>
<h2 id="管道和fifo">管道和FIFO</h2>
<p>管道是最初的Unix IPC 形式。由于管道没有名字，所以它只能用于有亲缘关系的进程间的通信。</p>
<p><strong>实现机制：</strong></p>
<p>管道是由内核管理的一个缓冲区，相当于我们放入内存中的一个纸条。管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它<strong>被设计成为环形的数据结构</strong>，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">pipe</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>             <span class="c1">//返回：若成功返回0，若出错返回-1
</span></code></pre></td></tr></table>
</div>
</div><p>该函数返回两个文件描述符：fd[0] 和 fd[1]。前者打开来读，后者打开来写。</p>
<p>管道尽管是单个进程创建，但是管道的典型用途是为两个不同的进程（一个父进程，一个子进程）提供进程间的通信手段。</p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/Screen%20Shot%202017-02-22%20at%2011.49.01%20AM.png" alt="Screen Shot 2017-02-22 at 11.49.01 AM"></p>
<p>​	  									   数据流 &gt;&gt;&gt;&gt;&gt;&gt;</p>
<p>首先是，由一个进程（它将成为父进程）创建一个 pipe 后调用 fork 派生一个自身的副本，接着关闭着个 pipe 的读成端，子进程关闭同一个 pipe 的写入端。这就是进程间提供了一个单向数据流，如下图。</p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/Screen%20Shot%202017-02-22%20at%2011.56.11%20AM.png" alt="Screen Shot 2017-02-22 at 11.56.11 AM"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
   
    <span class="k">if</span><span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">){</span>                 <span class="c1">// 先建立管道得到一对文件描述符
</span><span class="c1"></span>        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>            <span class="c1">// 父进程把文件描述符复制给子进程
</span><span class="c1"></span>        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>                <span class="c1">// 父进程写 
</span><span class="c1"></span>        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>                <span class="c1">// 关闭读描述符
</span><span class="c1"></span>        <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">hello world</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>                            <span class="c1">// 子进程读
</span><span class="c1"></span>        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>                <span class="c1">// 关闭写端
</span><span class="c1"></span>        <span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">);</span>
        <span class="n">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><em>technically，自从可以在进程间传递描述符后，管道也能用于无亲缘关系的进程间，而现实中管道通常用于具有共同祖先的进程间。</em></p>
<p><strong>FIFO：命名管道(named PIPE)</strong></p>
<p>管道尽管对很多操作来说是很有用的，但是它的根本局限性在于没有名字，从而只能由亲缘关系的进程（父子进程）使用。为了解决这一问题，Linux提供了FIFO方式连接进程。有了FIFO之后这一缺点得以改正。FIFO有时也称之为有名管道（named pipe）。FIFO除了有管道的功能外，它还允许无亲缘关系的进程的通信。pipe 和 FIFO 都是使用通常的 read 和 write 函数访问的。</p>
<p>FIFO (First in, First out)为一种特殊的文件类型，它在文件系统中有对应的路径。当一个进程以读(r)的方式打开该文件，而另一个进程以写(w)的方式打开该文件，那么内核就会在这两个进程之间建立管道，所以FIFO实际上也由内核管理，不与硬盘打交道。之所以叫FIFO，是因为管道本质上是一个先进先出的队列数据结构，最早放入的数据被最先读出来，从而保证信息交流的顺序。FIFO只是借用了文件系统(file system,命名管道是一种特殊类型的文件，因为Linux中所有事物都是文件，它在文件系统中以文件名的形式存在。)来为管道命名。写模式的进程向FIFO文件中写入，而读模式的进程从FIFO文件中读出。当删除FIFO文件时，管道连接也随之消失。<strong>FIFO的好处在于我们可以通过文件的路径来识别管道，从而让没有亲缘关系的进程之间建立连接</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">mkfifo</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">);</span>    <span class="c1">// 返回： 成功返回0，出错返回 -1
</span></code></pre></td></tr></table>
</div>
</div><p>其中 <em>pathname</em> 是一个普通的 Unix 路径名，它是该 FIFO 的名字。</p>
<p>mkfifo 函数中参数 <em>mode</em> 指定 FIFO 的读写权限。</p>
<p>mkfifo 函数是要么创建一个新的 FIFO ，要么返回一个 EEXIST 错误（如果该 FIFO 已存在），如果不希望创建一个新的 FIFO 那就用 open 函数就可以。</p>
<p>FIFO 不能打开既写又读。</p>
<p>如果一个 FIFO 只读不写，只写不读都会形成阻塞。</p>
<p>下边是一个简单地例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;  </span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;  </span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;  </span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;  </span><span class="cp">
</span><span class="cp"></span>      
<span class="cp"># define FIFO1  &#34;/tmp/my_fifo&#34;
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>  
<span class="p">{</span>  
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">mkfifo</span><span class="p">(</span><span class="s">&#34;/tmp/my_fifo&#34;</span><span class="p">,</span> <span class="mo">0777</span><span class="p">);</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;FIFO created/n&#34;</span><span class="p">);</span>  
    <span class="p">}</span>  
  <span class="c1">// 打开FIFO
</span><span class="c1"></span>  <span class="c1">//writefd = Open(FIFO1, O_WRONLY | O_NONBLOCK, 0)	
</span><span class="c1"></span>  <span class="c1">//readfd = Open(FIFO1, O_RDONLY, 0)
</span><span class="c1"></span>     <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>  
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><em>open</em> 第二个参数中的选项O_NONBLOCK，选项O_NONBLOCK表示非阻塞，加上这个选项后，表示open调用是非阻塞的，如果没有这个选项，则表示open调用是阻塞的。</p>
<ul>
<li>对于以只读方式（O_RDONLY）打开的FIFO文件，如果open调用是阻塞的（即第二个参数为O_RDONLY），除非有一个进程以写方式打开同一个FIFO，否则它不会返回；如果open调用是非阻塞的的（即第二个参数为O_RDONLY|O_NONBLOCK），则即使没有其他进程以写方式打开同一个FIFO文件，open调用将成功并立即返回。</li>
<li>对于以只写方式（O_WRONLY）打开的FIFO文件，如果open调用是阻塞的（即第二个参数为O_WRONLY），open调用将被阻塞，直到有一个进程以只读方式打开同一个FIFO文件为止；如果open调用是非阻塞的（即第二个参数为O_WRONLY|O_NONBLOCK），open总会立即返回，但如果没有其他进程以只读方式打开同一个FIFO文件，open调用将返回-1，并且FIFO也不会被打开。</li>
</ul>
<p>关于管道或 FIFO 的读写的若干规则：</p>
<ul>
<li>如果请求读出的数据量多于管道或 FIFO 中当前的可用数据量，那么只会返回这些可用的数据。</li>
<li>如果请求你写入的数据的字节数小于或等于 PIPE_BUF (可原子地写入往一个管道或 FIFO 的最大数据量， Posix 要求至少为512)，那么 write 操作保证是原子的。这意味着，如果两个进程差不多同时往同一个管道或 FIFO 写，那么不管是先写入来自第一个进程的所有数据再写第二个，还是顺序颠倒过来。系统都不会相互混杂来自两个进程的数据。然而如果数据的字节数大于 PIPE_BUF ，那么 write 操作不能保证是原子的。</li>
<li>不止以上这些。。。</li>
</ul>
<p><strong>小结</strong>： FIFO 与管道类似，但是它用 mkfifo 创建，之后需要open 打开。打开管道必须小心，因为许多规则（read 只写管道、write 只读管道、从空的管道或FIFO read 等的情况的返回结果。）制约着 open 的阻塞与否。</p>
<h2 id="posix-ipc">Posix IPC</h2>
<p>Posix--可移植性操作系统接口（Protable operating system interface）</p>
<p>有关Unix标准化的大多数活动是由 Posix 和 Open Group 做的。</p>
<p>Posix 不是单一的标准，是一系列的标准。</p>
<p>以下三种类型的IPC合成为“Posix IPC”</p>
<ul>
<li>Posix 消息队列</li>
<li>Posix 信号量</li>
<li>Posix 共享内存区</li>
</ul>
<h2 id="posix-消息队列">Posix 消息队列</h2>
<p>消息队列可认为是个消息链表。有足够写权限的进程可往队列放置信息，有足够读权限的进程可从队列读取信息。每一个信息都是一条记录，它是由发送者赋予一个优先级。在某个进程往一个队列写入消息之前，并不需要另一个进程在该队列上等待消息的到达。这根管道和 FIFO 是相反的。</p>
<p>一个进程可以往某些队列写入一些信息，然后终止，再让另外一个进程在以后的某个时刻读取这些信息。</p>
<p>Posix 消息队列和下面讲的System V 消息队列有许多的相似性。以下是主要的差别：</p>
<ul>
<li>对 Posix 消息队列的读总是返回最高优先级的最早消息，对 System V 消息队列的读则可以返回任意指定优先级的消息；</li>
<li>当往一个空队列放置一个信息时，Posix 消息队列允许产生一个信号或启动一个线程，System V消息队列则是不提供类似的机制。</li>
</ul>
<p>队列中的每一个消息都有如下属性：</p>
<ul>
<li>一个无符号整数优先级（Posix）或 一个长整数类型（system V）；</li>
<li>消息的数据部分长度（可以为0）；</li>
<li>数据本身（如果长度大于0）。</li>
</ul>
<p>一个消息队列的可能布局。</p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/unix%20%E7%BD%91%E7%BB%9C.png" alt="unix 网络"></p>
<p>我们所设想的是一个链表，该链表的有中含有当前队列的两个属性：队列中允许的最大开销数以及每一个消息的最大大小。</p>
<p>**mq_open ,mq_close 和 mq_unlink 函数 **：</p>
<p>mq_open 函数创建一个新的消息队列或打开一个已存在的消息队列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp"># include &lt;mqueue.h&gt;
</span><span class="cp"></span><span class="n">mqd_t</span> <span class="nf">mq_open</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oflag</span><span class="p">,</span> <span class="p">...</span>
              <span class="cm">/* mode_t mode, struct mq_attr *attr  */</span><span class="p">);</span>
							<span class="c1">//返回： 成功返回消息对列描述符，出错返回-1
</span></code></pre></td></tr></table>
</div>
</div><p>其中 <em>name</em> 有自己的一套命名规则，因为 Posix IPC 使用“Posix IPC 名字”进行标识。为方便于移植起见，Posix IPC 名字必须以斜杠符开头并且不能再包含任何斜杠符。</p>
<p><em>oflag</em> 是O_RDONLY、O_WRONLY 或 	O_RDWR 之一， 可能按位或上O_CREATE(若不存在则创建)、O_EXCL(与O_CREATE一起，若已存在返回EEXIST 错误)或 O_NONBLOCK（非阻塞标识符）。</p>
<p>当实际操作创建一个新的消息队列时（指定O_CREATE标志，且请求的队列不存在），<em>mode</em> 和 <em>attr</em> 参数是需要的。mode上面介绍过。attr参数用于给新队列指定某些属性。</p>
<p>mq_open 返回值称为<strong>消息队列描述符（message queue descriptor）</strong>，这个值用作其他消息队列函数的第一参数。</p>
<p>已打开的消息队列是由 mq_close 关闭的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;mqueue.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">mq_close</span><span class="p">(</span><span class="n">mqd_t</span> <span class="n">mqdes</span><span class="p">)</span>                       <span class="c1">//返回： 成功返回0，出错返回-1
</span></code></pre></td></tr></table>
</div>
</div><p>关闭之后调用进程不再使用该描述符，但其消息队列并不从系统中删除。一个进程终止时，它打开着的消息队列都关闭，就像调用mq_close 一样。</p>
<p>要从系统中删除消息队列则用mq_unlink 函数，其第一参数为 mq_open 的第一参数 <em>name</em>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp"># include &lt;mqueue.h&gt;
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">mq_unlink</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>                    <span class="c1">//返回： 成功返回0，出错返回-1
</span></code></pre></td></tr></table>
</div>
</div><p><strong>mq_getattr 和 mq_setattr 函数</strong></p>
<p>消息队列有四个属性，这两个函数是获取和修改这些属性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">mq_flags</span>		<span class="c1">//队列阻塞标志位
</span><span class="c1"></span><span class="n">mq_maxmsg</span>		<span class="c1">//队列最大允许消息数
</span><span class="c1"></span><span class="n">mq_msgsize</span>		<span class="c1">//队列消息最大字节数
</span><span class="c1"></span><span class="n">mq_curmsgs</span>		<span class="c1">//队列当前消息条数
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;mqueue.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">mq_getattr</span><span class="p">(</span><span class="n">mqd_t</span> <span class="n">mqdes</span><span class="p">,</span><span class="k">struct</span> <span class="n">mq_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">mq_setattr</span><span class="p">(</span><span class="n">mqd_t</span> <span class="n">mqdes</span><span class="p">,</span><span class="k">const</span> <span class="k">struct</span> <span class="n">mq_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mq_attr</span> <span class="o">*</span><span class="n">oattr</span><span class="p">);</span>  <span class="c1">//返回：均成功返回0，出错返回-1
</span></code></pre></td></tr></table>
</div>
</div><p><strong>mq_send 和 mq_receive 函数</strong></p>
<p>​	这两个函数分别往一个队列放置一个信息和从一个队列取走一个消息。每一个消息都有优先级，它是一个小于MQ_PRIO_MAX 的无符号整数。Posix要求这个上限至少为32.</p>
<p>​	mq_receive 总是返回所指定队列中优先级最高的的最早消息，而且该优先级能随该消息的内容及其长度一同返回。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;mqueue.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">mq_send</span><span class="p">(</span><span class="n">mqd_t</span> <span class="n">mqdes</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">);</span>      <span class="c1">//返回： 成功返回0，出错返回-1
</span><span class="c1"></span><span class="n">ssize_t</span> <span class="nf">mq_reccevie</span><span class="p">(</span><span class="n">mqd_t</span> <span class="n">mqdes</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">priop</span><span class="p">);</span>     <span class="c1">//返回： 成功返回消息中的字节数，出错返回-1
</span></code></pre></td></tr></table>
</div>
</div><p>mq_receive 的 <em>len</em> 参数的值不能小于能加到所指定队列中的最大大小（该队列 mq_attr 结构的 mq_msgsize ）。要是 <em>len</em> 小于该值， mq_receive立即返回 EMSGSIZE 错误。</p>
<p>mq_send 的 <em>prio</em> 参数是待发信息的优先级，其值必须小于 MQ_PRIO_MAX 。如果 mq_receive 的 <em>priop</em> 参数是一个非空指针，所返回消息的优先级就通过该指针存放。如果应用不必使用优先级不同的消息，那就给mq_send 指针值为0的优先级，给 mq_receive 指定一个空指针作为其最后一个参数。</p>
<p>往某个队列中增加一个消息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;mqueue.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">mqd_t</span>		<span class="n">mqd</span><span class="p">;</span>		<span class="c1">//描述符
</span><span class="c1"></span>  <span class="kt">void</span>		<span class="o">*</span><span class="n">ptr</span><span class="p">;</span>		<span class="c1">//指向缓冲区的指针
</span><span class="c1"></span>  <span class="n">size_t</span>	<span class="n">len</span><span class="p">;</span>		<span class="c1">//长度
</span><span class="c1"></span>  <span class="n">uint_t</span>	<span class="n">prio</span><span class="p">;</span>		<span class="c1">//优先度
</span><span class="c1"></span>  
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: mqsend &lt;name&gt; &lt;#bytes&gt; &lt;priority&gt;&#34;</span><span class="p">);</span>
  <span class="n">len</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
  <span class="n">prio</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
  
  <span class="n">mqd</span> <span class="o">=</span> <span class="n">Mq_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_WRONLY</span><span class="p">);</span>	<span class="c1">// 创建一个消息队列
</span><span class="c1"></span>  
  <span class="n">ptr</span> <span class="o">=</span> <span class="n">Calloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span><span class="c1">// 所用的缓冲区用colloc分配，该函数会把该缓冲区初始化为0
</span><span class="c1"></span>  <span class="n">Mq_send</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">prio</span><span class="p">);</span>
  
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>待发消息的大小和优先级必须作为命令行参数指定。</p>
<p>从某队列读出下一个信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> 		<span class="n">c</span><span class="p">,</span><span class="n">flags</span><span class="p">;</span>
  <span class="n">mqd_t</span>		<span class="n">maq</span><span class="p">;</span>
  <span class="n">ssize_t</span>	<span class="n">n</span><span class="p">;</span>
  <span class="n">uint_t</span>	<span class="n">prio</span><span class="p">;</span>
  <span class="kt">void</span>		<span class="o">*</span><span class="n">buff</span><span class="p">;</span>
  <span class="k">struct</span>	<span class="n">mq_attr</span>	<span class="n">attr</span><span class="p">;</span>
  
  <span class="n">flags</span> <span class="o">=</span> <span class="n">O_RDONLY</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="n">Getopt</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&#34;n&#34;</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="sc">&#39;n&#39;</span><span class="o">:</span>
        <span class="n">flags</span> <span class="o">|=</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">optind</span> <span class="o">!=</span> <span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: mqreceive [-n] &lt;name&gt;&#34;</span><span class="p">);</span>
  
  <span class="n">mqd</span> <span class="o">=</span><span class="n">Mq_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">optind</span><span class="p">],</span> <span class="n">flags</span><span class="p">);</span>
  <span class="n">Mq_getattr</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
  
  <span class="n">buff</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">);</span>
  
  <span class="n">n</span> <span class="o">=</span> <span class="n">Mq_receive</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prio</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;read %ld bytes, priority = %u</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">n</span><span class="p">,</span> <span class="n">prio</span><span class="p">);</span>
  
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>命令行选项 -n 指定非阻塞属性，这样如果所指定的队列中没有消息， 则返回一个错误。</p>
<p>调用 mq_getattr 打开队列并取得属性。需要确定最大消息大小，因为必须为调用的 mq_receive 分配一个这样大小的缓冲区。最后输出所读出消息的大小及其属性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">solaris %mqcreate /test1							创建并获取属性
solaris %mqgetattr /test1
max

solaris % mqsend /test1 <span class="m">100</span> 9999					以无效的优先级发送
mq_send error: Invalid argument

solaris % mqsend /test1 <span class="m">100</span> 6						100字节，优先级6 
solaris % mqsend /test1 <span class="m">50</span> <span class="m">18</span> 						50字节，优先级18
solaris % mqsend /test1 <span class="m">33</span> <span class="m">18</span> 						33字节，优先级18

solaris % mqreceive /test1
<span class="nb">read</span> <span class="m">50</span> bytes, <span class="nv">priority</span> <span class="o">=</span> 18						返回优先级最高的最早消息
solaris % mqreceive /test1
<span class="nb">read</span> <span class="m">33</span> bytes, <span class="nv">priority</span> <span class="o">=</span> <span class="m">18</span>
solaris % mqreceive /test1
<span class="nb">read</span> <span class="m">100</span> bytes, <span class="nv">priority</span> <span class="o">=</span> <span class="m">6</span>
solaris % mqreceive /test1							指定非阻塞属性，队列为空
mq_recevie error: Resource temporarily unavalibale
</code></pre></td></tr></table>
</div>
</div><p>消息队列限制：</p>
<ul>
<li>mq_mqxmsg			队列的最大消息数</li>
<li>mq_msgsize                  给定消息的最大字节数</li>
<li>MQ_OPEN_MAX            一个进程能够同时拥有的打开着消息队列的组大数目（Posix要求至少为8）</li>
<li>MQ_PRIO_MAX             任意消息的最大优先级值加1（Posix要求至少为32）</li>
</ul>
<p><strong>mq_notify 函数</strong></p>
<p>Posix 消息队列允许异步事件通知（ <em>asynchronous event notifiction</em>），以告知何时有一个消息放置到了某个空消息队列中。</p>
<h2 id="system-v-消息队列">System V 消息队列</h2>
<p>以下三种类型的IPC称为 System V IPC：</p>
<ul>
<li>System V 消息队列；</li>
<li>System V 信号量；</li>
<li>System V 共享内存区。</li>
</ul>
<p>这个称为作为这三个IPC机制的通称是因为它们源自 System V Unix 。这三种IPC最先出现在AT&amp;T System v UNIX上面，并遵循XSI标准，有时候也被称为XSI IPC。</p>
<p>System V 消息队列使用<em>消息队列标识符（message queue identifier）</em> 标识。有足够权限的任何进程可往队列放置信息，有足够权限的任何进程可从队列读取信息。跟 Posix 一样，在某个进程往一个队列写入消息之前，不求另外某个进程正在等待该队列上一个消息的到达。</p>
<p>对于系统的每个消息队列，内核维护一个定义在 <code>&lt;sys/msg.h&gt;</code>  头文件中的信息结构.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">msqid_ds</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">ipc_perm</span> 	<span class="n">msg_perm</span>   <span class="c1">//operation permission structure
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">msg</span>			<span class="o">*</span><span class="n">msg_frist</span> <span class="c1">//ptr to frist message on queue
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">msg</span>			<span class="o">*</span><span class="n">msg_last</span>  <span class="c1">//ptr to last message on queue
</span><span class="c1"></span>    <span class="n">msglen_t</span>			<span class="n">msg_cbytes</span> <span class="c1">//current #bytes on queue
</span><span class="c1"></span>    <span class="n">msgqnum_t</span>       	<span class="n">msg_qnum</span>   <span class="c1">//number of messages currently on queue
</span><span class="c1"></span>    <span class="n">msglen_t</span>        	<span class="n">msg_qbytes</span> <span class="c1">//maximum number of bytes allowed on queue
</span><span class="c1"></span>    <span class="n">pid_t</span>           	<span class="n">msg_lspid</span>  <span class="c1">//process ID of last msgsnd()
</span><span class="c1"></span>    <span class="n">pid_t</span>           	<span class="n">msg_lrpid</span>  <span class="c1">//process ID of last msgrcv()
</span><span class="c1"></span>    <span class="n">time_t</span>          	<span class="n">msg_stime</span>  <span class="c1">//time of last msgsnd()
</span><span class="c1"></span>    <span class="n">time_t</span>          	<span class="n">msg_rtime</span>  <span class="c1">//time of last msgrcv()
</span><span class="c1"></span>    <span class="n">time_t</span>          	<span class="n">msg_ctime</span>  <span class="c1">//time of last change
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><em>Unix 98 不要求有 msg_frist、msg_last 和 msg_cbytes 成员。然而普通的源自 <a href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/sysmsg.h.html">System V</a> 的实现中可以找到这三个成员。就算提供了这两个指针，那么它们指向的是内核内存空间，对于应用来说基本没有作用的。</em></p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/unix%20%E7%BD%91%E7%BB%9C%20%281%29.png" alt="unix 网络 (1)"></p>
<p>我们可以将内核中某个特定的消息队列画为一个消息链表，如图。</p>
<p><strong>msgget 函数</strong></p>
<p>msgget 函数用于创建一个新的消息队列或访问一个已存在的消息队列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/msg.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="n">msgget</span> <span class="p">(</span><span class="n">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oflag</span><span class="p">)</span>	
  											<span class="c1">//返回： 成功返回非负标识符，出错返回-1
</span></code></pre></td></tr></table>
</div>
</div><p>返回值是一个整数标识符，其他三个msg函数就用它来指代该队列。</p>
<p>oflag是读写权限的组合。（稍微复杂。。。）</p>
<p>当创建一个新的消息队列的时，msqid_ds 结构的如下成员被初始化。</p>
<ul>
<li>
<p>msg_perm 结构的 uid 和 cuid 成员被设置成当前进程的有效用户ID，gid 和 cgid 成员被设置成当前的进程的有效组ID。</p>
</li>
<li>
<p>oflag 中的读写权限位存放在msg_perm.mode 中。</p>
</li>
<li>
<p>msg_qnum、msg_lspid，msg_lrpid、msg_stime 和 msg_rtime 被设置为0.</p>
</li>
<li>
<p>msg_ctime 被设置为当前时间。</p>
</li>
<li>
<p>msg_qbytes 被设置成系统限制值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">ipc_perm</span>
<span class="p">{</span>
<span class="n">key_t</span>        		<span class="n">key</span><span class="p">;</span>            <span class="cm">/*调用shmget()时给出的关键字*/</span>
<span class="n">uid_t</span>           	<span class="n">uid</span><span class="p">;</span>            <span class="cm">/*共享内存所有者的有效用户ID */</span>
<span class="n">gid_t</span>          		<span class="n">gid</span><span class="p">;</span>            <span class="cm">/* 共享内存所有者所属组的有效组ID*/</span> 
<span class="n">uid_t</span>          		<span class="n">cuid</span><span class="p">;</span>           <span class="cm">/* 共享内存创建 者的有效用户ID*/</span>
<span class="n">gid_t</span>         		<span class="n">cgid</span><span class="p">;</span>           <span class="cm">/* 共享内存创建者所属组的有效组ID*/</span>
<span class="n">mode_t</span>			   	<span class="n">mode</span><span class="p">;</span>    		<span class="cm">/* Permissions + SHM_DEST和SHM_LOCKED标志*/</span>
<span class="n">ulong_t</span>		    	<span class="n">seq</span><span class="p">;</span>          	<span class="cm">/* 序列号*/</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
</li>
</ul>
<p><strong>msgsnd 函数</strong></p>
<p>使用 msgget 函数打开一个消息队列后，使用 msgsnd 函数往其上放置一个消息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp"># include &lt;sys/msg.h&gt;
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">msgsnd</span><span class="p">(</span><span class="kt">int</span> <span class="n">msqid</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="n">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>其中msqid 是由msgget 函数返回的标识符。ptr 是一个结构指针，该结构具有如下的模板：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">msgbuf</span> <span class="p">{</span>
 	<span class="kt">long</span> 	<span class="n">mtype</span><span class="p">;</span>			<span class="c1">// message type ,must be &gt; 0
</span><span class="c1"></span> 	<span class="kt">char</span>	<span class="n">mtext</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>		<span class="c1">// message data
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><em>消息类型必须大于0，因为对于 msgrcv 函数来说，非正的消息类型用作特殊的指示器。</em></p>
<p><em>mtext虽然起名是 text ，但是消息类型并不局限于文本。任何形式的数据都是允许的。内核根本不解释消					  息数据的内容。ptr 所指向的是一个含有消息类型的长整数，消息本身则紧跟着它之后。</em></p>
<p>msgsnd 的 <em>length</em> 参数以字节为单位指定待发送消息的长度。是用户自定义的，可以是0.</p>
<p><em>flag</em> 参数既可以是0，也可以是IPC_NOWAIT 。IPC_NOWAIT 标志使得 msgsnd 调用非阻塞：如果没有存放新消息的可用空间，该函数马上返回。这个条件可能发生的情况包括：</p>
<ul>
<li>在指定的队列中已有太多的字节（对应 该队列的msqid_ds 结构中的msg_qbytes 值）；</li>
<li>在系统范围存在太多的消息。</li>
</ul>
<p>如果两个条件一个存在，而且IPC_NOWAIT标志已指定，msgsnd 就返回一个EAGAIN 错误。如果两个条件一个存在，标志未指定，那么调用线程就被投入睡眠，直到：</p>
<ul>
<li>具备存放新消息的空间；</li>
<li>由 msqgid 标识的消息队列从系统中删除（这个情况下回返回一个EIDRM 错误）；</li>
<li>调用线程被某个捕获的信息所中断。</li>
</ul>
]]></content><category scheme="https://yusank.github.io/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术"/><category scheme="https://yusank.github.io/tags/unix/" term="Unix" label="Unix"/><category scheme="https://yusank.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" term="网络编程" label="网络编程"/></entry><entry><title type="text">跨域资源共享 CORS 详解</title><link rel="alternate" type="text/html" href="https://yusank.github.io/posts/cors/"/><id>https://yusank.github.io/posts/cors/</id><updated>2021-07-04T08:33:24+00:00</updated><published>2017-01-30T15:07:00+08:00</published><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><summary type="html">跨域资源共享 CORS 详解 CORS是一个W3C标准，全称是&amp;quot;跨域资源共享&amp;quot;（Cross-origin resource sha……</summary><content type="html"><![CDATA[<h1 id="跨域资源共享-cors-详解">跨域资源共享 CORS 详解</h1>
<p>CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。
它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了AJAX只能<strong>同源</strong>使用的限制。
本文详细介绍CORS的内部机制。</p>
<h2 id="一简介">一、简介</h2>
<p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h2 id="二两种请求">二、两种请求</h2>
<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要同时满足以下两大条件，就属于简单请求。</p>
<blockquote>
<ol>
<li>请求方法是以下三种方法之一：</li>
</ol>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>（2）HTTP的头信息不超出以下几种字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
</blockquote>
<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<h2 id="三简单请求">三、简单请求</h2>
<h3 id="31-基本流程">3.1 基本流程</h3>
<p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p>
<p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/cors</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="n">Origin</span><span class="o">:</span> <span class="l">http://api.bob.com</span>
<span class="n">Host</span><span class="o">:</span> <span class="l">api.alice.com</span>
<span class="n">Accept-Language</span><span class="o">:</span> <span class="l">en-US</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>
<span class="n">User-Agent</span><span class="o">:</span> <span class="l">Mozilla/5.0...</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-http" data-lang="http"><span class="err">Access-Control-Allow-Origin: http://api.bob.com
</span><span class="err">Access-Control-Allow-Credentials: true
</span><span class="err">Access-Control-Expose-Headers: FooBar
</span><span class="err">Content-Type: text/html; charset=utf-8
</span></code></pre></td></tr></table>
</div>
</div><p>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头。</p>
<p><strong>（1）Access-Control-Allow-Origin</strong></p>
<p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<p><strong>（2）Access-Control-Allow-Credentials</strong></p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p><strong>（3）Access-Control-Expose-Headers</strong></p>
<p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader('FooBar')</code>可以返回<code>FooBar</code>字段的值。</p>
<h3 id="32-withcredentials-属性">3.2 withCredentials 属性</h3>
<p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-http" data-lang="http"><span class="err">Access-Control-Allow-Credentials: true
</span></code></pre></td></tr></table>
</div>
</div><p>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">withCredentials</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p>
<p>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭<code>withCredentials</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">xhr</span><span class="p">.</span><span class="nx">withCredentials</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>需要注意的是，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</p>
<h2 id="四非简单请求">四、非简单请求</h2>
<h3 id="41-预检请求">4.1 预检请求</h3>
<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>
<p>下面是一段浏览器的JavaScript脚本。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="s1">&#39;http://api.alice.com/cors&#39;</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;PUT&#39;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="s1">&#39;X-Custom-Header&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><p>上面代码中，HTTP请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个&quot;预检&quot;请求，要求服务器确认可以这样请求。下面是这个&quot;预检&quot;请求的HTTP头信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-http" data-lang="http"><span class="nf">OPTIONS</span> <span class="nn">/cors</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="n">Origin</span><span class="o">:</span> <span class="l">http://api.bob.com</span>
<span class="n">Access-Control-Request-Method</span><span class="o">:</span> <span class="l">PUT</span>
<span class="n">Access-Control-Request-Headers</span><span class="o">:</span> <span class="l">X-Custom-Header</span>
<span class="n">Host</span><span class="o">:</span> <span class="l">api.alice.com</span>
<span class="n">Accept-Language</span><span class="o">:</span> <span class="l">en-US</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>
<span class="n">User-Agent</span><span class="o">:</span> <span class="l">Mozilla/5.0...</span>
</code></pre></td></tr></table>
</div>
</div><p>&quot;预检&quot;请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p>
<p>除了<code>Origin</code>字段，&quot;预检&quot;请求的头信息包括两个特殊字段。</p>
<p><strong>（1）Access-Control-Request-Method</strong></p>
<p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code>。</p>
<p><strong>（2）Access-Control-Request-Headers</strong></p>
<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p>
<h3 id="42-预检请求的回应">4.2 预检请求的回应</h3>
<p>服务器收到&quot;预检&quot;请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">200</span> <span class="ne">OK</span>
<span class="n">Date</span><span class="o">:</span> <span class="l">Mon, 01 Dec 2008 01:15:39 GMT</span>
<span class="n">Server</span><span class="o">:</span> <span class="l">Apache/2.0.61 (Unix)</span>
<span class="n">Access-Control-Allow-Origin</span><span class="o">:</span> <span class="l">http://api.bob.com</span>
<span class="n">Access-Control-Allow-Methods</span><span class="o">:</span> <span class="l">GET, POST, PUT</span>
<span class="n">Access-Control-Allow-Headers</span><span class="o">:</span> <span class="l">X-Custom-Header</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">text/html; charset=utf-8</span>
<span class="n">Content-Encoding</span><span class="o">:</span> <span class="l">gzip</span>
<span class="n">Content-Length</span><span class="o">:</span> <span class="l">0</span>
<span class="n">Keep-Alive</span><span class="o">:</span> <span class="l">timeout=2, max=100</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">Keep-Alive</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">text/plain</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的HTTP回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-http" data-lang="http"><span class="err">Access-Control-Allow-Origin: *
</span></code></pre></td></tr></table>
</div>
</div><p>如果浏览器否定了&quot;预检&quot;请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-http" data-lang="http"><span class="err">XMLHttpRequest cannot load http://api.alice.com.
</span><span class="err">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
</span></code></pre></td></tr></table>
</div>
</div><p>服务器回应的其他CORS相关字段如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-http" data-lang="http"><span class="err">Access-Control-Allow-Methods: GET, POST, PUT
</span><span class="err">Access-Control-Allow-Headers: X-Custom-Header
</span><span class="err">Access-Control-Allow-Credentials: true
</span><span class="err">Access-Control-Max-Age: 1728000
</span></code></pre></td></tr></table>
</div>
</div><p><strong>（1）Access-Control-Allow-Methods</strong></p>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。</p>
<p><strong>（2）Access-Control-Allow-Headers</strong></p>
<p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。</p>
<p><strong>（3）Access-Control-Allow-Credentials</strong></p>
<p>该字段与简单请求时的含义相同。</p>
<p><strong>（4）Access-Control-Max-Age</strong></p>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
<h3 id="43-浏览器的正常请求和回应">4.3 浏览器的正常请求和回应</h3>
<p>一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p>
<p>下面是&quot;预检&quot;请求之后，浏览器的正常CORS请求。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-http" data-lang="http"><span class="nf">PUT</span> <span class="nn">/cors</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="n">Origin</span><span class="o">:</span> <span class="l">http://api.bob.com</span>
<span class="n">Host</span><span class="o">:</span> <span class="l">api.alice.com</span>
<span class="n">X-Custom-Header</span><span class="o">:</span> <span class="l">value</span>
<span class="n">Accept-Language</span><span class="o">:</span> <span class="l">en-US</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>
<span class="n">User-Agent</span><span class="o">:</span> <span class="l">Mozilla/5.0...</span>
</code></pre></td></tr></table>
</div>
</div><p>上面头信息的<code>Origin</code>字段是浏览器自动添加的。</p>
<p>下面是服务器正常的回应。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-http" data-lang="http"><span class="err">Access-Control-Allow-Origin: http://api.bob.com
</span><span class="err">Content-Type: text/html; charset=utf-8
</span></code></pre></td></tr></table>
</div>
</div><p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p>
<h2 id="五与jsonp的比较">五、与JSONP的比较</h2>
<p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p>
<p>JSONP只支持<code>GET</code>请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<p>（完）</p>
]]></content><category scheme="https://yusank.github.io/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术"/><category scheme="https://yusank.github.io/tags/go/" term="go" label="go"/><category scheme="https://yusank.github.io/tags/cors/" term="cors" label="cors"/></entry><entry><title type="text">linux命令</title><link rel="alternate" type="text/html" href="https://yusank.github.io/posts/linux-cmd/"/><id>https://yusank.github.io/posts/linux-cmd/</id><updated>2021-07-04T08:33:24+00:00</updated><published>2016-12-28T13:13:13+08:00</published><author><name>yusank</name><uri>https://yusank.github.io/</uri><email>yusankurban@gmail.com</email></author><summary type="html">welcome to learn terminal command!!! linux命令 永！远！不！要！执！行！你！不！清！楚！在！干！啥！的！命！令！ 实用性 1 $ ls -l | sed &amp;#39;1d&amp;#39; | sort -n -k5 | awk……</summary><content type="html"><![CDATA[<p>welcome to learn terminal command!!!</p>
<h1 id="linux命令">linux命令</h1>
<h3 id="永远不要执行你不清楚在干啥的命令">永！远！不！要！执！行！你！不！清！楚！在！干！啥！的！命！令！</h3>
<h2 id="实用性">实用性</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ ls -l <span class="p">|</span> sed <span class="s1">&#39;1d&#39;</span> <span class="p">|</span> sort -n -k5 <span class="p">|</span> awk <span class="s1">&#39;{printf &#34;%15s %10s\n&#34;, $9,$5}&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>按文件大小增序打印出当前目录下的文件名及其文件大小(单位字节）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">history</span> <span class="p">|</span> awk <span class="s1">&#39;{print $2}&#39;</span> <span class="p">|</span> sort <span class="p">|</span> uniq -c <span class="p">|</span> sort -rn <span class="p">|</span> head -10
</code></pre></td></tr></table>
</div>
</div><p>输出你最常用的十条命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ http POST http://localhost:4000/ &lt; /&lt;json文件路径&gt;
</code></pre></td></tr></table>
</div>
</div><p>做测试的时候很有用的一个命令，需要下载http</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ brew install http
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ lsof -n -P -i TCP -s TCP:LISTEN

COMMAND  PID       USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
QQ       <span class="m">290</span> smartestee   33u  IPv4 0x2f3beaa58a62d73b      0t0  TCP 127.0.0.1:4300 <span class="o">(</span>LISTEN<span class="o">)</span>
QQ       <span class="m">290</span> smartestee   34u  IPv4 0x2f3beaa58c69673b      0t0  TCP 127.0.0.1:4301 <span class="o">(</span>LISTEN<span class="o">)</span>
idea    <span class="m">3257</span> smartestee  164u  IPv4 0x2f3beaa588d11e43      0t0  TCP 127.0.0.1:6942 <span class="o">(</span>LISTEN<span class="o">)</span>
idea    <span class="m">3257</span> smartestee  385u  IPv4 0x2f3beaa58c69316b      0t0  TCP 127.0.0.1:63342 <span class="o">(</span>LISTEN<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>查看端口的使用情况</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ ps -ef
</code></pre></td></tr></table>
</div>
</div><p>查看进程</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">kill</span>  xxxx
</code></pre></td></tr></table>
</div>
</div><p>端口冲突时，用此命令，关闭某个端口。用PID替换xxxx</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">history</span>
</code></pre></td></tr></table>
</div>
</div><p>查看历史命令记录</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">pwd</span>
</code></pre></td></tr></table>
</div>
</div><p>当前位置</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ which xx
</code></pre></td></tr></table>
</div>
</div><p>path位置，搭建环境的时候肯定会用得到</p>
<h3 id="linux-文件系统命令">Linux 文件系统命令</h3>
<p>修改问价拥有者</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ chgrp -R 组名 文件 / 目录
$ chown -R 账户名 文件 / 目录
</code></pre></td></tr></table>
</div>
</div><p>修改文件权限</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ chmod 
</code></pre></td></tr></table>
</div>
</div><ul>
<li>使用数字
<ul>
<li>r：4, w：2, x：1</li>
<li>每种身份的权限的累加的。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ chmod <span class="m">777</span> <span class="nb">test</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>使用符号修改</p>
<ul>
<li>
<p>u: user, g: group, o: others, a: all</p>
</li>
<li>
<p>添加权限用+， 除去用-， 设置用=</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ chmod <span class="nv">u</span><span class="o">=</span>rwx, <span class="nv">g</span><span class="o">=</span>rw, <span class="nv">o</span><span class="o">=</span>r <span class="nb">test</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ chmod a-x <span class="nb">test</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ chmod go+r <span class="nb">test</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo !!
</code></pre></td></tr></table>
</div>
</div><p>以root权限执行上一条命令（注意上一条命令的内容，以免发生意外）</p>
<p>例如：在Ubuntu 安装软件或插件的时候需要用到这个命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo apt-get install nginx
</code></pre></td></tr></table>
</div>
</div><p>查看和修改：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ cat
$ more
$ less
$ head
$ tail

$ vi
$ vim

$ mkdir
$ touch
</code></pre></td></tr></table>
</div>
</div><h3 id="git">git</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git
</code></pre></td></tr></table>
</div>
</div><p>先给出比较常用的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git add &lt;一个或多个文件名<span class="o">(</span>文件名之间是用空格，也可以是一个点，表示添加全部<span class="o">)</span>&gt;
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git commit -m <span class="s2">&#34;注释&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>本地提交</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-powershell" data-lang="powershell"><span class="p">$</span> <span class="n">git</span> <span class="n">checkout</span> <span class="p">&lt;</span><span class="n">分支名或master</span><span class="p">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>切换分支与master</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git branch &lt;分支名&gt;
</code></pre></td></tr></table>
</div>
</div><p>新开一个分支</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git merge &lt;分支名&gt;
</code></pre></td></tr></table>
</div>
</div><p>主分支与分支的合并</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git push origin master
</code></pre></td></tr></table>
</div>
</div><p>提交到github上</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ fuck
</code></pre></td></tr></table>
</div>
</div><p>纠正命令行输入的错误，比手动改快，实用。</p>
<p>安装：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ brew install thefuck
</code></pre></td></tr></table>
</div>
</div><h2 id="娱乐">娱乐</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ cmatrix
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ telnet towel.blinkenlights.nl
</code></pre></td></tr></table>
</div>
</div><p>telnet是基于Telnet协议的远程登录客户端程序,经常用来远程登录服务器.除此还可以用它来观看星球大战</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ fortune
</code></pre></td></tr></table>
</div>
</div><p>随机输出名言或者笑话，</p>
<p>还有很多，有兴趣的可以通过这个链接去看：<a href="https://www.zhihu.com/question/20273259">知乎</a></p>
<p>个人博客 <a href="http://aa.yusank.space/2016/12/28/linux%E5%91%BD%E4%BB%A4/">yusank</a></p>
<p>比较牛逼的一个查找命令的网站：http://www.commandlinefu.com/commands/browse/sort-by-votes</p>
<p>每天都有更新各种命令组合</p>
]]></content><category scheme="https://yusank.github.io/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术"/><category scheme="https://yusank.github.io/tags/linux/" term="Linux" label="Linux"/></entry></feed>