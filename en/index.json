[{"categories":["kubernetes"],"content":" A lightweight but powerful and programmable rule engine for kubernetes admission webhook called kinitiras powered by k-cloud-labs. ","date":"2023-02-01","objectID":"/en/posts/policy-engine/:0:0","tags":["kubernetes","policy-engine","webhook"],"title":"Policy based kubernetes admission webhook part 1","uri":"/en/posts/policy-engine/"},{"categories":["kubernetes"],"content":"1.Background Definition Admission webhooks are HTTP callbacks that receive admission requests and do something with them. You can define two types of admission webhooks, validating admission webhook and mutating admission webhook. Mutating admission webhooks are invoked first, and can modify objects sent to the API server to enforce custom defaults. After all object modifications are complete, and after the incoming object is validated by the API server, validating admission webhooks are invoked and can reject requests to enforce custom policies. The above is the definition given by kubernetes. In short, k8s webhooks are divided into two categories validating and mutating for verifying and modifying k8s resource modification operations, respectively. When a user creates or modifies a resource, the apiserver calls (http) the registered validating and mutating webhooks and does not actually process the modification until after the response of these webhooks. Process For those who are familiar with cloud native development or k8s, webhook should be a very familiar component and should have written more or less relevant code. As a native capability of k8s, the current webhook development/use approach is very unfriendly and primitive. While many of the k8s capabilities can be achieved by modifying existing objects or CRD information (e.g., updating images, rolling upgrades, etc.), webhook requires code to be developed and registered to the apiserver and run to achieve the purpose. However, in daily development, most of the requirements for webhook are limited to some simple capabilities, such as verifying the fields and legality of certain objects, modifying the information of specific objects (label, annotation or modifying resource specifications, etc.), which leads to the need for development to package and release the code every time new requirements are added or modified. This makes the whole process inefficient, and there are too many webhooks registered in a cluster to make the apiserver’s response time longer and less reliable. In order to solve these problems, we developed a new set of rule-based programmable webhooks – kinitiras, hoping to replace all the webhooks in a cluster with this component and all the requirements. We hope to use this component to replace all the webhooks in the cluster and all the requirements can be solved by this component without developing new webhooks, improving efficiency and reducing the security risks caused by multiple webhooks. ","date":"2023-02-01","objectID":"/en/posts/policy-engine/:1:0","tags":["kubernetes","policy-engine","webhook"],"title":"Policy based kubernetes admission webhook part 1","uri":"/en/posts/policy-engine/"},{"categories":["kubernetes"],"content":"2.Ability Feature overview First, lets talk about what this webhook can do. ","date":"2023-02-01","objectID":"/en/posts/policy-engine/:2:0","tags":["kubernetes","policy-engine","webhook"],"title":"Policy based kubernetes admission webhook part 1","uri":"/en/posts/policy-engine/"},{"categories":["kubernetes"],"content":"2.1 Validate resources Policy example We can configure different policies for different resources to reduce the occurrence of some uncontrollable situations or to restrict some special operations, for example. For create update operations, some fields of the resource can be restricted (not null or with values equal to or not equal to the specified value, etc.) Restrict update or delete operations. For some specific resources (ns or deployment), you can prohibit deletion or secondary confirmation mechanism (deletion is allowed only if the specified annotation exists) Field validation The fields and values of these checks can be the value of the current object or the value of other objects (e.g., compared with other objects such as cm or secret), and the data obtained by third-party http services can be checked. ","date":"2023-02-01","objectID":"/en/posts/policy-engine/:2:1","tags":["kubernetes","policy-engine","webhook"],"title":"Policy based kubernetes admission webhook part 1","uri":"/en/posts/policy-engine/"},{"categories":["kubernetes"],"content":"2.2 Mutate resources Policy example For modifying resources, our strategy can be configured for many different scenarios to meet different needs, such as Uniformly add label or annotation to resources. Modify the pod resource of limit or request. modify the affinity toleration of the resource, etc. The modified values can be dynamic and can be obtained from other objects (e.g., writing the owner’s properties to the pod) or from third-party http services (I have similar needs myself). ","date":"2023-02-01","objectID":"/en/posts/policy-engine/:2:2","tags":["kubernetes","policy-engine","webhook"],"title":"Policy based kubernetes admission webhook part 1","uri":"/en/posts/policy-engine/"},{"categories":["kubernetes"],"content":"3.Design Kinitiras is from the Greek κινητήρας (kini̱tí̱ras), meaning engine/motor, and the core capability of the project is also a rules-based engine that provides efficient and powerful capabilities. ","date":"2023-02-01","objectID":"/en/posts/policy-engine/:3:0","tags":["kubernetes","policy-engine","webhook"],"title":"Policy based kubernetes admission webhook part 1","uri":"/en/posts/policy-engine/"},{"categories":["kubernetes"],"content":"3.1 Basic concept Concept Explain validating Verifying the legitimacy of objects mutating Modifying objects info policy a crd object contains rules override policy policy contains mutate object rules validate policy policy contains validate object rules cue an open source program language，https://cuelang.org ","date":"2023-02-01","objectID":"/en/posts/policy-engine/:3:1","tags":["kubernetes","policy-engine","webhook"],"title":"Policy based kubernetes admission webhook part 1","uri":"/en/posts/policy-engine/"},{"categories":["kubernetes"],"content":"3.2 Core logic Here is the core logic of kinitiras： Define the crd corresponding to validating and mutating to represent a policy, record the scope of the policy (specified resource name or label) and the execution rules (verify or modify the content) register a unified webhook configuration and subscribe to all modification and deletion events for resources with a specific label by default (you can customize this configuration during installation) when receiving a callback from apiserver, the current modified resource and the existing policy match to filter the list of hit policies execute policies in a sequential manner policy engine core logic(step 3 and step 4 had marked reversely) ","date":"2023-02-01","objectID":"/en/posts/policy-engine/:3:2","tags":["kubernetes","policy-engine","webhook"],"title":"Policy based kubernetes admission webhook part 1","uri":"/en/posts/policy-engine/"},{"categories":["kubernetes"],"content":"3.3 Api definition This project has defined three CRD: OverridePolicy: mutate object info(namespace level) ClusterOverridePolicy: mutate object info(cluster level) ClusterValidatePolicy: validate object info(cluster level) Now, lets talk about core part of those CRDs. 3.3.1 Resource selector ResourceSelector the resources will be selected. Field type required Description apiVersion string Y APIVersion represents the API version of the target resources. kind string Y Kind represents the Kind of the target resources. namespace string N Namespace of the target resource. Default is empty, which means inherit from the parent object scope. name string N Name of the target resource. Default is empty, which means selecting all resources. labelSelector Kubernetes meta/v1.LabelSelector N A label query over a set of resources. If name is not empty, labelSelector will be ignored. fieldSelector FieldSelector N A field query over a set of resources. If name is not empty, fieldSelector wil be ignored. This structure is used to select a policy to match a resource, either by specifying a particular resource, or by specifying a label or field to take effect for a group of resources. for example: # match with all the pod which contains label webhook:enabled resourceSelectors: - apiVersion: v1 kind: Pod labelSelector: matchLabels: webhook: enabled 3.3.2 Validate rule Defines validate rules on operations. Field type required Description targetOperations []Kubernetes admission/v1.Operation Y Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or * for all of those operations and any future admission operations that are added. If * is present, the length of the slice must be one. cue string N Cue represents validate rules defined with cue code. template ValidateRuleTemplate N Template of condition which defines validate cond, and it will be rendered to CUE and store in RenderedCue field, so if there are any data added manually will be erased. renderedCue string N RenderedCue represents validate rule defined by Template. Don’t modify the value of this field, modify Rules instead of. Here is the information that defines the execution logic of the validate policy. targetOperations: indicates the type of operation that will take effect, i.e., it can be defined to take effect only for create or delete events cue: This field can be filled with a cue code, which will be executed after the policy is hit, see the following Example template: defines a simple template that templates some common checks (no need to write a cue anymore) renderedCue: the template will eventually be automatically rendered into cue code and stored on this field. cue example： validateRules: # This code means, if object has a label `xxx.io/no-delete:true` then reject the delete operation. - cue: |- object: _ @tag(object) reject: object.metadata.labels != null \u0026\u0026 object.metadata.labels[\"xxx.io/no-delete\"] == \"true\" validate: { if reject{ reason: \"operation rejected\" } if !reject{ reason: \"\" } valid: !reject } targetOperations: - DELETE template example: # It means, it will reject the delete operation if there is a no-delete annotation validateRules: - targetOperations: - DELETE template: type: condition # Only one type now, will extend in the future. condition: affectMode: reject # It means reject the operation if it hit this rule. Can set it to allow to allow the operation only if it hit this rule. cond: Exist # Support Exist, NoExist, In, NotIn, Gt, Lt, etc. message: \"cannot delete this ns\" # message when reject dataRef: # specify the data source from: current # It means get data from current object, also can get it from other object from current cluster. path: \"/metadata/annotations/no-delete\" # data path This templated approach can reduce the cost of learning cue and can satisfy most scenarios such as determining whether a field exists and doing size comparison with other fields. 3.3.3 Override rule Overriders offers various alternatives to","date":"2023-02-01","objectID":"/en/posts/policy-engine/:3:3","tags":["kubernetes","policy-engine","webhook"],"title":"Policy based kubernetes admission webhook part 1","uri":"/en/posts/policy-engine/"},{"categories":["kubernetes"],"content":"4.Implement The above describes how kinitiras works and the core concepts, from here on the implementation of its core capabilities are briefly described, so that it is easy to debug or understand the underlying implementation when using it. Project structure The project as a whole is divided into three repo’s, namely kinitiras, pkg, and pidalio. Each repo is positioned differently, where kinitiras is a more conventional webhook project, responsible for registering itself to the apiserver and handling callbacks, and pkg is the implementation of the core modules, such as api definitions, execution policies, and so on. And pidalio is the transport middleware for client-go, which can intercept requests and execute policy applications on the client side. This article focuses on the core implementation of the first two repo’s. ","date":"2023-02-01","objectID":"/en/posts/policy-engine/:4:0","tags":["kubernetes","policy-engine","webhook"],"title":"Policy based kubernetes admission webhook part 1","uri":"/en/posts/policy-engine/"},{"categories":["kubernetes"],"content":"4.1 kinitiras Repo URL: https://github.com/k-cloud-labs/kinitiras The core logic of this project, as a webhook, is to initialize the parameters and register itself to the apiserver, and then call the unified processing method provided by pkg in the callback function. 4.1.2 Initialize // Run runs the webhook server with options. This should never exit. func Run(ctx context.Context, opts *options.Options) error { klog.InfoS(\"kinitiras webhook starting.\", \"version\", version.Get()) config, err := controllerruntime.GetConfig() if err != nil { panic(err) } config.QPS, config.Burst = opts.KubeAPIQPS, opts.KubeAPIBurst hookManager, err := controllerruntime.NewManager(config, controllerruntime.Options{ // ... set options }) if err != nil { klog.ErrorS(err, \"failed to build webhook server.\") return err } // init clients, informer, lister sm := \u0026setupManager{} if err := sm.init(hookManager, ctx.Done()); err != nil { klog.ErrorS(err, \"init setup manager failed\") return err } if err := sm.waitForCacheSync(ctx); err != nil { klog.ErrorS(err, \"wait for cache sync failed\") return err } if err := sm.setupInterrupter(); err != nil { klog.ErrorS(err, \"setup interrupter failed\") return err } setupCh, err := cert.SetupCertRotator(hookManager, cert.Options{ // ... set options }) if err != nil { klog.ErrorS(err, \"failed to setup cert rotator controller.\") return err } go func() { \u003c-setupCh // register handler here hookServer := hookManager.GetWebhookServer() hookServer.Register(\"/mutate\", \u0026webhook.Admission{Handler: pkgwebhook.NewMutatingAdmissionHandler(sm.overrideManager, sm.policyInterrupterManager)}) hookServer.Register(\"/validate\", \u0026webhook.Admission{Handler: pkgwebhook.NewValidatingAdmissionHandler(sm.validateManager, sm.policyInterrupterManager)}) hookServer.WebhookMux.Handle(\"/readyz\", http.StripPrefix(\"/readyz\", \u0026healthz.Handler{})) }() // blocks until the context is done. if err := hookManager.Start(ctx); err != nil { klog.ErrorS(err, \"webhook server exits unexpectedly.\") return err } // never reach here return nil } The above code is quite conventional, only sm.setupInterrupter() is mentioned separately. The webhook defines several CRDs as the carrier of the policy, and the policy itself needs to be verified and modified, especially after providing a template (template), which needs to be rendered into a cue script, so the concept of interrupter is introduced in order to be able to verify and render the policy when it is created. Interrupter, as the name suggests – an interceptor, is used to intercept the policy and perform checks on specific fields of the policy and rendering of the template, these logic is not quite the same as the regular object checks and modifications, so it does not go through the ordinary logic, but only through the logical part of interrupter. And the above sm.setupInterrupter() is used to initialize these interrupters with the following code. func (s *setupManager) setupInterrupter() error { // Init template -- render template is implemented based on go tmpl. otm, err := templatemanager.NewOverrideTemplateManager(\u0026templatemanager.TemplateSource{ Content: templates.OverrideTemplate, TemplateName: \"BaseTemplate\", }) if err != nil { klog.ErrorS(err, \"failed to setup mutating template manager.\") return err } // validate template same as above. vtm, err := templatemanager.NewValidateTemplateManager(\u0026templatemanager.TemplateSource{ Content: templates.ValidateTemplate, TemplateName: \"BaseTemplate\", }) if err != nil { klog.ErrorS(err, \"failed to setup validate template manager.\") return err } // base baseInterrupter := interrupter.NewBaseInterrupter(otm, vtm, templatemanager.NewCueManager()) // op overridePolicyInterrupter := interrupter.NewOverridePolicyInterrupter(baseInterrupter, s.tokenManager, s.client, s.opLister) // register interrupter to manager s.policyInterrupterManager.AddInterrupter(schema.GroupVersionKind{ Group: policyv1alpha1.SchemeGroupVersion.Group, Version: policyv1alpha1.SchemeGroupVersion.Version, Ki","date":"2023-02-01","objectID":"/en/posts/policy-engine/:4:1","tags":["kubernetes","policy-engine","webhook"],"title":"Policy based kubernetes admission webhook part 1","uri":"/en/posts/policy-engine/"},{"categories":["kubernetes"],"content":"4.2 pkg Repo URL: https://github.com/k-cloud-labs/pkg The pkg contains most of the logic implementation, as well as the definition of the crd and the generated client code. Following the above, we will focus on the implementation of interrupter and the hitting and execution of the policy. 4.2.1 interrupter definition: // PolicyInterrupterManager manage multi PolicyInterrupter and decide which one to use by gvk. type PolicyInterrupterManager interface { PolicyInterrupter // AddInterrupter add a PolicyInterrupter to manager, // it will replace interrupter if already add with same gvk.s AddInterrupter(gvk schema.GroupVersionKind, pi PolicyInterrupter) } // PolicyInterrupter defines interrupt process for policy change // It validate and mutate policy. type PolicyInterrupter interface { // OnMutating called on \"/mutating\" api to complete policy // return nil means obj is not defined policy OnMutating(obj, oldObj *unstructured.Unstructured, operation admissionv1.Operation) ([]jsonpatchv2.JsonPatchOperation, error) // OnValidating called on \"/validating\" api to validate policy // return nil means obj is not defined policy or no invalid field OnValidating(obj, oldObj *unstructured.Unstructured, operation admissionv1.Operation) error // OnStartUp called when webhook process initialize // return error if initial phase get any error OnStartUp() error } PolicyInterrupterManager inherits from PolicyInterrupter and adds a method to add interrupters to manage multiple interrupters, and each interrupter implements the following three methods. OnMutating: Called when the apiserver calls back the /mutating interface, mainly to render and supplement policy information OnValidating: called when the apiserver calls back the /validating interface, mainly to validate policy information OnStartUp: called during the webhook startup phase to do some initialization work (pulling cache, etc.) The implementation of manager is different from the actual interrupter, it first identifies if the current resource is the policy crd we defined, then looks for a corresponding registered interrupter from memory and calls the corresponding method of that interrupter. The code is as follows. type policyInterrupterManagerImpl struct { interrupters sync.Map } func (p *policyInterrupterManagerImpl) OnValidating(obj, oldObj *unstructured.Unstructured, operation admissionv1.Operation) error { if interrupter := p.getInterrupter(obj); interrupter != nil { return interrupter.OnValidating(obj, oldObj, operation) } return nil } func (p *policyInterrupterManagerImpl) getInterrupter(obj *unstructured.Unstructured) PolicyInterrupter { if !p.isKnownPolicy(obj) { klog.V(5).InfoS(\"unknown policy\", \"gvk\", obj.GroupVersionKind()) return nil } i, ok := p.interrupters.Load(obj.GroupVersionKind()) if ok { klog.V(4).InfoS(\"sub interrupter found\", \"gvk\", obj.GroupVersionKind()) return i.(PolicyInterrupter) } return nil } func (p *policyInterrupterManagerImpl) isKnownPolicy(obj *unstructured.Unstructured) bool { group := strings.Split(obj.GetAPIVersion(), \"/\")[0] return group == policyv1alpha1.SchemeGroupVersion.Group } 4.2.2 Render The matter of rendering has been mentioned few times before, now lets talk about it. About background. The project has supported the user to write cue by hand to execute complex logic in the strategy to meet different needs in the early days. However, writing cue requires some knowledge of the syntax and features of the language and there is no good mechanism to verify the legitimacy of cue scripts, which makes it difficult to get started, so we came up with the idea of abstracting some common cases into a structured template, where the user only needs to fill in the necessary parameters, and webhook itself translates the template into cue scripts. To be able to translate structured data into cue scripts, we wrote a more complex go/tmpl ([template link](https://github.com/k-cloud-labs/pkg/tree/main/utils/templatemanager/ templates)), and then proceeded to transl","date":"2023-02-01","objectID":"/en/posts/policy-engine/:4:2","tags":["kubernetes","policy-engine","webhook"],"title":"Policy based kubernetes admission webhook part 1","uri":"/en/posts/policy-engine/"},{"categories":["kubernetes"],"content":"5.Summarize This article introduces the webhook product launched by k-cloud-labs, which is excellent in terms of functionality and usability. I am now working as one of the maintainers of the project to add and optimize certain features to the project, and will continue to update new capabilities and solve more problems later. Main content. Introduced the background of developing the webhook and the problem it solves Introduced the core design ideas and api definitions Introduces the implementation of the core logic For more detailed design details and use cases and installation methods, please click here to jump the official website to understand. ","date":"2023-02-01","objectID":"/en/posts/policy-engine/:5:0","tags":["kubernetes","policy-engine","webhook"],"title":"Policy based kubernetes admission webhook part 1","uri":"/en/posts/policy-engine/"},{"categories":["kubernetes"],"content":"6.Links🔗 Official Website: https://k-cloud-labs.github.io/kinitiras-doc/ Github: https://github.com/k-cloud-labs ","date":"2023-02-01","objectID":"/en/posts/policy-engine/:6:0","tags":["kubernetes","policy-engine","webhook"],"title":"Policy based kubernetes admission webhook part 1","uri":"/en/posts/policy-engine/"},{"categories":["New Area"],"content":" Trying to write blog with English and Chinese at same time to make it more international and more readers can benefit from it. ","date":"2022-12-21","objectID":"/en/posts/start-up/:0:0","tags":["other"],"title":"Start to write with English","uri":"/en/posts/start-up/"},{"categories":null,"content":"Hi, My name is Yusan Kurban and I’m a software engineer. MicroServices, Service Architecture, Service Management. Working on Kubernetes component, gateway and HPA. Fully experience on highly available services. Love to share knowledge and codes. How to get in touch with me? Email: yusankurban@gmail.com Location: Beijing/China WeChatID: yusank77 WeChatOfficialAccount ","date":"2020-03-09","objectID":"/en/about/:0:0","tags":null,"title":"About me","uri":"/en/about/"}]