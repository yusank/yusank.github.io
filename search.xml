<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Unix 网络编程]]></title>
      <url>http://yusank.github.io/Unix-Network.html/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="Unix-网络编程"><a href="#Unix-网络编程" class="headerlink" title="Unix 网络编程"></a>Unix 网络编程</h1><p>​                                                                        <strong>卷II - 进程间通信</strong></p>
<p>IPC是进程间通信（interprocess communication）的简称。传统上该术语描述的是运行在某个操作系统之上的不同进程间各种消息传递（<em>message passing</em>）的方式。</p>
<p>进程间的通信一般是一下四种形式：</p>
<ul>
<li>消息传递（管道、FIFO和消息队列）；</li>
<li>同步（互斥量、条件变量、读写锁、文件和记录锁、信号量）；</li>
<li>共享内存（匿名的和具名的）；</li>
<li>远程过程调用（Solaris 门和 Sun RPC）。</li>
</ul>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p><strong>消息传递：</strong></p>
<ul>
<li><p>管道和FIFO；</p>
</li>
<li><p>Posix 消息队列；</p>
</li>
<li><p>System V消息队列。</p>
<p>​</p>
</li>
</ul>
<h2 id="管道和FIFO"><a href="#管道和FIFO" class="headerlink" title="管道和FIFO"></a>管道和FIFO</h2><p>管道是最初的Unix IPC 形式。由于管道没有名字，所以它只能用于有亲缘关系的进程间的通信。</p>
<p><strong>实现机制：</strong></p>
<p>管道是由内核管理的一个缓冲区，相当于我们放入内存中的一个纸条。管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它<strong>被设计成为环形的数据结构</strong>，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span> <span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span></div><div class="line">  						<span class="comment">//返回：若成功返回0，若出错返回-1</span></div></pre></td></tr></table></figure>
<p>该函数返回两个文件描述符：fd[0] 和 fd[1]。前者打开来读，后者打开来写。</p>
<p>管道尽管是单个进程创建，但是管道的典型用途是为两个不同的进程（一个父进程，一个子进程）提供进程间的通信手段。</p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/Screen%20Shot%202017-02-22%20at%2011.49.01%20AM.png" alt="Screen Shot 2017-02-22 at 11.49.01 AM"></p>
<p>​                                             数据流 &gt;&gt;&gt;&gt;&gt;&gt;</p>
<p>首先是，由一个进程（它将成为父进程）创建一个 pipe 后调用 fork 派生一个自身的副本，接着关闭着个 pipe 的读成端，子进程关闭同一个 pipe 的写入端。这就是进程间提供了一个单向数据流，如下图。</p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/Screen%20Shot%202017-02-22%20at%2011.56.11%20AM.png" alt="Screen Shot 2017-02-22 at 11.56.11 AM"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</div><div class="line">    <span class="keyword">pid_t</span> pid;</div><div class="line">    <span class="keyword">char</span> line[MAXLINE];</div><div class="line">   </div><div class="line">    <span class="keyword">if</span>(pipe(fd) === <span class="number">0</span>)&#123;                 <span class="comment">/* 先建立管道得到一对文件描述符 */</span></div><div class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)            <span class="comment">/* 父进程把文件描述符复制给子进程 */</span></div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;                <span class="comment">/* 父进程写 */</span></div><div class="line">        close(fd[<span class="number">0</span>]);                <span class="comment">/* 关闭读描述符 */</span></div><div class="line">        write(fd[<span class="number">1</span>], <span class="string">"\nhello world\n"</span>, <span class="number">14</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;                            <span class="comment">/* 子进程读 */</span></div><div class="line">        close(fd[<span class="number">1</span>]);                <span class="comment">/* 关闭写端 */</span></div><div class="line">        n = read(fd[<span class="number">0</span>], line, MAXLINE);</div><div class="line">        write(STDOUT_FILENO, line, n);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>technically，自从可以在进程间传递描述符后，管道也能用于无亲缘关系的进程间，而现实中管道通常用于具有共同祖先的进程间。</em></p>
<p><strong>FIFO：命名管道(named PIPE)</strong></p>
<p>管道尽管对很多操作来说是很有用的，但是它的根本局限性在于没有名字，从而只能由亲缘关系的进程（父子进程）使用。为了解决这一问题，Linux提供了FIFO方式连接进程。有了FIFO之后这一缺点得以改正。FIFO有时也称之为有名管道（named pipe）。FIFO除了有管道的功能外，它还允许无亲缘关系的进程的通信。pipe 和 FIFO 都是使用通常的 read 和 write 函数访问的。</p>
<p>FIFO (First in, First out)为一种特殊的文件类型，它在文件系统中有对应的路径。当一个进程以读(r)的方式打开该文件，而另一个进程以写(w)的方式打开该文件，那么内核就会在这两个进程之间建立管道，所以FIFO实际上也由内核管理，不与硬盘打交道。之所以叫FIFO，是因为管道本质上是一个先进先出的队列数据结构，最早放入的数据被最先读出来，从而保证信息交流的顺序。FIFO只是借用了文件系统(file system,命名管道是一种特殊类型的文件，因为Linux中所有事物都是文件，它在文件系统中以文件名的形式存在。)来为管道命名。写模式的进程向FIFO文件中写入，而读模式的进程从FIFO文件中读出。当删除FIFO文件时，管道连接也随之消失。<strong>FIFO的好处在于我们可以通过文件的路径来识别管道，从而让没有亲缘关系的进程之间建立连接</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line">												<span class="comment">// 返回： 成功返回0，出错返回 -1</span></div></pre></td></tr></table></figure>
<p>其中 <em>pathname</em> 是一个普通的 Unix 路径名，它是该 FIFO 的名字。</p>
<p>mkfifo 函数中参数 <em>mode</em> 指定 FIFO 的读写权限。</p>
<p>mkfifo 函数是要么创建一个新的 FIFO ，要么返回一个 EEXIST 错误（如果该 FIFO 已存在），如果不希望创建一个新的 FIFO 那就用 open 函数就可以。</p>
<p>FIFO 不能打开既写又读。</p>
<p>如果一个 FIFO 只读不写，只写不读都会形成阻塞。</p>
<p>下边是一个简单地例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span>  </span></div><div class="line">      </div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> FIFO1  <span class="meta-string">"/tmp/my_fifo"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> res = mkfifo(<span class="string">"/tmp/my_fifo"</span>, <span class="number">0777</span>);  </div><div class="line">    <span class="keyword">if</span> (res == <span class="number">0</span>)  </div><div class="line">    &#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"FIFO created/n"</span>);  </div><div class="line">    &#125;  </div><div class="line">  <span class="comment">/*打开FIFO*/</span></div><div class="line">  <span class="comment">//writefd = Open(FIFO1, O_WRONLY | O_NONBLOCK, 0)	</span></div><div class="line">  <span class="comment">//readfd = Open(FIFO1, O_RDONLY, 0)</span></div><div class="line">     <span class="built_in">exit</span>(EXIT_SUCCESS);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>open</em> 第二个参数中的选项O_NONBLOCK，选项O_NONBLOCK表示非阻塞，加上这个选项后，表示open调用是非阻塞的，如果没有这个选项，则表示open调用是阻塞的。</p>
<ul>
<li>对于以只读方式（O_RDONLY）打开的FIFO文件，如果open调用是阻塞的（即第二个参数为O_RDONLY），除非有一个进程以写方式打开同一个FIFO，否则它不会返回；如果open调用是非阻塞的的（即第二个参数为O_RDONLY|O_NONBLOCK），则即使没有其他进程以写方式打开同一个FIFO文件，open调用将成功并立即返回。</li>
<li>对于以只写方式（O_WRONLY）打开的FIFO文件，如果open调用是阻塞的（即第二个参数为O_WRONLY），open调用将被阻塞，直到有一个进程以只读方式打开同一个FIFO文件为止；如果open调用是非阻塞的（即第二个参数为O_WRONLY|O_NONBLOCK），open总会立即返回，但如果没有其他进程以只读方式打开同一个FIFO文件，open调用将返回-1，并且FIFO也不会被打开。</li>
</ul>
<p>关于管道或 FIFO 的读写的若干规则：</p>
<ul>
<li>如果请求读出的数据量多于管道或 FIFO 中当前的可用数据量，那么只会返回这些可用的数据。</li>
<li>如果请求你写入的数据的字节数小于或等于 PIPE_BUF (可原子地写入往一个管道或 FIFO 的最大数据量， Posix 要求至少为512)，那么 write 操作保证是原子的。这意味着，如果两个进程差不多同时往同一个管道或 FIFO 写，那么不管是先写入来自第一个进程的所有数据再写第二个，还是顺序颠倒过来。系统都不会相互混杂来自两个进程的数据。然而如果数据的字节数大于 PIPE_BUF ，那么 write 操作不能保证是原子的。</li>
<li>不止以上这些。。。</li>
</ul>
<p><strong>小结</strong>： FIFO 与管道类似，但是它用 mkfifo 创建，之后需要open 打开。打开管道必须小心，因为许多规则（read 只写管道、write 只读管道、从空的管道或FIFO read 等的情况的返回结果。）制约着 open 的阻塞与否。</p>
<h2 id="Posix-IPC"><a href="#Posix-IPC" class="headerlink" title="Posix IPC"></a>Posix IPC</h2><p>Posix–可移植性操作系统接口（Protable operating system interface）</p>
<p>有关Unix标准化的大多数活动是由 Posix 和 Open Group 做的。</p>
<p>Posix 不是单一的标准，是一系列的标准。</p>
<p>以下三种类型的IPC合成为“Posix IPC”</p>
<ul>
<li>Posix 消息队列</li>
<li>Posix 信号量</li>
<li>Posix 共享内存区</li>
</ul>
<h2 id="Posix-消息队列"><a href="#Posix-消息队列" class="headerlink" title="Posix 消息队列"></a>Posix 消息队列</h2><p>消息队列可认为是个消息链表。有足够写权限的进程可往队列放置信息，有足够读权限的进程可从队列读取信息。每一个信息都是一条记录，它是由发送者赋予一个优先级。在某个进程往一个队列写入消息之前，并不需要另一个进程在该队列上等待消息的到达。这根管道和 FIFO 是相反的。</p>
<p>一个进程可以往某些队列写入一些信息，然后终止，再让另外一个进程在以后的某个时刻读取这些信息。</p>
<p>Posix 消息队列和下面讲的System V 消息队列有许多的相似性。以下是主要的差别：</p>
<ul>
<li>对 Posix 消息队列的读总是返回最高优先级的最早消息，对 System V 消息队列的读则可以返回任意指定优先级的消息；</li>
<li>当往一个空队列放置一个信息时，Posix 消息队列允许产生一个信号或启动一个线程，System V消息队列则是不提供类似的机制。</li>
</ul>
<p>队列中的每一个消息都有如下属性：</p>
<ul>
<li>一个无符号整数优先级（Posix）或 一个长整数类型（system V）；</li>
<li>消息的数据部分长度（可以为0）；</li>
<li>数据本身（如果长度大于0）。</li>
</ul>
<p>一个消息队列的可能布局。</p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/unix%20%E7%BD%91%E7%BB%9C.png" alt="unix 网络"></p>
<p>我们所设想的是一个链表，该链表的有中含有当前队列的两个属性：队列中允许的最大开销数以及每一个消息的最大大小。</p>
<p><strong>mq_open ,mq_close 和 mq_unlink 函数 </strong>：</p>
<p>mq_open 函数创建一个新的消息队列或打开一个已存在的消息队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></div><div class="line"><span class="keyword">mqd_t</span> mq_open (<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> oflag, ...</div><div class="line">              <span class="comment">/* mode_t mode, struct mq_attr *attr  */</span>);</div><div class="line">							<span class="comment">//返回： 成功返回消息对列描述符，出错返回-1</span></div></pre></td></tr></table></figure>
<p>其中 <em>name</em> 有自己的一套命名规则，因为 Posix IPC 使用“Posix IPC 名字”进行标识。为方便于移植起见，Posix IPC 名字必须以斜杠符开头并且不能再包含任何斜杠符。</p>
<p><em>oflag</em> 是O_RDONLY、O_WRONLY 或     O_RDWR 之一， 可能按位或上O_CREATE(若不存在则创建)、O_EXCL(与O_CREATE一起，若已存在返回EEXIST 错误)或 O_NONBLOCK（非阻塞标识符）。</p>
<p>当实际操作创建一个新的消息队列时（指定O_CREATE标志，且请求的队列不存在），<em>mode</em> 和 <em>attr</em> 参数是需要的。mode上面介绍过。attr参数用于给新队列指定某些属性。</p>
<p>mq_open 返回值称为<strong>消息队列描述符（message queue descriptor）</strong>，这个值用作其他消息队列函数的第一参数。</p>
<p>已打开的消息队列是由 mq_close 关闭的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_close</span><span class="params">(<span class="keyword">mqd_t</span> mqdes)</span></span></div><div class="line">  													<span class="comment">//返回： 成功返回0，出错返回-1</span></div></pre></td></tr></table></figure>
<p>关闭之后调用进程不再使用该描述符，但其消息队列并不从系统中删除。一个进程终止时，它打开着的消息队列都关闭，就像调用mq_close 一样。</p>
<p>要从系统中删除消息队列则用mq_unlink 函数，其第一参数为 mq_open 的第一参数 <em>name</em>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></div><div class="line">												<span class="comment">//返回： 成功返回0，出错返回-1</span></div></pre></td></tr></table></figure>
<p><strong>mq_getattr 和 mq_setattr 函数</strong></p>
<p>消息队列有四个属性，这两个函数是获取和修改这些属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mq_flags		<span class="comment">//队列阻塞标志位</span></div><div class="line">mq_maxmsg		<span class="comment">//队列最大允许消息数</span></div><div class="line">mq_msgsize		<span class="comment">//队列消息最大字节数</span></div><div class="line">mq_curmsgs		<span class="comment">//队列当前消息条数</span></div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_getattr</span><span class="params">(<span class="keyword">mqd_t</span> mqdes,<span class="keyword">struct</span> mq_attr *attr)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_setattr</span><span class="params">(<span class="keyword">mqd_t</span> mqdes,<span class="keyword">const</span> <span class="keyword">struct</span> mq_attr *attr, <span class="keyword">struct</span> mq_attr *oattr)</span></span>;</div><div class="line">												<span class="comment">//返回：均成功返回0，出错返回-1</span></div></pre></td></tr></table></figure>
<p><strong>mq_send 和 mq_receive 函数</strong></p>
<p>​    这两个函数分别往一个队列放置一个信息和从一个队列取走一个消息。每一个消息都有优先级，它是一个小于MQ_PRIO_MAX 的无符号整数。Posix要求这个上限至少为32.</p>
<p>​    mq_receive 总是返回所指定队列中优先级最高的的最早消息，而且该优先级能随该消息的内容及其长度一同返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_send</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> prio)</span></span>;</div><div class="line">											<span class="comment">//返回： 成功返回0，出错返回-1</span></div><div class="line"><span class="keyword">ssize_t</span> mq_reccevie(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> *priop);</div><div class="line">											<span class="comment">//返回： 成功返回消息中的字节数，出错返回-1</span></div></pre></td></tr></table></figure>
<p>mq_receive 的 <em>len</em> 参数的值不能小于能加到所指定队列中的最大大小（该队列 mq_attr 结构的 mq_msgsize ）。要是 <em>len</em> 小于该值， mq_receive立即返回 EMSGSIZE 错误。</p>
<p>mq_send 的 <em>prio</em> 参数是待发信息的优先级，其值必须小于 MQ_PRIO_MAX 。如果 mq_receive 的 <em>priop</em> 参数是一个非空指针，所返回消息的优先级就通过该指针存放。如果应用不必使用优先级不同的消息，那就给mq_send 指针值为0的优先级，给 mq_receive 指定一个空指针作为其最后一个参数。</p>
<p>往某个队列中增加一个消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">mqd_t</span>		mqd;		<span class="comment">//描述符</span></div><div class="line">  <span class="keyword">void</span>		*ptr;		<span class="comment">//指向缓冲区的指针</span></div><div class="line">  <span class="keyword">size_t</span>	len;		<span class="comment">//长度</span></div><div class="line">  <span class="keyword">uint_t</span>	prio;		<span class="comment">//优先度</span></div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (argc != <span class="number">4</span>)</div><div class="line">    err_quit(<span class="string">"usage: mqsend &lt;name&gt; &lt;#bytes&gt; &lt;priority&gt;"</span>);</div><div class="line">  len = atoi(argv[<span class="number">2</span>]);</div><div class="line">  prio = atoi(argv[<span class="number">3</span>]);</div><div class="line">  </div><div class="line">  mqd = Mq_open(argv[<span class="number">1</span>], O_WRONLY);	<span class="comment">// 创建一个消息队列</span></div><div class="line">  </div><div class="line">  ptr = Calloc(len, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">// 所用的缓冲区用colloc分配，该函数会把该缓冲区初始化为0</span></div><div class="line">  Mq_send(mqd, ptr, len, prio);</div><div class="line">  </div><div class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>待发消息的大小和优先级必须作为命令行参数指定。</p>
<p>从某队列读出下一个信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unpipc.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> 		c,flags;</div><div class="line">  <span class="keyword">mqd_t</span>		maq;</div><div class="line">  <span class="keyword">ssize_t</span>	n;</div><div class="line">  <span class="keyword">uint_t</span>	prio;</div><div class="line">  <span class="keyword">void</span>		*buff;</div><div class="line">  <span class="keyword">struct</span>	mq_attr	attr;</div><div class="line">  </div><div class="line">  flags = O_RDONLY;</div><div class="line">  <span class="keyword">while</span> ( (c = Getopt(argc, argv, <span class="string">"n"</span>)) != <span class="number">-1</span>) &#123;</div><div class="line">    <span class="keyword">switch</span> (c) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">'n'</span>:</div><div class="line">        flags |= O_NONBLOCK;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (optind != argc - <span class="number">1</span>)</div><div class="line">    err_quit(<span class="string">"usage: mqreceive [-n] &lt;name&gt;"</span>);</div><div class="line">  </div><div class="line">  mqd =Mq_open(argv[optind], flags);</div><div class="line">  Mq_getattr(mqd, &amp;attr);</div><div class="line">  </div><div class="line">  buff = Malloc(attr.mq_msgsize);</div><div class="line">  </div><div class="line">  n = Mq_receive(mqd, buff, attr.mq_msgsize, &amp;prio);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"read %ld bytes, priority = %u\n"</span>, (<span class="keyword">long</span>) n, prio);</div><div class="line">  </div><div class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>命令行选项 -n 指定非阻塞属性，这样如果所指定的队列中没有消息， 则返回一个错误。</p>
<p>调用 mq_getattr 打开队列并取得属性。需要确定最大消息大小，因为必须为调用的 mq_receive 分配一个这样大小的缓冲区。最后输出所读出消息的大小及其属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">solaris %mqcreate /test1							创建并获取属性</div><div class="line">solaris %mqgetattr /test1</div><div class="line">max</div><div class="line"></div><div class="line">solaris % mqsend /test1 100 9999					以无效的优先级发送</div><div class="line">mq_send error: Invalid argument</div><div class="line"></div><div class="line">solaris % mqsend /test1 100 6						100字节，优先级6 </div><div class="line">solaris % mqsend /test1 50 18 						50字节，优先级18</div><div class="line">solaris % mqsend /test1 33 18 						33字节，优先级18</div><div class="line"></div><div class="line">solaris % mqreceive /test1</div><div class="line">read 50 bytes, priority = 18						返回优先级最高的最早消息</div><div class="line">solaris % mqreceive /test1</div><div class="line">read 33 bytes, priority = 18</div><div class="line">solaris % mqreceive /test1</div><div class="line">read 100 bytes, priority = 6</div><div class="line">solaris % mqreceive /test1							指定非阻塞属性，队列为空</div><div class="line">mq_recevie error: Resource temporarily unavalibale</div></pre></td></tr></table></figure>
<p>消息队列限制：</p>
<ul>
<li>mq_mqxmsg            队列的最大消息数</li>
<li>mq_msgsize                  给定消息的最大字节数</li>
<li>MQ_OPEN_MAX            一个进程能够同时拥有的打开着消息队列的组大数目（Posix要求至少为8）</li>
<li>MQ_PRIO_MAX             任意消息的最大优先级值加1（Posix要求至少为32）</li>
</ul>
<p><strong>mq_notify 函数</strong></p>
<p>Posix 消息队列允许异步事件通知（ <em>asynchronous event notifiction</em>），以告知何时有一个消息放置到了某个空消息队列中。</p>
<h2 id="System-V-消息队列"><a href="#System-V-消息队列" class="headerlink" title="System V 消息队列"></a>System V 消息队列</h2><p>以下三种类型的IPC称为 System V IPC：</p>
<ul>
<li>System V 消息队列；</li>
<li>System V 信号量；</li>
<li>System V 共享内存区。</li>
</ul>
<p>这个称为作为这三个IPC机制的通称是因为它们源自 System V Unix 。这三种IPC最先出现在AT&amp;T System v UNIX上面，并遵循XSI标准，有时候也被称为XSI IPC。</p>
<p>System V 消息队列使用<em>消息队列标识符（message queue identifier）</em> 标识。有足够权限的任何进程可往队列放置信息，有足够权限的任何进程可从队列读取信息。跟 Posix 一样，在某个进程往一个队列写入消息之前，不求另外某个进程正在等待该队列上一个消息的到达。</p>
<p>对于系统的每个消息队列，内核维护一个定义在 <code>&lt;sys/msg.h&gt;</code>  头文件中的信息结构.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> msqid_ds &#123;</div><div class="line">    <span class="keyword">struct</span> ipc_perm 	msg_perm   <span class="comment">//operation permission structure</span></div><div class="line">    <span class="keyword">struct</span> msg			*msg_frist <span class="comment">//ptr to frist message on queue</span></div><div class="line">    <span class="keyword">struct</span> msg			*msg_last  <span class="comment">//ptr to last message on queue</span></div><div class="line">    <span class="keyword">msglen_t</span>			msg_cbytes <span class="comment">//current #bytes on queue</span></div><div class="line">    <span class="keyword">msgqnum_t</span>       	msg_qnum   <span class="comment">//number of messages currently on queue</span></div><div class="line">    <span class="keyword">msglen_t</span>        	msg_qbytes <span class="comment">//maximum number of bytes allowed on queue</span></div><div class="line">    <span class="keyword">pid_t</span>           	msg_lspid  <span class="comment">//process ID of last msgsnd()</span></div><div class="line">    <span class="keyword">pid_t</span>           	msg_lrpid  <span class="comment">//process ID of last msgrcv()</span></div><div class="line">    <span class="keyword">time_t</span>          	msg_stime  <span class="comment">//time of last msgsnd()</span></div><div class="line">    <span class="keyword">time_t</span>          	msg_rtime  <span class="comment">//time of last msgrcv()</span></div><div class="line">    <span class="keyword">time_t</span>          	msg_ctime  <span class="comment">//time of last change</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>Unix 98 不要求有 msg_frist、msg_last 和 msg_cbytes 成员。然而普通的源自 <a href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/sysmsg.h.html" target="_blank" rel="external">System V</a> 的实现中可以找到这三个成员。就算提供了这两个指针，那么它们指向的是内核内存空间，对于应用来说基本没有作用的。</em></p>
<p><img src="http://oid1xlj7h.bkt.clouddn.com/unix%20%E7%BD%91%E7%BB%9C%20%281%29.png" alt="unix 网络 (1)"></p>
<p>我们可以将内核中某个特定的消息队列画为一个消息链表，如图。</p>
<p><strong>msgget 函数</strong></p>
<p>msgget 函数用于创建一个新的消息队列或访问一个已存在的消息队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span> <span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> oflag)</span>	</span></div><div class="line">  											<span class="comment">//返回： 成功返回非负标识符，出错返回-1</span></div></pre></td></tr></table></figure>
<p>返回值是一个整数标识符，其他三个msg函数就用它来指代该队列。</p>
<p>oflag是读写权限的组合。（稍微复杂。。。）</p>
<p>当创建一个新的消息队列的时，msqid_ds 结构的如下成员被初始化。</p>
<ul>
<li><p>msg_perm 结构的 uid 和 cuid 成员被设置成当前进程的有效用户ID，gid 和 cgid 成员被设置成当前的进程的有效组ID。</p>
</li>
<li><p>oflag 中的读写权限位存放在msg_perm.mode 中。</p>
</li>
<li><p>msg_qnum、msg_lspid，msg_lrpid、msg_stime 和 msg_rtime 被设置为0.</p>
</li>
<li><p>msg_ctime 被设置为当前时间。</p>
</li>
<li><p>msg_qbytes 被设置成系统限制值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> ipc_perm</div><div class="line">&#123;</div><div class="line"><span class="keyword">key_t</span>        		key;            <span class="comment">/*调用shmget()时给出的关键字*/</span></div><div class="line"><span class="keyword">uid_t</span>           	uid;            <span class="comment">/*共享内存所有者的有效用户ID */</span></div><div class="line"><span class="keyword">gid_t</span>          		gid;            <span class="comment">/* 共享内存所有者所属组的有效组ID*/</span> </div><div class="line"><span class="keyword">uid_t</span>          		cuid;           <span class="comment">/* 共享内存创建 者的有效用户ID*/</span></div><div class="line"><span class="keyword">gid_t</span>         		cgid;           <span class="comment">/* 共享内存创建者所属组的有效组ID*/</span></div><div class="line"><span class="keyword">mode_t</span>			   	mode;    		<span class="comment">/* Permissions + SHM_DEST和SHM_LOCKED标志*/</span></div><div class="line"><span class="keyword">ulong_t</span>		    	seq;          	<span class="comment">/* 序列号*/</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<p><strong>msgsnd 函数</strong></p>
<p>使用 msgget 函数打开一个消息队列后，使用 msgsnd 函数往其上放置一个消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *ptr,<span class="keyword">size_t</span> length, <span class="keyword">int</span> flag)</span></span>;</div></pre></td></tr></table></figure>
<p>其中msqid 是由msgget 函数返回的标识符。ptr 是一个结构指针，该结构具有如下的模板：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> msgbuf &#123;</div><div class="line"> 	<span class="keyword">long</span> 	mtype;			<span class="comment">/*message type ,must be &gt; 0*/</span></div><div class="line"> 	<span class="keyword">char</span>	mtext[<span class="number">1</span>]		<span class="comment">/*message data*/</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><em>消息类型必须大于0，因为对于 msgrcv 函数来说，非正的消息类型用作特殊的指示器。</em></p>
<p><em>mtext虽然起名是 text ，但是消息类型并不局限于文本。任何形式的数据都是允许的。内核根本不解释消                      息数据的内容。ptr 所指向的是一个含有消息类型的长整数，消息本身则紧跟着它之后。</em></p>
<p>msgsnd 的 <em>length</em> 参数以字节为单位指定待发送消息的长度。是用户自定义的，可以是0.</p>
<p><em>flag</em> 参数既可以是0，也可以是IPC_NOWAIT 。IPC_NOWAIT 标志使得 msgsnd 调用非阻塞：如果没有存放新消息的可用空间，该函数马上返回。这个条件可能发生的情况包括：</p>
<ul>
<li>在指定的队列中已有太多的字节（对应 该队列的msqid_ds 结构中的msg_qbytes 值）；</li>
<li>在系统范围存在太多的消息。</li>
</ul>
<p>如果两个条件一个存在，而且IPC_NOWAIT标志已指定，msgsnd 就返回一个EAGAIN 错误。如果两个条件一个存在，标志未指定，那么调用线程就被投入睡眠，直到：</p>
<ul>
<li>具备存放新消息的空间；</li>
<li>由 msqgid 标识的消息队列从系统中删除（这个情况下回返回一个EIDRM 错误）；</li>
<li>调用线程被某个捕获的信息所中断。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 添加歌单]]></title>
      <url>http://yusank.github.io/testlist.html/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>测试添加歌单。。。。<br><a id="more"></a></p>
<h1 id="测试歌单"><a href="#测试歌单" class="headerlink" title="测试歌单"></a>测试歌单</h1>
			<div id="aplayer2" class="aplayer" style="margin-bottom: 20px;"></div>
			<script>
				var options = {"narrow":false,"autoplay":false,"showlrc":1,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"匆匆那年","author":"王菲","url":"http://oid1xlj7h.bkt.clouddn.com/%E7%8E%8B%E8%8F%B2%20-%20%E5%8C%86%E5%8C%86%E9%82%A3%E5%B9%B4.mp3","lrc":"http://oid1xlj7h.bkt.clouddn.com/ccnn.txt"},{"title":"Toca Toca","author":"Fly project","url":"http://oid1xlj7h.bkt.clouddn.com/Fly%20Project%20-%20Toca%20Toca.mp3"},{"title":"Danzo Kuduro","author":"Don Omar","url":"http://oid1xlj7h.bkt.clouddn.com/Don%20Omar,Lucenzo%20-%20Danza%20Kuduro%20-%20Album%20Version.mp3"},{"title":"难忘的一天","author":"许巍","url":"http://oid1xlj7h.bkt.clouddn.com/%E8%AE%B8%E5%B7%8D%20-%20%E9%9A%BE%E5%BF%98%E7%9A%84%E4%B8%80%E5%A4%A9.mp3","lrc":"http://oid1xlj7h.bkt.clouddn.com/nwdyt.txt"},{"title":"Counting Stars","author":"OneRepublic","url":"http://oid1xlj7h.bkt.clouddn.com/OneRepublic%20-%20Counting%20Stars.mp3"},{"title":"Zoobi Doobi","author":"Sonu Nigam,Shreya Ghoshal","url":"http://oid1xlj7h.bkt.clouddn.com/Sonu%20Nigam,Shreya%20Ghoshal%20-%20Zoobi%20Doobi.mp3","lrc":"http://oid1xlj7h.bkt.clouddn.com/tidoit.txt"}]};
				options.element = document.getElementById("aplayer2");
				new APlayer(options);
			</script>

		]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 博客添加视频和音乐]]></title>
      <url>http://yusank.github.io/HexoMedia.html/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>找到一个炒鸡流弊的东西。。。</p>
<a id="more"></a>
<h1 id="Hexo-博客中插入视频-音乐"><a href="#Hexo-博客中插入视频-音乐" class="headerlink" title="Hexo 博客中插入视频/音乐"></a>Hexo 博客中插入视频/音乐</h1><p>博客中插入音乐/视频，可以让博客的逼格瞬间提高。作为优秀的静态博客，Hexo 当然也少不了这些高大上的功能。</p>
<h2 id="Markdown-通用音乐-视频插入方法"><a href="#Markdown-通用音乐-视频插入方法" class="headerlink" title="Markdown 通用音乐/视频插入方法"></a>Markdown 通用音乐/视频插入方法</h2><p>Markdown 作为轻量级的标记语言，兼容 html 语法，所以可以直接在 Markdown 文档中使用 html 语法。</p>
<p><code>vedio</code> 标签</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"480"</span> <span class="attr">height</span>=<span class="string">"320"</span> <span class="attr">controls</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"movie.mp4"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其中在 <code>src</code> 后面需要替换自己的音乐/视频链接</p>
<p>效果:</p>
<p>​    <video width="480" height="320" controls><br>​    <source src="http://oid1xlj7h.bkt.clouddn.com/WeChatSight72.mp4"><br>​    </video></p>
<h3 id="embed标签"><a href="#embed标签" class="headerlink" title="embed标签"></a><code>embed</code>标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">"http://player.youku.com/player.php/Type/Folder/Fid/27690810/Ob/1/sid/XMTY1MTI3NjMyNA==/v.swf"</span> <span class="attr">quality</span>=<span class="string">"high"</span> <span class="attr">width</span>=<span class="string">"480"</span> <span class="attr">height</span>=<span class="string">"400"</span> <span class="attr">align</span>=<span class="string">"middle"</span> <span class="attr">allowScriptAccess</span>=<span class="string">"always"</span> <span class="attr">allowFullScreen</span>=<span class="string">"true"</span> <span class="attr">mode</span>=<span class="string">"transparent"</span> <span class="attr">type</span>=<span class="string">"application/x-shockwave-flash"</span>&gt;</span><span class="tag">&lt;/<span class="name">embed</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="ifreame标签"><a href="#ifreame标签" class="headerlink" title="ifreame标签"></a><code>ifreame</code>标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">height</span>=<span class="string">498</span> <span class="attr">width</span>=<span class="string">510</span> <span class="attr">src</span>=<span class="string">"http://player.youku.com/embed/XMTY1MTI3NjMyNA=="</span> <span class="attr">frameborder</span>=<span class="string">0</span> <span class="attr">allowfullscreen</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div></pre></td></tr></table></figure>
<p>网易云音乐网页版提供生成 iframe 标签。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://www.xiami.com/widget/player-single?uid=32329501&amp;sid=1776238762&amp;mode=js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>除了 <code>vedio</code> 标签外，大部分音乐/视频网站都可以直接生成播放代码，直接粘贴在 Markdown 文档即可。</p>
<p>不过有些标签不支持 HTTPS。</p>
<h2 id="通过-Hexo-插件插入音频-视频"><a href="#通过-Hexo-插件插入音频-视频" class="headerlink" title="通过 Hexo 插件插入音频/视频"></a>通过 Hexo 插件插入音频/视频</h2><p>这里需要两个播放器插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo-tag-aplayer:https://github.com/grzhan/hexo-tag-aplayer#upstream-issue</div><div class="line"></div><div class="line">hexo-tag-dplayer:https://github.com/NextMoe/hexo-tag-dplayer</div></pre></td></tr></table></figure>
<p>这两款插件基于 DIYgod 编写的 html5 播放器 APlayer 和 DPlayer 开发。</p>
<p>首先安装两款插件</p>
<p>打开 shell，切换到 Hexo 目录下，运行两条目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install hexo-tag-dplayer --save</div><div class="line">npm install hexo-tag-aplayer --save</div></pre></td></tr></table></figure>
<p>安装成功后，在 Markdown 文档中添加 APlayer 和 DPlayer 标签即可。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;% aplayer "Caffeine" "Jeff Williams" "http://7xq131.com1.z0.glb.clouddn.com/Preparation.mp3" "autoplay" %&#125;</div><div class="line">&#123;% dplayer "url=http://devtest.qiniudn.com/若能绽放光芒.mp4" "api=http://dplayer.daoapp.io" "pic=http://devtest.qiniudn.com/若能绽放光芒.png" "id=9E2E3368B56CDBB4" "loop=yes" "theme=#FADFA3" "autoplay=false" "token=tokendemo" %&#125;</div></pre></td></tr></table></figure>
<p>APlayer 和 DPlayer 具体参数设置可以到 GitHub 项目主页，不过默认参数足够了。</p>
<div id="aplayer0" class="aplayer" style="margin-bottom: 20px;">
				<pre class="aplayer-lrc-content">'[00:00.00]Zoobi Doobi
[00:00.38]Sonu Nigam & Shreya Ghoshal
[00:00.53]LRC：Meselson (QQ 445942376)
[00:01.18]
[00:03.50]Gungunati hain yeh hawayein 
[00:12.73]Gungunata hai gagan
[00:19.91]Gaa raha hai yeh saara aalam
[00:26.90]Zoobi do… param pum… 
[00:37.35]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum
[00:42.67]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann 
[00:47.99]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum
[00:53.30]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann 
[00:58.34]Shaakhon pe pattey gaa rahe hain Phoolon pe bhanvre gaa rahe
[01:03.69]Deewani kirine gaa rahi hain Yeh panchhi gaa rahe
[01:08.38]Ohhh Bagiya mein do phoolon ki Ho rahi hai guft-gu 
[01:14.02]Jaisa filmon mein hota hai Ho raha hai hu-bahoo
[01:19.18]I iiii iii.. 
[01:20.11]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum
[01:25.21]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann
[01:30.52]
[01:30.81]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum
[01:35.98]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann
[01:40.68]
[02:02.67]Rimjhim rimjhim rimjhim San san san san hawaa
[02:07.63]Tip tip tip tip boondein Gurrati bijliyaan
[02:13.00]Bheegi bheegi saree mein Yun thumke lagati tu
[02:18.24]Ho raha hai hu bahoo
[02:23.58]I iiii iii.. 
[02:24.23]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum
[02:29.16]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann
[02:32.50]
[02:34.30]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum
[02:39.58]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann
[02:45.70]
[03:06.55]Amber ka chand zameen par Itra ke gaa raha
[03:12.02]Ek tim tim toota tara Ithla ka gaa raha
[03:17.29]Hai raat akeli tanha Mujhe choo le aake tu
[03:22.47]Jaisa filmon mein hota hai Ho raha hai hubahoo
[03:27.24]I iiii iii.. 
[03:27.78]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum
[03:33.28]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann
[03:38.57]Zoobi doobi zoobi doobi pum paara Zoobi doobi param pum
[03:43.79]Zoobi doobi zoobi doobi naache kyun Paagal stupid mann
[03:48.58]LRC：Meselson (QQ 445942376)
[03:50.47]THE END
</pre>
			</div>
			<script>
				new APlayer({
					element: document.getElementById("aplayer0"),
					narrow: false,
					autoplay: 1,
					showlrc: 2,
					music: {
						title: "Zoobi Doobi",
						author: "Three ediot",
						url: "http://oid1xlj7h.bkt.clouddn.com/Sonu%20Nigam,Shreya%20Ghoshal%20-%20Zoobi%20Doobi.mp3",
						pic: "http://oid1xlj7h.bkt.clouddn.com/3_idiots_wallpaper.jpg",
					}
				});
			</script>    
<div id="dplayer0" class="dplayer" style="margin-bottom: 20px;"></div><script>var dplayer0 = new DPlayer({"element":document.getElementById("dplayer0"),"autoplay":false,"theme":"#FADFA3","loop":true,"video":{"url":"http://oid1xlj7h.bkt.clouddn.com/WeChatSight72.mp4"},"danmaku":{"api":"http://dplayer.daoapp.io","id":"9E2E3368B56CDBB4","token":"tokendemo"}});</script>
<p>APlayer 和 DPlayer 均支持 HTTPS。</p>
<p>上述两种方法都有优缺点，选择一种适合自己的方法，打造自己专属的博客吧。</p>
<p>转载：【login926】login926.github.io</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vim 快捷键]]></title>
      <url>http://yusank.github.io/Vimkyboard.html/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="Vim-快捷键"><a href="#Vim-快捷键" class="headerlink" title="Vim 快捷键"></a>Vim 快捷键</h1><h2 id="一-移动："><a href="#一-移动：" class="headerlink" title="一. 移动："></a>一. 移动：</h2><pre><code>h,j,k,l: 左，下，上，右。
w: 下一个词的词首。
e:下一个词的词尾。
</code></pre><p>​    b:上一个词的词首。</p>
<pre><code>&lt;&gt;: v 模式选中后进行缩进。
</code></pre><a id="more"></a>
<div id="aplayer1" class="aplayer" style="margin-bottom: 20px;"></div>
		<script>
			new APlayer({
				element: document.getElementById("aplayer1"),
				narrow: false,
				autoplay: true,
				showlrc: 0,
				music: {
					title: "Wadilar Keni",
					author: "from nobody",
					url: "http://oid1xlj7h.bkt.clouddn.com/elyarr%20-%20wadilar%C2%A0keni%EF%BC%88%E5%90%AC%E4%BA%86%E5%B0%B1%E6%B2%A1%E9%94%99%EF%BC%89.mp3",
					pic: "",
				}
			});
		</script>
<h2 id="二-跳转："><a href="#二-跳转：" class="headerlink" title="二. 跳转："></a>二. 跳转：</h2><pre><code>%: 可以匹配{},&quot;&quot;,(),[]之间跳转。
H、M、L：直接跳转到当前屏幕的顶部、中部、底部。
</code></pre><p>“#H”：跳转到当前屏的第#行。            <em>// 由于markdown语法原因，加上了双引号，实际用的时候没有双引号的</em>, 以下所有加引号的雷同。</p>
<p>“#L”：跳转到当前屏的倒数第#行。</p>
<pre><code>zt: 当前编辑行置为屏顶。
zz: 当前编辑行置为屏中。
zb: 当前编辑行置为屏底。
G：直接跳转到文件的底部。
gg: 跳转到文件首。
():跳转到当前的行首、行尾。
{}：向上、向下跳转到最近的空行。
[{：跳转到目前区块开头。
]}：跳转到目前区块结尾。
0: 跳转到行首。
$: 跳转到行尾。
2$: 跳转到下一行的行尾。
</code></pre><p>“#”：跳转到该行的第#个位置。</p>
<p>“#G”: 15G,跳转到15行。</p>
<pre><code>:#：跳转到#行。
f&apos;n&apos;：跳转到下一个&quot;n&quot;字母后。
ctrl+b: 向后翻一页。
ctrl+f：向前翻一页。
ctrl+u: 向后翻半页。
ctrl+d: 向前翻半页。
ctry+e: 下滚一行。
</code></pre><h2 id="三-选择："><a href="#三-选择：" class="headerlink" title="三. 选择："></a>三. 选择：</h2><pre><code>1.V: 选择一行。
2.^V: 矩形选择。
3.v3w: 选择三个字符。  
</code></pre><h2 id="四-编辑："><a href="#四-编辑：" class="headerlink" title="四. 编辑："></a>四. 编辑：</h2><ol>
<li><p>新增：<br>i: 光标前插入。</p>
<pre><code>I: 在当前行首插入。
a: 光标后插入。
A: 当前行尾插入。
O: 在当前行之前插入新行。
o: 在当前行之后插入新行。
</code></pre></li>
<li><p>修改 c(change) 为主：<br>   r: 替换光标所在处的字符。</p>
<pre><code>R：替换光标所到之处的字符。
cw: 更改光标所在处的字到字尾处。
c#w: c3w 修改3个字符。
C：修改到行尾。
ci&apos;：修改配对标点符号中的文本内容。
di&apos;：删除配对标点符号中的文本内容。
yi&apos;：复制配对标点符号中的文本内容。
vi&apos;：选中配对标点符号中的文本内容。
s：替换当前一个光标所处字符。
</code></pre><p>   ​    “#S”：删除 # 行，并以新文本代替。</p>
</li>
</ol>
<ol>
<li><p>删除 d(delete) 为主：<br>D：删除到行尾。</p>
<pre><code>X: 每按一次，删除光标所在位置的前面一个字符。
x: 每按一次，删除光标所在位置的后面一个字符。
</code></pre><p>​    “#x”: 删除光标所在位置后面6个字符。</p>
<pre><code>d^: 删至行首。
d$: 删至行尾。
dd:(剪切)删除光标所在行。        
dw: 删除一个单词/光标之后的单词剩余部分。
d4w: 删除4个word。
</code></pre><p>​”#dd”: 从光标所在行开始删除#行。</p>
<p>  daB: 删除{}及其内的内容。<br>  diB: 删除{}中的内容。<br>  n1,n2 d：将n1,n2行之间的内容删除。</p>
</li>
<li><p>查找：<br>/： 输入关键字，发现不是要找的，直接在按n，向后查找直到找到为止。</p>
<pre><code>?： 输入关键字，发现不是要找的，直接在按n，向前查找直到找到为止。
*: 在当前页向后查找同一字。
</code></pre><p>​    “#”: 在当前页向前查找同一字。</p>
</li>
<li><p>复制 y(yank)为主：<br>   yw: 将光标所在之处到字尾的字符复制到缓冲区中。</p>
<p>   “#yw”: 复制#个字到缓冲区。</p>
<pre><code>Y：相当于yy, 复制整行。
</code></pre></li>
</ol>
<p>​    “#yy”:表示复制从光标所在的该行往下数#行文字。</p>
<pre><code>    p: 粘贴。所有与y相关的操作必用p来结合粘贴。
    n1,n2 co n3：复制第n1行到第n2行之间的内容到第n3行后面。
6. 大小写转换：
      gUU: 将当前行的字母改为大写。
              guu: 将当前行的字母改为小写。
              gUw: 将当前光标下的单词改为大写。
              guw: 将当前光标下的单词改为小写。
              a. 整篇大写:
              ggguG
              gg: 光标到文件第一个字符。
              gu: 把选择范围全部小写。
              G: 到文件结束。
              b. 整篇小写：gggUG
7. 其它：
      J：当前行和下一行合并成一行。
8. 移动：
      n1,n2 m n3：将n1行到n2行之间的内容移至n3行下。
</code></pre><h2 id="五-退出："><a href="#五-退出：" class="headerlink" title="五.退出："></a>五.退出：</h2><pre><code>1. w filename: 保存正在编辑的文件filename
2. wq filename: 保存后退出正在编辑的文件filename
3. q：退出不保存。
</code></pre><h2 id="六-窗口操作："><a href="#六-窗口操作：" class="headerlink" title="六.窗口操作："></a>六.窗口操作：</h2><pre><code>1. ctrl+w p: 在两个分割窗口之间来回切换。
2. ctrl+w j: 跳到下面的分割窗
3. ctrl+w h: 跳到左边的分割窗。
4. ctrl+w k: 跳到上面的分割窗。
5. ctrl+w l: 跳到右边的分割窗。
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[跨域资源共享 CORS 详解]]></title>
      <url>http://yusank.github.io/CORS.html/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="跨域资源共享-CORS-详解"><a href="#跨域资源共享-CORS-详解" class="headerlink" title="跨域资源共享 CORS 详解"></a>跨域资源共享 CORS 详解</h1><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。<br>它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了AJAX只能<strong>同源</strong>使用的限制。<br>本文详细介绍CORS的内部机制。<br><a id="more"></a></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5110131&auto=1&height=66"></iframe>

<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h2 id="二、两种请求"><a href="#二、两种请求" class="headerlink" title="二、两种请求"></a>二、两种请求</h2><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要同时满足以下两大条件，就属于简单请求。</p>
<blockquote>
<p>1) 请求方法是以下三种方法之一：</p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>（2）HTTP的头信息不超出以下几种字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
</blockquote>
<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<h2 id="三、简单请求"><a href="#三、简单请求" class="headerlink" title="三、简单请求"></a>三、简单请求</h2><h3 id="3-1-基本流程"><a href="#3-1-基本流程" class="headerlink" title="3.1 基本流程"></a>3.1 基本流程</h3><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p>
<p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">/cors</span> HTTP/1.1</div><div class="line"><span class="attribute">Origin</span>: http://api.bob.com</div><div class="line"><span class="attribute">Host</span>: api.alice.com</div><div class="line"><span class="attribute">Accept-Language</span>: en-US</div><div class="line"><span class="attribute">Connection</span>: keep-alive</div><div class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0...</div></pre></td></tr></table></figure>
<p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Access-Control-Allow-Origin</span>: http://api.bob.com</div><div class="line"><span class="attribute">Access-Control-Allow-Credentials</span>: true</div><div class="line"><span class="attribute">Access-Control-Expose-Headers</span>: FooBar</div><div class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</div></pre></td></tr></table></figure>
<p>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头。</p>
<p><strong>（1）Access-Control-Allow-Origin</strong></p>
<p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<p><strong>（2）Access-Control-Allow-Credentials</strong></p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p><strong>（3）Access-Control-Expose-Headers</strong></p>
<p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p>
<h3 id="3-2-withCredentials-属性"><a href="#3-2-withCredentials-属性" class="headerlink" title="3.2 withCredentials 属性"></a>3.2 withCredentials 属性</h3><p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Access-Control-Allow-Credentials</span>: true</div></pre></td></tr></table></figure>
<p>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">xhr.withCredentials = <span class="literal">true</span>;</div></pre></td></tr></table></figure>
<p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p>
<p>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭<code>withCredentials</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.withCredentials = <span class="literal">false</span>;</div></pre></td></tr></table></figure>
<p>需要注意的是，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</p>
<h2 id="四、非简单请求"><a href="#四、非简单请求" class="headerlink" title="四、非简单请求"></a>四、非简单请求</h2><h3 id="4-1-预检请求"><a href="#4-1-预检请求" class="headerlink" title="4.1 预检请求"></a>4.1 预检请求</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>
<p>下面是一段浏览器的JavaScript脚本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> url = <span class="string">'http://api.alice.com/cors'</span>;</div><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">xhr.open(<span class="string">'PUT'</span>, url, <span class="literal">true</span>);</div><div class="line">xhr.setRequestHeader(<span class="string">'X-Custom-Header'</span>, <span class="string">'value'</span>);</div><div class="line">xhr.send();</div></pre></td></tr></table></figure>
<p>上面代码中，HTTP请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">OPTIONS</span> <span class="string">/cors</span> HTTP/1.1</div><div class="line"><span class="attribute">Origin</span>: http://api.bob.com</div><div class="line"><span class="attribute">Access-Control-Request-Method</span>: PUT</div><div class="line"><span class="attribute">Access-Control-Request-Headers</span>: X-Custom-Header</div><div class="line"><span class="attribute">Host</span>: api.alice.com</div><div class="line"><span class="attribute">Accept-Language</span>: en-US</div><div class="line"><span class="attribute">Connection</span>: keep-alive</div><div class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0...</div></pre></td></tr></table></figure>
<p>“预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p>
<p>除了<code>Origin</code>字段，”预检”请求的头信息包括两个特殊字段。</p>
<p><strong>（1）Access-Control-Request-Method</strong></p>
<p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code>。</p>
<p><strong>（2）Access-Control-Request-Headers</strong></p>
<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p>
<h3 id="4-2-预检请求的回应"><a href="#4-2-预检请求的回应" class="headerlink" title="4.2 预检请求的回应"></a>4.2 预检请求的回应</h3><p>服务器收到”预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 <span class="number">200</span> OK</div><div class="line"><span class="attribute">Date</span>: Mon, 01 Dec 2008 01:15:39 GMT</div><div class="line"><span class="attribute">Server</span>: Apache/2.0.61 (Unix)</div><div class="line"><span class="attribute">Access-Control-Allow-Origin</span>: http://api.bob.com</div><div class="line"><span class="attribute">Access-Control-Allow-Methods</span>: GET, POST, PUT</div><div class="line"><span class="attribute">Access-Control-Allow-Headers</span>: X-Custom-Header</div><div class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</div><div class="line"><span class="attribute">Content-Encoding</span>: gzip</div><div class="line"><span class="attribute">Content-Length</span>: 0</div><div class="line"><span class="attribute">Keep-Alive</span>: timeout=2, max=100</div><div class="line"><span class="attribute">Connection</span>: Keep-Alive</div><div class="line"><span class="attribute">Content-Type</span>: text/plain</div></pre></td></tr></table></figure>
<p>上面的HTTP回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Access-Control-Allow-Origin</span>: *</div></pre></td></tr></table></figure>
<p>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">XMLHttpRequest cannot load http://api.alice.com.</div><div class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</div></pre></td></tr></table></figure>
<p>服务器回应的其他CORS相关字段如下。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Access-Control-Allow-Methods</span>: GET, POST, PUT</div><div class="line"><span class="attribute">Access-Control-Allow-Headers</span>: X-Custom-Header</div><div class="line"><span class="attribute">Access-Control-Allow-Credentials</span>: true</div><div class="line"><span class="attribute">Access-Control-Max-Age</span>: 1728000</div></pre></td></tr></table></figure>
<p><strong>（1）Access-Control-Allow-Methods</strong></p>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p>
<p><strong>（2）Access-Control-Allow-Headers</strong></p>
<p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p>
<p><strong>（3）Access-Control-Allow-Credentials</strong></p>
<p>该字段与简单请求时的含义相同。</p>
<p><strong>（4）Access-Control-Max-Age</strong></p>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
<h3 id="4-3-浏览器的正常请求和回应"><a href="#4-3-浏览器的正常请求和回应" class="headerlink" title="4.3 浏览器的正常请求和回应"></a>4.3 浏览器的正常请求和回应</h3><p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p>
<p>下面是”预检”请求之后，浏览器的正常CORS请求。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">PUT</span> <span class="string">/cors</span> HTTP/1.1</div><div class="line"><span class="attribute">Origin</span>: http://api.bob.com</div><div class="line"><span class="attribute">Host</span>: api.alice.com</div><div class="line"><span class="attribute">X-Custom-Header</span>: value</div><div class="line"><span class="attribute">Accept-Language</span>: en-US</div><div class="line"><span class="attribute">Connection</span>: keep-alive</div><div class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0...</div></pre></td></tr></table></figure>
<p>上面头信息的<code>Origin</code>字段是浏览器自动添加的。</p>
<p>下面是服务器正常的回应。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Access-Control-Allow-Origin</span>: http://api.bob.com</div><div class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</div></pre></td></tr></table></figure>
<p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p>
<h2 id="五、与JSONP的比较"><a href="#五、与JSONP的比较" class="headerlink" title="五、与JSONP的比较"></a>五、与JSONP的比较</h2><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p>
<p>JSONP只支持<code>GET</code>请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<p>（完）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Go Channel]]></title>
      <url>http://yusank.github.io/Go%20Channel.html/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>讲解 Golang 的 channel（通道），学 go 语言的有必要看一下。以下正文。。。</p>
<hr>
<h1 id="Go-Channel-详解"><a href="#Go-Channel-详解" class="headerlink" title="Go Channel 详解"></a>Go Channel 详解</h1><p>Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)。</p>
<p>它的操作符是箭头 <strong>&lt;-</strong> 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ch &lt;- v    </div><div class="line">v := &lt;-ch</div></pre></td></tr></table></figure>
<p>(箭头的指向就是数据的流向)</p>
<p>就像 map 和 slice 数据类型一样, channel必须先创建再使用:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</div></pre></td></tr></table></figure>
<h2 id="Channel-类型"><a href="#Channel-类型" class="headerlink" title="Channel 类型"></a>Channel 类型</h2><p>Channel类型的定义格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ChannelType = ( <span class="string">"chan"</span> | <span class="string">"chan"</span> <span class="string">"&lt;-"</span> | <span class="string">"&lt;-"</span> <span class="string">"chan"</span> ) ElementType .</div></pre></td></tr></table></figure>
<p>它包括三种类型的定义。可选的<code>&lt;-</code>代表channel的方向。如果没有指定方向，那么Channel就是双向的，既可以接收数据，也可以发送数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">chan</span> T          <span class="comment">// 可以接收和发送类型为 T 的数据</span></div><div class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">float64</span>  <span class="comment">// 只可以用来发送 float64 类型的数据</span></div><div class="line">&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>      <span class="comment">// 只可以用来接收 int 类型的数据</span></div></pre></td></tr></table></figure>
<p><code>&lt;-</code>总是优先和最左边的类型结合。(The &lt;- operator associates with the leftmost chan possible)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">chan</span> <span class="keyword">int</span>    <span class="comment">// 等价 chan&lt;- (chan int)</span></div><div class="line"><span class="keyword">chan</span>&lt;- &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>  <span class="comment">// 等价 chan&lt;- (&lt;-chan int)</span></div><div class="line">&lt;-<span class="keyword">chan</span> &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>  <span class="comment">// 等价 &lt;-chan (&lt;-chan int)</span></div><div class="line"><span class="keyword">chan</span> (&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</div></pre></td></tr></table></figure>
<p>使用<code>make</code>初始化Channel,并且可以设置容量:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</div></pre></td></tr></table></figure>
<p>容量(capacity)代表Channel容纳的最多的元素的数量，代表Channel的缓存的大小。<br>如果没有设置容量，或者容量设置为0, 说明Channel没有缓存，只有sender和receiver都准备好了后它们的通讯(communication)才会发生(Blocking)。如果设置了缓存，就有可能不发生阻塞， 只有buffer满了后 send才会阻塞， 而只有缓存空了后receive才会阻塞。一个nil channel不会通信。</p>
<p>可以通过内建的<code>close</code>方法可以关闭Channel。</p>
<p>你可以在多个goroutine从/往 一个channel 中 receive/send 数据, 不必考虑额外的同步措施。</p>
<p>Channel可以作为一个先入先出(FIFO)的队列，接收的数据和发送的数据的顺序是一致的。</p>
<p>channel的 receive支持 <em>multi-valued assignment</em>，如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">v, ok := &lt;-ch</div></pre></td></tr></table></figure>
<p>它可以用来检查Channel是否已经被关闭了。</p>
<ol>
<li><strong>send语句</strong><br>send语句用来往Channel中发送数据， 如<code>ch &lt;- 3</code>。<br>它的定义如下:</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SendStmt = Channel <span class="string">"&lt;-"</span> Expression .</div><div class="line">Channel  = Expression .</div></pre></td></tr></table></figure>
<p>在通讯(communication)开始前channel和expression必选先求值出来(evaluated)，比如下面的(3+4)先计算出7然后再发送给channel。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</div><div class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(c)</div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- <span class="number">3</span> + <span class="number">4</span> &#125;()</div><div class="line">i := &lt;-c</div><div class="line">fmt.Println(i)</div></pre></td></tr></table></figure>
<p>send被执行前(proceed)通讯(communication)一直被阻塞着。如前所言，无缓存的channel只有在receiver准备好后send才被执行。如果有缓存，并且缓存未满，则send会被执行。</p>
<p>往一个已经被close的channel中继续发送数据会导致<strong>run-time panic</strong>。</p>
<p>往nil channel中发送数据会一致被阻塞着。</p>
<ol>
<li>receive 操作符<br><code>&lt;-ch</code>用来从channel ch中接收数据，这个表达式会一直被block,直到有数据可以接收。</li>
</ol>
<p>从一个nil channel中接收数据会一直被block。</p>
<p>从一个被close的channel中接收数据不会被阻塞，而是立即返回，接收完已发送的数据后会返回元素类型的零值(zero value)。</p>
<p>如前所述，你可以使用一个额外的返回参数来检查channel是否关闭。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x, ok := &lt;-ch</div><div class="line">x, ok = &lt;-ch</div><div class="line"><span class="keyword">var</span> x, ok = &lt;-ch</div></pre></td></tr></table></figure>
<h2 id="blocking"><a href="#blocking" class="headerlink" title="blocking"></a>blocking</h2><p>缺省情况下，发送和接收会一直阻塞着，知道另一方准备好。这种方式可以用来在gororutine中进行同步，而不必使用显示的锁或者条件变量。</p>
<p>如官方的例子中<code>x, y := &lt;-c, &lt;-c</code>这句会一直等待计算结果发送到channel中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	sum := <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</div><div class="line">		sum += v</div><div class="line">	&#125;</div><div class="line">	c &lt;- sum </div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</div><div class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</div><div class="line">	<span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</div><div class="line">	<span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</div><div class="line">	x, y := &lt;-c, &lt;-c <span class="comment">// receive from c</span></div><div class="line">	fmt.Println(x, y, x+y)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h2><p>make的第二个参数指定缓存的大小：<code>ch := make(chan int, 100)</code>。</p>
<p>通过缓存的使用，可以尽量避免阻塞，提供应用的性能。</p>
<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p><code>for …… range</code>语句可以处理Channel。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		time.Sleep(<span class="number">1</span> * time.Hour)</div><div class="line">	&#125;()</div><div class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i = i + <span class="number">1</span> &#123;</div><div class="line">			c &lt;- i</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">close</span>(c)</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</div><div class="line">		fmt.Println(i)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"Finished"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>range c</code>产生的迭代值为Channel中发送的值，它会一直迭代知道channel被关闭。上面的例子中如果把<code>close(c)</code>注释掉，程序会一直阻塞在<code>for …… range</code>那一行。</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p><code>select</code>语句选择一组可能的send操作和receive操作去处理。它类似<code>switch</code>,但是只是用来处理通讯(communication)操作。<br>它的<code>case</code>可以是send语句，也可以是receive语句，亦或者<code>default</code>。</p>
<p><code>receive</code>语句可以将值赋值给一个或者两个变量。它必须是一个receive操作。</p>
<p>最多允许有一个<code>default case</code>,它可以放在case列表的任何位置，尽管我们大部分会将它放在最后。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	x, y := <span class="number">0</span>, <span class="number">1</span></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> c &lt;- x:</div><div class="line">			x, y = y, x+y</div><div class="line">		<span class="keyword">case</span> &lt;-quit:</div><div class="line">			fmt.Println(<span class="string">"quit"</span>)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</div><div class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line">			fmt.Println(&lt;-c)</div><div class="line">		&#125;</div><div class="line">		quit &lt;- <span class="number">0</span></div><div class="line">	&#125;()</div><div class="line">	fibonacci(c, quit)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有同时多个case去处理,比如同时有多个channel可以接收数据，那么Go会伪随机的选择一个case处理(pseudo-random)。如果没有case需要处理，则会选择<code>default</code>去处理，如果<code>default case</code>存在的情况下。如果没有<code>default case</code>，则<code>select</code>语句会阻塞，直到某个case需要处理。</p>
<p>需要注意的是，nil channel上的操作会一直被阻塞，如果没有default case,只有nil channel的select会一直被阻塞。</p>
<p><code>select</code>语句和<code>switch</code>语句一样，它不是循环，它只会选择一个case来处理，如果想一直处理channel，你可以在外面加一个无限的for循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">	<span class="keyword">select</span> &#123;</div><div class="line">	<span class="keyword">case</span> c &lt;- x:</div><div class="line">		x, y = y, x+y</div><div class="line">	<span class="keyword">case</span> &lt;-quit:</div><div class="line">		fmt.Println(<span class="string">"quit"</span>)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p><code>select</code>有很重要的一个应用就是超时处理。 因为上面我们提到，如果没有case需要处理，select语句就会一直阻塞着。这时候我们可能就需要一个超时操作，用来处理超时的情况。<br>下面这个例子我们会在2秒后往channel c1中发送一个数据，但是<code>select</code>设置为1秒超时,因此我们会打印出<code>timeout 1</code>,而不是<code>result 1</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"time"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</div><div class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">        time.Sleep(time.Second * <span class="number">2</span>)</div><div class="line">        c1 &lt;- <span class="string">"result 1"</span></div><div class="line">    &#125;()</div><div class="line">    <span class="keyword">select</span> &#123;</div><div class="line">    <span class="keyword">case</span> res := &lt;-c1:</div><div class="line">        fmt.Println(res)</div><div class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">1</span>):</div><div class="line">        fmt.Println(<span class="string">"timeout 1"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实它利用的是<code>time.After</code>方法，它返回一个类型为<code>&lt;-chan Time</code>的单向的channel，在指定的时间发送一个当前时间给返回的channel中。</p>
<h2 id="Timer-和-Ticker"><a href="#Timer-和-Ticker" class="headerlink" title="Timer 和 Ticker"></a>Timer 和 Ticker</h2><p>我们看一下关于时间的两个Channel。<br>timer是一个定时器，代表未来的一个单一事件，你可以告诉timer你要等待多长时间，它提供一个Channel，在将来的那个时间那个Channel提供了一个时间值。下面的例子中第二行会阻塞2秒钟左右的时间，直到时间到了才会继续执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">timer1 := time.NewTimer(time.Second * <span class="number">2</span>)</div><div class="line">&lt;-timer1.C</div><div class="line">fmt.Println(<span class="string">"Timer 1 expired"</span>)</div></pre></td></tr></table></figure>
<p>当然如果你只是想单纯的等待的话，可以使用<code>time.Sleep</code>来实现。</p>
<p>你还可以使用<code>timer.Stop</code>来停止计时器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">timer2 := time.NewTimer(time.Second)</div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">	&lt;-timer2.C</div><div class="line">	fmt.Println(<span class="string">"Timer 2 expired"</span>)</div><div class="line">&#125;()</div><div class="line">stop2 := timer2.Stop()</div><div class="line"><span class="keyword">if</span> stop2 &#123;</div><div class="line">	fmt.Println(<span class="string">"Timer 2 stopped"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ticker</code>是一个定时触发的计时器，它会以一个间隔(interval)往Channel发送一个事件(当前时间)，而Channel的接收者可以以固定的时间间隔从Channel中读取事件。下面的例子中ticker每500毫秒触发一次，你可以观察输出的时间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ticker := time.NewTicker(time.Millisecond * <span class="number">500</span>)</div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> t := <span class="keyword">range</span> ticker.C &#123;</div><div class="line">		fmt.Println(<span class="string">"Tick at"</span>, t)</div><div class="line">	&#125;</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<p>类似timer, ticker也可以通过<code>Stop</code>方法来停止。一旦它停止，接收者不再会从channel中接收数据了。</p>
<h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>内建的close方法可以用来关闭channel。</p>
<p>总结一下channel关闭后sender的receiver操作。<br>如果channel c已经被关闭,继续往它发送数据会导致<code>panic: send on closed channel</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"time"</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		time.Sleep(time.Hour)</div><div class="line">	&#125;()</div><div class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</div><div class="line">	c &lt;- <span class="number">1</span></div><div class="line">	c &lt;- <span class="number">2</span></div><div class="line">	<span class="built_in">close</span>(c)</div><div class="line">	c &lt;- <span class="number">3</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是从这个关闭的channel中不但可以读取出已发送的数据，还可以不断的读取零值:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</div><div class="line">c &lt;- <span class="number">1</span></div><div class="line">c &lt;- <span class="number">2</span></div><div class="line"><span class="built_in">close</span>(c)</div><div class="line">fmt.Println(&lt;-c) <span class="comment">//1</span></div><div class="line">fmt.Println(&lt;-c) <span class="comment">//2</span></div><div class="line">fmt.Println(&lt;-c) <span class="comment">//0</span></div><div class="line">fmt.Println(&lt;-c) <span class="comment">//0</span></div></pre></td></tr></table></figure>
<p>但是如果通过<code>range</code>读取，channel关闭后for循环会跳出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</div><div class="line">c &lt;- <span class="number">1</span></div><div class="line">c &lt;- <span class="number">2</span></div><div class="line"><span class="built_in">close</span>(c)</div><div class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</div><div class="line">	fmt.Println(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>i, ok := &lt;-c</code>可以查看Channel的状态，判断值是零值还是正常读取的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</div><div class="line"><span class="built_in">close</span>(c)</div><div class="line"></div><div class="line">i, ok := &lt;-c</div><div class="line">fmt.Printf(<span class="string">"%d, %t"</span>, i, ok) <span class="comment">//0, false</span></div></pre></td></tr></table></figure>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>channel可以用在goroutine之间的同步。<br>下面的例子中main goroutine通过done channel等待worker完成任务。 worker做完任务后只需往channel发送一个数据就可以通知main goroutine任务完成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</div><div class="line">	time.Sleep(time.Second)</div><div class="line">	<span class="comment">// 通知任务已完成</span></div><div class="line">	done &lt;- <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</div><div class="line">	<span class="keyword">go</span> worker(done)</div><div class="line">	<span class="comment">// 等待任务完成</span></div><div class="line">	&lt;-done</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>[参考资料]：</strong></p>
<ol>
<li><a href="https://gobyexample.com/channels" target="_blank" rel="external">https://gobyexample.com/channels</a></li>
<li><a href="https://tour.golang.org/concurrency/2" target="_blank" rel="external">https://tour.golang.org/concurrency/2</a></li>
<li><a href="https://golang.org/ref/spec#Select_statements" target="_blank" rel="external">https://golang.org/ref/spec#Select_statements</a></li>
<li><a href="https://github.com/a8m/go-lang-cheat-sheet" target="_blank" rel="external">https://github.com/a8m/go-lang-cheat-sheet</a></li>
<li><a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/" target="_blank" rel="external">http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Docker 进阶与实践（第一讲）]]></title>
      <url>http://yusank.github.io/Docker.html/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>学习 Docker 技术，每看完一章或够写一篇文章的时候就上传一次. 这一篇讲容器技术。以下正文。。。<br><a id="more"></a></p>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h3 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h3><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=437292675&auto=1&height=66"></iframe>

<p>对于容器，目前并没有一个严格的定义，但是普遍被认可的说法是，它首先必须是一个相对独立的环境，在这一点上有点类似虚拟机，但是没有虚拟机那么彻底。另外，在一个容器环境中，应该最小化其对外界的影响，比如不能在容器中吧host上的资源耗尽，这就是资源的控制。</p>
<p>容器技术之所以受欢迎，一个重要的原因是它已经集成到了 Linux 内核中，已经被当作 Linux 内核原生提供的特征。当然其他平台也有相应的容器技术，但是我们讨论的以及Docker涉及的都是指 Linux 平台上的容器技术。</p>
<p>一般来说，容器技术主要包括Namespace和Cgroup两个内核特征。</p>
<ul>
<li>Namespace 命名空间，它主要做的是访问隔离。其原理是对一类资源进行抽象，并将其封装在一起提供给容器使用，对于这类资源，因为每个容器都有自己的抽象，而他们彼此之间是不可见的，所以就做到访问隔离。</li>
<li>Cgroup是 control group 的简称，又称为控制组，它主要是控制资源控制。其原理是将一组进程放在一个控制组里，通过给这个控制组分配指定的可用资源，达到控制这一组进程可用资源的目的。</li>
</ul>
<p>容器最核心技术是 Namespace+Cgroup，但是光有这两个抽象的技术概念是无法组成一个完整的容器的。<br>对于 linux 容器的最小组成，是由一下四个部分构成：</p>
<ul>
<li>Cgroup： 资源控制。</li>
<li>Namespace： 访问隔离。</li>
<li>rootfs： 系统文件隔离。</li>
<li>容器引擎： 生命周期控制。</li>
</ul>
<h2 id="容器的创建原理"><a href="#容器的创建原理" class="headerlink" title="容器的创建原理"></a>容器的创建原理</h2><p>代码一<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pid = clone(fun, <span class="built_in">stack</span>, flags, clone_arg);</div><div class="line"></div><div class="line">(flags: CLONE_NEWPID | CLONE_NEWNS |</div><div class="line">     CLONE_NEWUSER | CLONE_NEWNET |</div><div class="line">     CLONE_NEWIPC | CLONE_NEWUTS |</div><div class="line">        ...)</div></pre></td></tr></table></figure></p>
<ul>
<li>对于以上代码，通过clone系统调用，并传入各个Namespace对应的clone flag，创建了一个新的子进程，该进程拥有自己的Namespace。从上面的代码可以看出，该进程拥有自己的pid,mount,user,net,ipc,uts namespace 。</li>
</ul>
<p>代码二：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="variable">$pid</span> &gt; /sys/fs/cgroup/cpu/tasks</div><div class="line"><span class="built_in">echo</span> <span class="variable">$pid</span> &gt; /sys/fs/cgroup/cpuset/tasks</div><div class="line"><span class="built_in">echo</span> <span class="variable">$pid</span> &gt; /sys/fs/cgroup/blkio/tasks</div><div class="line"><span class="built_in">echo</span> <span class="variable">$pid</span> &gt; /sys/fs/cgroup/memory/tasks</div><div class="line"><span class="built_in">echo</span> <span class="variable">$pid</span> &gt; /sys/fs/cgroup/devices/tasks</div><div class="line"><span class="built_in">echo</span> <span class="variable">$pid</span> &gt; /sys/fs/cgroup/freezer/tasks</div></pre></td></tr></table></figure></p>
<ul>
<li>对于代码二，将代码一中的pid写入各个Cgroup子系统中，这样该进程就可以受到相应Cgroup子系统的控制。</li>
</ul>
<p>代码三：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">fun</span></span> ()</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    pivot_root(<span class="string">"path_of_rootfs/"</span>, path);</div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="built_in">exec</span>(<span class="string">"/bin/bash"</span>);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>对于代码三，该fun函数由上面生成的新进程执行，在fun函数中，通过<code>pivot_root</code>系统调用，使进程进入新的<code>rootfs</code>，之后通过<code>exec</code>系统调用，在新的<code>Namespace</code>,<code>Cgroup</code>,<code>rootfs</code>中执行<code>&quot;/bin/bash&quot;</code>程序。</li>
</ul>
<p>通过以上操作，成功在一个“容器”中运行了一个bash程序。对于Cgroup和Namespace的技术细节，我们下一节详细描述</p>
<h1 id="Cgroup"><a href="#Cgroup" class="headerlink" title="Cgroup"></a>Cgroup</h1><h2 id="Cgroup-是什么"><a href="#Cgroup-是什么" class="headerlink" title="Cgroup 是什么"></a>Cgroup 是什么</h2><p>Cgroup是control group 的简写，属于 Linux 内核提供的一个特性，用于限制和隔离一组进程对系统资源的使用。这些资源主要包括 CPU， 内存， block I/O（数据块 I/O） 和网络宽带。<br>Cgroup 从 2.6.24版本进入内核主线，目前各大发行版linux都默认打开了 Cgroup 特性</p>
<p>从实现的角度来看，Cgroup 实现了一个通用的进程分组的框架，而不同资源的具体管理则是由各个 Cgroup 子系统实现的。截止内核4.1版本，Cgroup 中实现的子系统的及其作用如下：</p>
<ul>
<li>devices： 设备权限控制</li>
<li>cpuset： 分配指定的CPU和内存节点</li>
<li>cpu： 控制 CPU 占用率</li>
<li>cpuacct： 统计 CPU 使用情况</li>
<li>memory： 限制内存的使用上限</li>
<li>freezer： 冻结（暂停）Cgroup 中的进程</li>
<li>net_cls： 配合tc（traffic controller）限制网络宽带</li>
<li>net_prio： 设置进程的网络流量优先级</li>
<li>huge_tlb： 限制HugeTLB（块表缓冲区）的使用</li>
<li>perf_event： 允许 Perf 工具基于Cgroup分组做性能测试</li>
</ul>
<h1 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h1><h2 id="Namespace-是什么"><a href="#Namespace-是什么" class="headerlink" title="Namespace 是什么"></a>Namespace 是什么</h2><p>Namespace 是将内核的全局资源做封装，使得每个Namespace都有有一份独立的资源，因此不同的进程各自的 Namespace 内对同一个资源的使用不会互相干扰。<br>举个例子，执行 sethostname 这个系统调用时，可以改变系统的主机名，这个主机名就是一个内核的全局资源。内核通过实现 UTS Namespace，可以将不同的进程分隔在不同的 UTS Namespace 中，在某个 Namespace 修改主机名时，另一个 Namespace 的主机名还是保持不变。</p>
<p>目前 Linux 内核总共实现了6种 Namespace：</p>
<ul>
<li>IPC： 隔离 System V IPC 和 POSIX 消息队列</li>
<li>Network： 隔离网络资源</li>
<li>Mount： 隔离文件系统挂载点</li>
<li>PID： 隔离进程 ID</li>
<li>UTS： 隔离主机名和域名</li>
<li>User： 隔离用户 ID 和 组 ID</li>
</ul>
<p>Namespace 和 Cgroup 的使用是灵活的，同时也有不少需要注意的地方，因此直接操作 Namespace 和 Cgroup 并不是很容易。正是因为这些原因，Docker 通过 Libcontainer 来处理这些底层的事情。这样一来，Docker 只需简单地调用 Libcontainer 的 API ，就能将完整的容器搭建起来。而作为 Docker 的用户，就更不用操心这些事情了。</p>
<h1 id="容器造就-Docker"><a href="#容器造就-Docker" class="headerlink" title="容器造就 Docker"></a>容器造就 Docker</h1><p>关于容器是否是 Docker 的技术核心技术，业界一直存在着争议。</p>
<p>在理解了容器，理解了容器的核心技术 Cgroup 和 Namespace，理解了容器技术如何巧妙且轻量地实现“容器”本身的资源控制和访问隔离之后，可以看到 Docker 和容器是一种完美的融合和辅助相成的关系，它们不是唯一的搭配，但一定是最完美的结合（目前来说）。与其说是容器造就了 Docker ， 不如说是它们造就了彼此，容器技术让 Docker 得到更多的应用和推广，Docker 也使得容器技术被更多人熟知。<br>[须知]：<b>转载请标明出处，请尊重笔者和作者的功劳，O(∩_∩)O谢谢！</b><br>[参考]:<b>Docker 进阶与实践  </b><i>华为Docker实践小组 著（机械工业出版社）</i></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Goddbye 2016 and Hello 2017]]></title>
      <url>http://yusank.github.io/%E5%86%8D%E8%A7%81%E4%BA%862016%EF%BC%8C%E4%BD%A0%E5%A5%BD2017.html/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>突然想写一篇文章纪念一下我的2016，语文水平不是很好，要是写的不好，就不要在意太多的细节了，以下正文。。。。<br><a id="more"></a></p>
<h2 id="再见了2016，你好2017"><a href="#再见了2016，你好2017" class="headerlink" title="再见了2016，你好2017"></a>再见了2016，你好2017</h2><p>来点音乐吧，</p>
<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=186560&auto=0&height=66"></iframe><br>​    纵观过去的这一年，发生了很多我没有预料的到时事儿，不管是感情还是学习工作方面。</p>
<p>​    去年的今天我做了不少的计划，许了不少的愿，但是实现了几个没做到几个，现在我是真想不出来。从我现在的情况来看，2016过得并不是很糟糕，也许可以用过得还不错的这句话来形容。</p>
<p>​    寒假跟每年的寒假没有任何区别，玩儿吃喝，非要说有区别的话，我还是想不起来任何的区别【微笑】。3月份回学校，做了我人生第一次烫发，自我感觉还可以。生活还是一如既往，学习吃饭周末出去通宵。就这样，2016年也快一半了，6月初的出去旅游，给我们每个人一次难忘的回忆，那回忆如此的美好，甜蜜。然而好梦总是不长的，6月末，我听到了一个我最不想听的一个消息。以前一直以为如果真有这么一天，我会怎么怎么样。但是真的碰到了这个情况的时候，我不知道该干嘛了，不知道该为自己伤心还是为她开心，但是我不认为这就是最终结果。一个对我来说是一个不是很正常的暑假的开始了，除了一个月帮老爸跑腿开车以为，我脑子里只有一个人，也许这就是爱吧。但是我一直都只动嘴皮子不干实际性的，到目前我都很后悔这事儿。</p>
<p>​    暑假结束回到学校不到两个月，我遇到了思异，遇到了我的人生转折点。大学两年荒废过去的我终于见到一丁点曙光在远处向我招手，我不能再荒废下去了，我得努力，我得为以后找出路。就这样，我的几乎每一天都是要么在实习要么在去实习的路上度过，一直到现在，2016的最后一天。</p>
<p>​    这几个月，跟她关系越来越好，感觉已经离不开她了。每次见到到都是一种幸福满，遇到她是我大学生活发生的最幸运最幸福的事情，绝对没有之一。</p>
<p>​    时间总是过得很快，一年时间说长很长说短很短，依然记得去年的今天，但是又觉得是很久之前的事儿。再过几个小时，就得送2016了，在送它之前，我还是要好好的感谢2016，给我这么多的快乐的时光，给我了配家人配爱人的时间，谢谢你！！！</p>
<p>​    在这儿我不会许什么愿做什么计划，我只是静静的等2017的到来，静静地欢迎它，不管是到来的是哪一年，我只是希望陪我欢迎新一年的人，依然是她！</p>
<p>再见了2016，</p>
<p>​                你好2017.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux命令]]></title>
      <url>http://yusank.github.io/linux%E5%91%BD%E4%BB%A4.html/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>welcome to learn terminal command!!!<br><a id="more"></a></p>
<h1 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h1><h3 id="永！远！不！要！执！行！你！不！清！楚！在！干！啥！的！命！令！"><a href="#永！远！不！要！执！行！你！不！清！楚！在！干！啥！的！命！令！" class="headerlink" title="永！远！不！要！执！行！你！不！清！楚！在！干！啥！的！命！令！"></a>永！远！不！要！执！行！你！不！清！楚！在！干！啥！的！命！令！</h3><h2 id="实用性"><a href="#实用性" class="headerlink" title="实用性"></a>实用性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ls -l | sed &apos;1d&apos; | sort -n -k5 | awk &apos;&#123;printf &quot;%15s %10s\n&quot;, $9,$5&#125;&apos;</div></pre></td></tr></table></figure>
<p>按文件大小增序打印出当前目录下的文件名及其文件大小(单位字节）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ history | awk &apos;&#123;print $2&#125;&apos; | sort | uniq -c | sort -rn | head -10</div></pre></td></tr></table></figure>
<p>输出你最常用的十条命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ http POST http://localhost:4000/ &lt; /&lt;json文件路径&gt;</div></pre></td></tr></table></figure>
<p>做测试的时候很有用的一个命令，需要下载http</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install http</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ lsof -n -P -i TCP -s TCP:LISTEN</div><div class="line"></div><div class="line">COMMAND  PID       USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME</div><div class="line">QQ       290 smartestee   33u  IPv4 0x2f3beaa58a62d73b      0t0  TCP 127.0.0.1:4300 (LISTEN)</div><div class="line">QQ       290 smartestee   34u  IPv4 0x2f3beaa58c69673b      0t0  TCP 127.0.0.1:4301 (LISTEN)</div><div class="line">idea    3257 smartestee  164u  IPv4 0x2f3beaa588d11e43      0t0  TCP 127.0.0.1:6942 (LISTEN)</div><div class="line">idea    3257 smartestee  385u  IPv4 0x2f3beaa58c69316b      0t0  TCP 127.0.0.1:63342 (LISTEN)</div></pre></td></tr></table></figure>
<p>查看端口的使用情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ps -ef</div></pre></td></tr></table></figure>
<p>查看进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kill  xxxx</div></pre></td></tr></table></figure>
<p>端口冲突时，用此命令，关闭某个端口。用PID替换xxxx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ history</div></pre></td></tr></table></figure>
<p>查看历史命令记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pwd</div></pre></td></tr></table></figure>
<p>当前位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ which xx</div></pre></td></tr></table></figure>
<p>path位置，搭建环境的时候肯定会用得到</p>
<h3 id="Linux-文件系统命令"><a href="#Linux-文件系统命令" class="headerlink" title="Linux 文件系统命令"></a>Linux 文件系统命令</h3><p>修改问价拥有者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ chgrp -R 组名 文件 / 目录</div><div class="line">$ chown -R 账户名 文件 / 目录</div></pre></td></tr></table></figure>
<p>修改文件权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chmod</div></pre></td></tr></table></figure>
<ul>
<li>使用数字<ul>
<li>r：4, w：2, x：1</li>
<li>每种身份的权限的累加的。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chmod 777 test</div></pre></td></tr></table></figure>
<ul>
<li><p>使用符号修改</p>
<ul>
<li><p>u: user, g: group, o: others, a: all</p>
</li>
<li><p>添加权限用+， 除去用-， 设置用=</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chmod u=rwx, g=rw, o=r test</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chmod a-x test</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chmod go+r test</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo !!</div></pre></td></tr></table></figure>
<p>以root权限执行上一条命令（注意上一条命令的内容，以免发生意外）</p>
<p>例如：在Ubuntu 安装软件或插件的时候需要用到这个命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install nginx</div></pre></td></tr></table></figure>
<p>查看和修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ cat</div><div class="line">$ more</div><div class="line">$ less</div><div class="line">$ head</div><div class="line">$ tail</div><div class="line"></div><div class="line">$ vi</div><div class="line">$ vim</div><div class="line"></div><div class="line">$ mkdir</div><div class="line">$ touch</div></pre></td></tr></table></figure>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git</div></pre></td></tr></table></figure>
<p>先给出比较常用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git add &lt;一个或多个文件名(文件名之间是用空格，也可以是一个点，表示添加全部)&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git commit -m &quot;注释&quot;</div></pre></td></tr></table></figure>
<p>本地提交</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout &lt;分支名或master&gt;</div></pre></td></tr></table></figure>
<p>切换分支与master</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch &lt;分支名&gt;</div></pre></td></tr></table></figure>
<p>新开一个分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git merge &lt;分支名&gt;</div></pre></td></tr></table></figure>
<p>主分支与分支的合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin master</div></pre></td></tr></table></figure>
<p>提交到github上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ fuck</div></pre></td></tr></table></figure>
<p>纠正命令行输入的错误，比手动改快，实用。</p>
<p>安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install thefuck</div></pre></td></tr></table></figure>
<h2 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cmatrix</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ telnet towel.blinkenlights.nl</div></pre></td></tr></table></figure>
<p>telnet是基于Telnet协议的远程登录客户端程序,经常用来远程登录服务器.除此还可以用它来观看星球大战</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ fortune</div></pre></td></tr></table></figure>
<p>随机输出名言或者笑话，</p>
<p>还有很多，有兴趣的可以通过这个链接去看：<a href="https://www.zhihu.com/question/20273259" target="_blank" rel="external">知乎</a></p>
<p>个人博客 <a href="http://aa.yusank.space/2016/12/28/linux%E5%91%BD%E4%BB%A4/" target="_blank" rel="external">yusank</a></p>
<p>比较牛逼的一个查找命令的网站：<a href="http://www.commandlinefu.com/commands/browse/sort-by-votes" target="_blank" rel="external">http://www.commandlinefu.com/commands/browse/sort-by-votes</a></p>
<p>每天都有更新各种命令组合</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Material 的配置]]></title>
      <url>http://yusank.github.io/%20Material%20%E5%8E%9F%E8%B4%A8.html/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="Material-原质"><a href="#Material-原质" class="headerlink" title="Material 原质"></a>Material 原质</h1><p><a href="https://material.vss.im" target="_blank" rel="external">Material Theme</a></p>
<blockquote>
<p>Nature, Source</p>
<p>stay with light`s</p>
</blockquote>
<h2 id="Contents-目录"><a href="#Contents-目录" class="headerlink" title="Contents 目录"></a>Contents 目录</h2><ul>
<li><a href="#general-概括">General 概括</a></li>
<li><a href="#demo-演示">Demo 演示</a></li>
<li><a href="#quick-start-快速开始">Quick start 快速开始</a></li>
<li><a href="#docs-文档">Docs 文档</a></li>
<li><a href="#contributing-贡献">Contributing 贡献</a></li>
<li><a href="#license-许可证">License 许可证</a></li>
<li><a href="#render-渲染">Render 渲染</a></li>
<li><a href="https://material.vss.im/changelog/" target="_blank" rel="external">Changelog 开发日志</a></li>
</ul>
<h2 id="General-概括"><a href="#General-概括" class="headerlink" title="General 概括"></a>General 概括</h2><p><a href="https://viosey.com" target="_blank" rel="external"><img src="https://img.shields.io/badge/author-Viosey-blue.svg?style=flat-square" alt="Author"></a><br><a href=""><img src="https://img.shields.io/badge/version-1.2.4-green.svg?style=flat-square" alt="Version"></a><br><a href="https://hexo.io" target="_blank" rel="external"><img src="https://img.shields.io/badge/hexo-3.0+-green.svg?style=flat-square" alt="Hexo"></a><br><a href="https://travis-ci.org/viosey/hexo-theme-material" target="_blank" rel="external"><img src="https://img.shields.io/travis/viosey/hexo-theme-material.svg?style=flat-square" alt="Build Status"></a><br><a href="http://jq.qq.com/?_wv=1027&amp;k=40Vdy24" target="_blank" rel="external"><img src="https://img.shields.io/badge/QQ%20%E7%BE%A4-566308505-brightgreen.svg?style=flat-square" alt="QQ Group"></a></p>
<h2 id="Demo-演示"><a href="#Demo-演示" class="headerlink" title="Demo 演示"></a>Demo 演示</h2><p><a href="https://blog.viosey.com" target="_blank" rel="external">Viosey’s Blog</a></p>
<h2 id="Quick-start-快速开始"><a href="#Quick-start-快速开始" class="headerlink" title="Quick start 快速开始"></a>Quick start 快速开始</h2><p><a href="https://material.vss.im/en/start/#install-material" target="_blank" rel="external">Install Material</a>    </p>
<p><a href="https://material.vss.im/start/#install-material" target="_blank" rel="external">安装 Material</a></p>
<h2 id="Docs-文档"><a href="#Docs-文档" class="headerlink" title="Docs 文档"></a>Docs 文档</h2><p><a href="https://material.vss.im/en/" target="_blank" rel="external">Material Theme Docs</a></p>
<p><a href="https://material.vss.im" target="_blank" rel="external">Material 主题文档</a></p>
<blockquote>
<p><a href="https://github.com/viosey/material-theme-docs" target="_blank" rel="external">Docs Markdown Files</a></p>
</blockquote>
<h2 id="Contributing-贡献"><a href="#Contributing-贡献" class="headerlink" title="Contributing 贡献"></a>Contributing 贡献</h2><p>All kinds of contributions (enhancements, new features, documentation &amp; code improvements, issues &amp; bugs reporting) are welcome.</p>
<p>欢迎各种形式的贡献，包括但不限于优化，添加功能，文档 &amp; 代码的改进，问题和 bugs 的报告。期待您的 <code>Pull Request</code>。</p>
<h2 id="License-许可证"><a href="#License-许可证" class="headerlink" title="License 许可证"></a>License 许可证</h2><p><a href="https://github.com/viosey/hexo-theme-material/blob/master/LICENSE" target="_blank" rel="external"><img src="https://img.shields.io/github/license/viosey/hexo-theme-material.svg?style=flat-square" alt="license"></a></p>
<p>Open sourced under the GPL v3.0 license.</p>
<p>根据 GPL V3.0 许可证开源。</p>
<h2 id="Render-渲染"><a href="#Render-渲染" class="headerlink" title="Render 渲染"></a>Render 渲染</h2><p><img src="https://qiniu.viosey.com/img/Material-Phone-Render.png" alt=""></p>
<p><img src="https://qiniu.viosey.com/img/Materia-themel-overview-tiny.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python 资源大全]]></title>
      <url>http://yusank.github.io/awesomepython.html/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="Python-资源大全中文版"><a href="#Python-资源大全中文版" class="headerlink" title="Python 资源大全中文版"></a>Python 资源大全中文版</h1><a id="more"></a>
<p>我想很多程序员应该记得 GitHub 上有一个 Awesome - XXX 系列的资源整理。<a href="https://github.com/vinta/awesome-python" target="_blank" rel="external">awesome-python</a> 是 vinta 发起维护的 Python 资源列表，内容包括：Web框架、网络爬虫、网络内容提取、模板引擎、数据库、数据可视化、图片处理、文本处理、自然语言处理、机器学习、日志、代码分析等。由伯乐在线持续更新。</p>
<p>Awesome 系列虽然挺全，但基本只对收录的资源做了极为简要的介绍，如果有更详细的中文介绍，对相应开发者的帮助会更大。这也是我们发起这个开源项目的初衷。</p>
<hr>
<h3 id="我们要做什么？"><a href="#我们要做什么？" class="headerlink" title="我们要做什么？"></a>我们要做什么？</h3><ul>
<li>基于 awesome-python 列表，我们将对其中的各个资源项进行编译整理。此外还将从其他来源补充好资源。</li>
<li>整理后的内容，将收录在<a href="http://hao.jobbole.com/" target="_blank" rel="external">伯乐在线资源频道</a>。可参考已整理的内容：<ul>
<li>《<a href="http://hao.jobbole.com/python-scrapy/" target="_blank" rel="external">Scrapy：Python的爬虫框架</a>》</li>
<li>《<a href="http://hao.jobbole.com/flask/" target="_blank" rel="external">Flask：一个使用Python编写的轻量级Web应用框架</a>》</li>
</ul>
</li>
</ul>
<hr>
<h3 id="如何参与本项目？"><a href="#如何参与本项目？" class="headerlink" title="如何参与本项目？"></a>如何参与本项目？</h3><p>从下面的目录来看，本项目的工作量小不了，所以非常期待能有更多程序员一起来参与。</p>
<p>不过加入前，有几个小要求：</p>
<ul>
<li>英文还不错，能读懂英文并用自己的话复述；</li>
<li>在用 Python；</li>
</ul>
<p>如有兴趣，请加 QQ：50872495。加 Q 时请注明「Python大全」</p>
<hr>
<h3 id="如何为列表贡献新资源？"><a href="#如何为列表贡献新资源？" class="headerlink" title="如何为列表贡献新资源？"></a>如何为列表贡献新资源？</h3><p>欢迎大家为列表贡献高质量的新资源，提交PR时请参照以下要求：</p>
<ul>
<li>请确保推荐的资源自己使用过</li>
<li>提交PR时请注明推荐理由</li>
</ul>
<p>资源列表管理收到PR请求后，会定期（每周）在微博转发本周提交的PR列表，并在微博上面听取使用过这些资源的意见。确认通过后，会加入资源大全。</p>
<p>感谢您的贡献！</p>
<hr>
<h3 id="本项目的参与者"><a href="#本项目的参与者" class="headerlink" title="本项目的参与者"></a>本项目的参与者</h3><ul>
<li>维护者：</li>
<li>贡献者：<a href="https://github.com/hanxiaomax" target="_blank" rel="external">艾凌风</a>、Namco、<a href="https://github.com/Daetalus" target="_blank" rel="external">Daetalus</a>、<a href="http://www.jobbole.com/members/huanglimin/" target="_blank" rel="external">黄利民</a>、<a href="http://www.jobbole.com/members/atupal/" target="_blank" rel="external">atupal</a>、<a href="http://www.jobbole.com/members/rainbow/" target="_blank" rel="external">rainbow</a>、<a href="https://github.com/mutoulbj" target="_blank" rel="external">木头lbj</a>、<a href="http://www.jobbole.com/members/beyondwu/" target="_blank" rel="external">beyondwu</a>、<a href="https://github.com/cissoid" target="_blank" rel="external">cissoid</a>、<a href="https://github.com/liguangsheng" target="_blank" rel="external">李广胜</a>、<a href="https://github.com/polyval" target="_blank" rel="external">polyval</a>、<a href="http://www.jobbole.com/members/libing1209/" target="_blank" rel="external">冰斌</a>、<a href="http://www.jobbole.com/members/nelsonzhao/" target="_blank" rel="external">赵叶宇</a>、<a href="http://www.jobbole.com/members/fengfeng19910805/" target="_blank" rel="external">л stalgic</a>、<a href="http://www.jobbole.com/members/shawnw/" target="_blank" rel="external">硕恩</a></li>
</ul>
<p>注：名单不分排名，不定期补充更新</p>
<hr>
<h3 id="奖励计划"><a href="#奖励计划" class="headerlink" title="奖励计划"></a>奖励计划</h3><p>虽然奖励可能并不是你加入的主要原因，但还是有必要提一下：</p>
<ul>
<li>整理超过 20 个资源后，可在伯乐在线上开通打赏；</li>
<li>每整理 20 个资源，有机会获得技术书籍或各种有意思的创意、极客产品；</li>
<li><a href="http://hao.jobbole.com/rewards/" target="_blank" rel="external">奖励详情</a></li>
</ul>
<hr>
<h3 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h3><p>管理 Python 版本和环境的工具</p>
<ul>
<li>p：非常简单的交互式 python 版本管理工具。<a href="https://github.com/qw3rtman/p" target="_blank" rel="external">官网</a></li>
<li>pyenv：简单的 Python 版本管理工具。<a href="https://github.com/yyuu/pyenv" target="_blank" rel="external">官网</a></li>
<li>Vex：可以在虚拟环境中执行命令。<a href="https://github.com/sashahart/vex" target="_blank" rel="external">官网</a></li>
<li>virtualenv：创建独立 Python 环境的工具。<a href="https://pypi.python.org/pypi/virtualenv" target="_blank" rel="external">官网</a></li>
<li>virtualenvwrapper：virtualenv 的一组扩展。<a href="https://pypi.python.org/pypi/virtualenvwrapper" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><p>管理包和依赖的工具。</p>
<ul>
<li>pip：Python 包和依赖关系管理工具。<a href="https://pip.pypa.io/" target="_blank" rel="external">官网</a></li>
<li>pip-tools：保证 Python 包依赖关系更新的一组工具。<a href="https://github.com/nvie/pip-tools" target="_blank" rel="external">官网</a></li>
<li>conda：跨平台，Python 二进制包管理工具。<a href="https://github.com/conda/conda/" target="_blank" rel="external">官网</a></li>
<li>Curdling：管理 Python 包的命令行工具。<a href="http://clarete.li/curdling/" target="_blank" rel="external">官网</a></li>
<li>wheel：Python 分发的新标准，意在取代 eggs。<a href="http://pythonwheels.com/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="包仓库"><a href="#包仓库" class="headerlink" title="包仓库"></a>包仓库</h3><p>本地 PyPI 仓库服务和代理。</p>
<ul>
<li>warehouse：下一代 PyPI。<a href="https://github.com/pypa/warehouse" target="_blank" rel="external">官网</a><ul>
<li>Warehouse：PyPA 提供的 PyPI 镜像工具。<a href="https://warehouse.python.org/" target="_blank" rel="external">官网</a> <a href="https://bitbucket.org/pypa/bandersnatch" target="_blank" rel="external">bandersnatch</a></li>
</ul>
</li>
<li>devpi：PyPI 服务和打包/测试/分发工具。<a href="http://doc.devpi.net/" target="_blank" rel="external">官网</a></li>
<li>localshop：本地 PyPI 服务（自定义包并且自动对 PyPI 镜像）。<a href="https://github.com/mvantellingen/localshop" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="分发"><a href="#分发" class="headerlink" title="分发"></a>分发</h3><p>打包为可执行文件以便分发。</p>
<ul>
<li>PyInstaller：将 Python 程序转换成独立的执行文件（跨平台）。<a href="https://github.com/pyinstaller/pyinstaller" target="_blank" rel="external">官网</a></li>
<li>dh-virtualenv：构建并将 virtualenv 虚拟环境作为一个 Debian 包来发布。<a href="http://dh-virtualenv.readthedocs.org/" target="_blank" rel="external">官网</a></li>
<li>Nuitka：将脚本、模块、包编译成可执行文件或扩展模块。<a href="http://nuitka.net/" target="_blank" rel="external">官网</a></li>
<li>py2app：将 Python 脚本变为独立软件包（Mac OS X）。<a href="http://pythonhosted.org/py2app/" target="_blank" rel="external">官网</a></li>
<li>py2exe：将 Python 脚本变为独立软件包（Windows）。<a href="http://www.py2exe.org/" target="_blank" rel="external">官网</a></li>
<li>pynsist：一个用来创建 Windows 安装程序的工具，可以在安装程序中打包 Python本身。<a href="http://pynsist.readthedocs.org/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><p>将源码编译成软件。</p>
<ul>
<li>buildout：一个构建系统，从多个组件来创建，组装和部署应用。<a href="http://www.buildout.org/" target="_blank" rel="external">官网</a></li>
<li>BitBake：针对嵌入式 Linux 的类似 make 的构建工具。<a href="http://www.yoctoproject.org/docs/1.6/bitbake-user-manual/bitbake-user-manual.html" target="_blank" rel="external">官网</a></li>
<li>fabricate：对任何语言自动找到依赖关系的构建工具。<a href="https://code.google.com/archive/p/fabricate" target="_blank" rel="external">官网</a></li>
<li>PlatformIO：多平台命令行构建工具。<a href="https://github.com/platformio/platformio" target="_blank" rel="external">官网</a></li>
<li>PyBuilder：纯 Python 实现的持续化构建工具。<a href="https://github.com/pybuilder/pybuilder" target="_blank" rel="external">官网</a></li>
<li>SCons：软件构建工具。<a href="http://www.scons.org/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="交互式解析器"><a href="#交互式解析器" class="headerlink" title="交互式解析器"></a>交互式解析器</h3><p>交互式 Python 解析器。</p>
<ul>
<li>IPython：功能丰富的工具，非常有效的使用交互式 Python。<a href="https://github.com/ipython/ipython" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/bpython/" target="_blank" rel="external">bpython</a>：界面丰富的 Python 解析器。<a href="http://bpython-interpreter.org/" target="_blank" rel="external">官网</a></li>
<li>ptpython：高级交互式Python解析器， 构建于<a href="https://github.com/jonathanslenders/python-prompt-toolkit" target="_blank" rel="external">python-prompt-toolkit</a> 之上。<a href="https://github.com/jonathanslenders/ptpython" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件管理和 MIME（多用途的网际邮件扩充协议）类型检测。</p>
<ul>
<li>imghdr：（Python 标准库）检测图片类型。<a href="https://docs.python.org/2/library/imghdr.html" target="_blank" rel="external">官网</a></li>
<li>mimetypes：（Python 标准库）将文件名映射为 MIME 类型。<a href="https://docs.python.org/2/library/mimetypes.html" target="_blank" rel="external">官网</a></li>
<li>path.py：对 os.path 进行封装的模块。<a href="https://github.com/jaraco/path.py" target="_blank" rel="external">官网</a></li>
<li>pathlib：（Python3.4+ 标准库）跨平台的、面向对象的路径操作库。<a href="https://pathlib.readthedocs.org/en/pep428/" target="_blank" rel="external">官网</a></li>
<li>python-magic：文件类型检测的第三方库 libmagic 的 Python 接口。<a href="https://github.com/ahupp/python-magic" target="_blank" rel="external">官网</a></li>
<li>Unipath：用面向对象的方式操作文件和目录。<a href="https://github.com/mikeorr/Unipath" target="_blank" rel="external">官网</a></li>
<li>watchdog：管理文件系统事件的 API 和 shell 工具<a href="https://github.com/gorakhargosh/watchdog" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><p>操作日期和时间的类库。</p>
<ul>
<li>arrow：更好的 Python 日期时间操作类库。<a href="https://github.com/crsmithdev/arrow" target="_blank" rel="external">官网</a></li>
<li>Chronyk：Python 3 的类库，用于解析手写格式的时间和日期。<a href="https://github.com/KoffeinFlummi/Chronyk" target="_blank" rel="external">官网</a></li>
<li>dateutil：Python datetime 模块的扩展。<a href="https://pypi.python.org/pypi/python-dateutil" target="_blank" rel="external">官网</a></li>
<li>delorean：解决 Python 中有关日期处理的棘手问题的库。<a href="https://github.com/myusuf3/delorean/" target="_blank" rel="external">官网</a></li>
<li>moment：一个用来处理时间和日期的Python库。灵感来自于Moment.js。<a href="https://github.com/zachwill/moment" target="_blank" rel="external">官网</a></li>
<li>PyTime：一个简单易用的Python模块，用于通过字符串来操作日期/时间。<a href="https://github.com/shinux/PyTime" target="_blank" rel="external">官网</a></li>
<li>pytz：现代以及历史版本的世界时区定义。将时区数据库引入Python。<a href="https://launchpad.net/pytz" target="_blank" rel="external">官网</a></li>
<li>when.py：提供用户友好的函数来帮助用户进行常用的日期和时间操作。<a href="https://github.com/dirn/When.py" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><p>用于解析和操作文本的库。</p>
<ul>
<li>通用<ul>
<li><a href="http://hao.jobbole.com/chardet/" target="_blank" rel="external">chardet</a>：字符编码检测器，兼容 Python2 和 Python3。<a href="https://github.com/chardet/chardet" target="_blank" rel="external">官网</a></li>
<li>difflib：(Python 标准库)帮助我们进行差异化比较。<a href="https://docs.python.org/2/library/difflib.html" target="_blank" rel="external">官网</a></li>
<li>ftfy：让Unicode文本更完整更连贯。<a href="https://github.com/LuminosoInsight/python-ftfy" target="_blank" rel="external">官网</a></li>
<li>fuzzywuzzy：模糊字符串匹配。<a href="https://github.com/seatgeek/fuzzywuzzy" target="_blank" rel="external">官网</a></li>
<li>Levenshtein：快速计算编辑距离以及字符串的相似度。<a href="https://github.com/ztane/python-Levenshtein/" target="_blank" rel="external">官网</a></li>
<li>pangu.py：在中日韩语字符和数字字母之间添加空格。<a href="https://github.com/vinta/pangu.py" target="_blank" rel="external">官网</a></li>
<li>yfiglet-figlet：<a href="https://github.com/pwaller/pyfiglet" target="_blank" rel="external">pyfiglet -figlet</a> 的 Python实现。</li>
<li>shortuuid：一个生成器库，用以生成简洁的，明白的，URL 安全的 UUID。<a href="https://github.com/stochastic-technologies/shortuuid" target="_blank" rel="external">官网</a></li>
<li>unidecode：Unicode 文本的 ASCII 转换形式 。<a href="https://pypi.python.org/pypi/Unidecode" target="_blank" rel="external">官网</a></li>
<li>uniout：打印可读的字符，而不是转义的字符串。<a href="https://github.com/moskytw/uniout" target="_blank" rel="external">官网</a></li>
<li>xpinyin：一个用于把汉字转换为拼音的库。<a href="https://github.com/lxneng/xpinyin" target="_blank" rel="external">官网</a></li>
<li>simplejson：Python的JSON编码、解码器。<a href="https://simplejson.readthedocs.io/en/latest/" target="_blank" rel="external">官网</a>、<a href="https://github.com/simplejson/simplejson" target="_blank" rel="external">GitHub</a></li>
</ul>
</li>
<li>Slug化<ul>
<li>awesome-slugify：一个 Python slug 化库，可以保持 Unicode。<a href="https://github.com/dimka665/awesome-slugify" target="_blank" rel="external">官网</a></li>
<li>python-slugify：Python slug 化库，可以把 unicode 转化为 ASCII。<a href="https://github.com/un33k/python-slugify" target="_blank" rel="external">官网</a></li>
<li>unicode-slugify：一个 slug 工具，可以生成 unicode slugs ,需要依赖 Django 。<a href="https://github.com/mozilla/unicode-slugify" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>解析器<ul>
<li>phonenumbers：解析，格式化，储存，验证电话号码。<a href="https://github.com/daviddrysdale/python-phonenumbers" target="_blank" rel="external">官网</a></li>
<li>PLY：lex 和 yacc 解析工具的 Python 实现。<a href="http://www.dabeaz.com/ply/" target="_blank" rel="external">官网</a></li>
<li>Pygments：通用语法高亮工具。<a href="http://pygments.org/" target="_blank" rel="external">官网</a></li>
<li>pyparsing：生成通用解析器的框架。<a href="http://pyparsing.wikispaces.com/" target="_blank" rel="external">官网</a></li>
<li>python-nameparser：把一个人名分解为几个独立的部分。<a href="https://github.com/derek73/python-nameparser" target="_blank" rel="external">官网</a></li>
<li>python-user-agents：浏览器 user agent 解析器。<a href="https://github.com/selwin/python-user-agents" target="_blank" rel="external">官网</a></li>
<li>sqlparse：一个无验证的 SQL 解析器。<a href="https://sqlparse.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="特殊文本格式处理"><a href="#特殊文本格式处理" class="headerlink" title="特殊文本格式处理"></a>特殊文本格式处理</h3><p>一些用来解析和操作特殊文本格式的库。</p>
<ul>
<li>通用<ul>
<li>tablib：一个用来处理中表格数据的模块。<a href="https://github.com/kennethreitz/tablib" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Office<ul>
<li>Marmir：把输入的Python 数据结构转换为电子表单。<a href="https://github.com/brianray/mm" target="_blank" rel="external">官网</a></li>
<li>openpyxl：一个用来读写 Excel 2010 xlsx/xlsm/xltx/xltm 文件的库。<a href="https://openpyxl.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>python-docx：读取，查询以及修改 Microsoft Word 2007/2008 docx 文件。<a href="https://github.com/python-openxml/python-docx" target="_blank" rel="external">官网</a></li>
<li>unoconv：在 LibreOffice/OpenOffice 支持的任意文件格式之间进行转换。<a href="https://github.com/dagwieers/unoconv" target="_blank" rel="external">官网</a></li>
<li>XlsxWriter：一个用于创建 Excel .xlsx 文件的 Python 模块。<a href="https://xlsxwriter.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>xlwings：一个使得在 Excel 中方便调用 Python 的库（反之亦然），基于 BSD 协议。<a href="http://xlwings.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/xlwt/" target="_blank" rel="external">xlwt</a>：读写 Excel 文件的数据和格式信息。<a href="https://github.com/python-excel/xlwt" target="_blank" rel="external">官网</a> / <a href="https://github.com/python-excel/xlrd" target="_blank" rel="external">xlrd</a></li>
<li>relatorio：模板化OpenDocument 文件。<a href="http://relatorio.tryton.org/" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>PDF<ul>
<li>PDFMiner：一个用于从PDF文档中抽取信息的工具。<a href="https://github.com/euske/pdfminer" target="_blank" rel="external">官网</a></li>
<li>PyPDF2：一个可以分割，合并和转换 PDF 页面的库。<a href="https://github.com/mstamy2/PyPDF2" target="_blank" rel="external">官网</a></li>
<li>ReportLab：快速创建富文本 PDF 文档。<a href="http://www.reportlab.com/opensource/" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Markdown<ul>
<li>Mistune：快速并且功能齐全的纯 Python 实现的 Markdown 解析器。<a href="https://github.com/lepture/mistune" target="_blank" rel="external">官网</a></li>
<li>Python-Markdown：John Gruber’s Markdown 的 Python 版实现。<a href="https://github.com/waylan/Python-Markdown" target="_blank" rel="external">官网</a></li>
<li>Python-Markdiwn2：纯 Python 实现的 Markdown 解析器，比 Python-Markdown 更快，更准确，可扩展。<a href="https://github.com/trentm/python-markdown2" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>YAML<ul>
<li>PyYAML：Python 版本的 YAML 解析器。<a href="http://pyyaml.org/" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>CSV<ul>
<li>csvkit：用于转换和操作 CSV 的工具。<a href="https://github.com/wireservice/csvkit" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Archive<ul>
<li>unp：一个用来方便解包归档文件的命令行工具。<a href="https://github.com/mitsuhiko/unp" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h3><p>用来处理人类语言的库。</p>
<ul>
<li>NLTK：一个先进的平台，用以构建处理人类语言数据的 Python 程序。<a href="http://www.nltk.org/" target="_blank" rel="external">官网</a></li>
<li>jieba：中文分词工具。<a href="https://github.com/fxsjy/jieba" target="_blank" rel="external">官网</a></li>
<li>langid.py：独立的语言识别系统。<a href="https://github.com/saffsd/langid.py" target="_blank" rel="external">官网</a></li>
<li>Pattern：Python 网络信息挖掘模块。<a href="http://www.clips.ua.ac.be/pattern" target="_blank" rel="external">官网</a></li>
<li>SnowNLP：一个用来处理中文文本的库。<a href="https://github.com/isnowfy/snownlp" target="_blank" rel="external">官网</a></li>
<li>TextBlob：为进行普通自然语言处理任务提供一致的 API。<a href="http://textblob.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>TextGrocery：一简单高效的短文本分类工具，基于 LibLinear 和 Jieba。<a href="https://github.com/2shou/TextGrocery" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>用以生成项目文档的库。</p>
<ul>
<li><a href="http://hao.jobbole.com/sphinx/" target="_blank" rel="external">Sphinx</a>：Python 文档生成器。<a href="http://www.sphinx-doc.org/en/latest/" target="_blank" rel="external">官网</a><ul>
<li>awesome-sphinxdoc：<a href="https://github.com/yoloseem/awesome-sphinxdoc" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>MkDocs：对 Markdown 友好的文档生成器。<a href="http://www.mkdocs.org/" target="_blank" rel="external">官网</a></li>
<li>pdoc：一个可以替换Epydoc 的库，可以自动生成 Python 库的 API 文档。<a href="https://github.com/BurntSushi/pdoc" target="_blank" rel="external">官网</a></li>
<li>Pycco：文学编程（literate-programming）风格的文档生成器。<a href="https://github.com/pycco-docs/pycco" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>用来保存和解析配置的库。</p>
<ul>
<li>config：<a href="https://docs.python.org/2/library/logging.html" target="_blank" rel="external">logging</a> 模块作者写的分级配置模块。<a href="https://www.red-dove.com/config-doc/" target="_blank" rel="external">官网</a></li>
<li>ConfigObj：INI 文件解析器，带验证功能。<a href="http://www.voidspace.org.uk/python/configobj.html" target="_blank" rel="external">官网</a></li>
<li>ConfigParser：(Python 标准库) INI 文件解析器。<a href="https://docs.python.org/2/library/configparser.html" target="_blank" rel="external">官网</a></li>
<li>profig：通过多种格式进行配置，具有数值转换功能。<a href="http://profig.readthedocs.org/en/default/" target="_blank" rel="external">官网</a></li>
<li>python-decouple：将设置和代码完全隔离。<a href="https://github.com/henriquebastos/python-decouple" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><p>用于创建命令行程序的库。</p>
<ul>
<li>命令行程序开发<ul>
<li>cement：Python 的命令行程序框架。<a href="http://builtoncement.com/" target="_blank" rel="external">官网</a></li>
<li>click：一个通过组合的方式来创建精美命令行界面的包。<a href="http://click.pocoo.org/dev/" target="_blank" rel="external">官网</a></li>
<li>cliff：一个用于创建命令行程序的框架，可以创建具有多层命令的命令行程序。<a href="http://docs.openstack.org/developer/cliff/" target="_blank" rel="external">官网</a></li>
<li>clint：Python 命令行程序工具。<a href="https://github.com/kennethreitz/clint" target="_blank" rel="external">官网</a></li>
<li>colorama：跨平台彩色终端文本。<a href="https://pypi.python.org/pypi/colorama" target="_blank" rel="external">官网</a></li>
<li>docopt：Python 风格的命令行参数解析器。<a href="http://docopt.org/" target="_blank" rel="external">官网</a></li>
<li>Gooey：一条命令，将命令行程序变成一个 GUI 程序。<a href="https://github.com/chriskiehl/Gooey" target="_blank" rel="external">官网</a></li>
<li>python-prompt-toolkit：一个用于构建强大的交互式命令行程序的库。<a href="https://github.com/jonathanslenders/python-prompt-toolkit" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/pythonpy/" target="_blank" rel="external">Pythonpy</a>：在命令行中直接执行任何Python指令。<a href="https://github.com/Russell91/pythonpy/wiki" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>生产力工具<ul>
<li>aws-cli：Amazon Web Services 的通用命令行界面。<a href="https://github.com/aws/aws-cli" target="_blank" rel="external">官网</a></li>
<li>bashplotlib：在终端中进行基本绘图。<a href="https://github.com/glamp/bashplotlib" target="_blank" rel="external">官网</a></li>
<li>caniusepython3：判断是哪个项目妨碍你你移植到 Python 3。<a href="https://github.com/brettcannon/caniusepython3" target="_blank" rel="external">官网</a></li>
<li>cookiecutter：从 cookiecutters（项目模板）创建项目的一个命令行工具。<a href="https://github.com/audreyr/cookiecutter" target="_blank" rel="external">官网</a></li>
<li>doitlive：一个用来在终端中进行现场演示的工具。<a href="https://github.com/sloria/doitlive" target="_blank" rel="external">官网</a></li>
<li>howdoi：通过命令行获取即时的编程问题解答。<a href="https://github.com/gleitz/howdoi" target="_blank" rel="external">官网</a></li>
<li>httpie：一个命令行HTTP 客户端，cURL 的替代品，易用性更好。<a href="https://github.com/jkbrzt/httpie" target="_blank" rel="external">官网</a></li>
<li>PathPicker：从bash输出中选出文件。<a href="https://github.com/facebook/PathPicker" target="_blank" rel="external">官网</a></li>
<li>percol：向UNIX shell 传统管道概念中加入交互式选择功能。<a href="https://github.com/mooz/percol" target="_blank" rel="external">官网</a></li>
<li>SAWS：一个加强版的 AWS 命令行。<a href="https://github.com/donnemartin/saws" target="_blank" rel="external">官网</a></li>
<li>thefuck：修正你之前的命令行指令。<a href="https://github.com/nvbn/thefuck" target="_blank" rel="external">官网</a></li>
<li>mycli：一个 MySQL 命令行客户端，具有自动补全和语法高亮功能。<a href="https://github.com/dbcli/mycli" target="_blank" rel="external">官网</a></li>
<li>pgcli：Postgres 命令行工具，具有自动补全和语法高亮功能。<a href="https://github.com/dbcli/pgcli" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="下载器"><a href="#下载器" class="headerlink" title="下载器"></a>下载器</h3><p>用来进行下载的库.</p>
<ul>
<li>s3cmd：一个用来管理Amazon S3 和 CloudFront 的命令行工具。<a href="https://github.com/s3tools/s3cmd" target="_blank" rel="external">官网</a></li>
<li>s4cmd：超级 S3 命令行工具，性能更加强劲。<a href="https://github.com/bloomreach/s4cmd" target="_blank" rel="external">官网</a></li>
<li>you-get：一个 YouTube/Youku/Niconico 视频下载器，使用 Python3 编写。<a href="https://www.soimort.org/you-get/" target="_blank" rel="external">官网</a></li>
<li>youtube-dl：一个小巧的命令行程序，用来下载 YouTube 视频。<a href="http://rg3.github.io/youtube-dl/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h3><p>用来操作图像的库.</p>
<ul>
<li><a href="http://hao.jobbole.com/pillow/" target="_blank" rel="external">pillow</a>：Pillow 是一个更加易用版的 <a href="http://www.pythonware.com/products/pil/" target="_blank" rel="external">PIL</a>。<a href="http://pillow.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>hmap：图像直方图映射。<a href="https://github.com/rossgoodwin/hmap" target="_blank" rel="external">官网</a></li>
<li>imgSeek：一个使用视觉相似性搜索一组图片集合的项目。<a href="https://sourceforge.net/projects/imgseek/" target="_blank" rel="external">官网</a></li>
<li>nude.py：裸体检测。<a href="https://github.com/hhatto/nude.py" target="_blank" rel="external">官网</a></li>
<li>pyBarcode：不借助 PIL 库在 Python 程序中生成条形码。<a href="https://pythonhosted.org/pyBarcode/" target="_blank" rel="external">官网</a></li>
<li>pygram：类似 Instagram 的图像滤镜。<a href="https://github.com/ajkumar25/pygram" target="_blank" rel="external">官网</a></li>
<li>python-qrcode：一个纯 Python 实现的二维码生成器。<a href="https://github.com/lincolnloop/python-qrcode" target="_blank" rel="external">官网</a></li>
<li>Quads：基于四叉树的计算机艺术。<a href="https://github.com/fogleman/Quads" target="_blank" rel="external">官网</a></li>
<li>scikit-image：一个用于（科学）图像处理的 Python 库。<a href="http://scikit-image.org/" target="_blank" rel="external">官网</a></li>
<li>thumbor：一个小型图像服务，具有剪裁，尺寸重设和翻转功能。<a href="https://github.com/thumbor/thumbor" target="_blank" rel="external">官网</a></li>
<li>wand：<a href="http://www.imagemagick.org/script/magick-wand.php" target="_blank" rel="external">MagickWand</a>的Python 绑定。MagickWand 是 ImageMagick的 C API 。<a href="https://github.com/dahlia/wand" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="OCR"><a href="#OCR" class="headerlink" title="OCR"></a>OCR</h3><p>光学字符识别库。</p>
<ul>
<li>pyocr：Tesseract 和 Cuneiform 的一个封装(wrapper)。<a href="https://github.com/jflesch/pyocr" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/pytesseract/" target="_blank" rel="external">pytesseract</a>：<a href="https://github.com/tesseract-ocr" target="_blank" rel="external">Google Tesseract OCR</a> 的另一个封装(wrapper)。<a href="https://github.com/madmaze/pytesseract" target="_blank" rel="external">官网</a></li>
<li>python-tesseract - <a href="https://github.com/tesseract-ocr" target="_blank" rel="external">Google Tesseract OCR</a> 的一个包装类。</li>
</ul>
<h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><p>用来操作音频的库</p>
<ul>
<li>audiolazy：Python 的数字信号处理包。<a href="https://github.com/danilobellini/audiolazy" target="_blank" rel="external">官网</a> </li>
<li>audioread：交叉库 (GStreamer + Core Audio + MAD + FFmpeg) 音频解码。<a href="https://github.com/beetbox/audioread" target="_blank" rel="external">官网</a></li>
<li>beets：一个音乐库管理工具及 <a href="https://musicbrainz.org/" target="_blank" rel="external">MusicBrainz</a> 标签添加工具<a href="http://beets.io/" target="_blank" rel="external">官网</a></li>
<li>dejavu：音频指纹提取和识别<a href="https://github.com/worldveil/dejavu" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/django-elastic-transcoder/" target="_blank" rel="external">django-elastic-transcoder</a>：Django + <a href="http://aws.amazon.com/elastictranscoder/" target="_blank" rel="external">Amazon Elastic Transcoder</a>。<a href="https://github.com/StreetVoice/django-elastic-transcoder" target="_blank" rel="external">官网</a></li>
<li>eyeD3：一个用来操作音频文件的工具，具体来讲就是包含 ID3 元信息的 MP3 文件。<a href="http://eyed3.nicfit.net/" target="_blank" rel="external">官网</a></li>
<li>id3reader：一个用来读取 MP3 元数据的 Python 模块。<a href="http://nedbatchelder.com/code/modules/id3reader.py" target="_blank" rel="external">官网</a></li>
<li>m3u8：一个用来解析 m3u8 文件的模块。<a href="https://github.com/globocom/m3u8" target="_blank" rel="external">官网</a></li>
<li>mutagen：一个用来处理音频元数据的 Python 模块。<a href="https://bitbucket.org/lazka/mutagen" target="_blank" rel="external">官网</a></li>
<li>pydub：通过简单、简洁的高层接口来操作音频文件。<a href="https://github.com/jiaaro/pydub" target="_blank" rel="external">官网</a></li>
<li>pyechonest：<a href="http://developer.echonest.com/" target="_blank" rel="external">Echo Nest</a> API 的 Python 客户端<a href="https://github.com/echonest/pyechonest" target="_blank" rel="external">官网</a></li>
<li>talkbox：一个用来处理演讲/信号的 Python 库<a href="http://scikits.appspot.com/talkbox" target="_blank" rel="external">官网</a></li>
<li>TimeSide：开源 web 音频处理框架。<a href="https://github.com/Parisson/TimeSide" target="_blank" rel="external">官网</a></li>
<li>tinytag：一个用来读取MP3, OGG, FLAC 以及 Wave 文件音乐元数据的库。<a href="https://github.com/devsnd/tinytag" target="_blank" rel="external">官网</a></li>
<li>mingus：一个高级音乐理论和曲谱包，支持 MIDI 文件和回放功能。<a href="http://bspaans.github.io/python-mingus/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h3><p>用来操作视频和GIF的库。</p>
<ul>
<li>moviepy：一个用来进行基于脚本的视频编辑模块，适用于多种格式，包括动图 GIFs。<a href="http://zulko.github.io/moviepy/" target="_blank" rel="external">官网</a></li>
<li>scikit-video：SciPy 视频处理常用程序。<a href="https://github.com/aizvorski/scikit-video" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h3><p>地理编码地址以及用来处理经纬度的库。</p>
<ul>
<li>GeoDjango：世界级地理图形 web 框架。<a href="https://docs.djangoproject.com/en/dev/ref/contrib/gis/" target="_blank" rel="external">官网</a></li>
<li>GeoIP：MaxMind GeoIP Legacy 数据库的 Python API。<a href="https://github.com/maxmind/geoip-api-python" target="_blank" rel="external">官网</a></li>
<li>geojson：GeoJSON 的 Python 绑定及工具。<a href="https://github.com/frewsxcv/python-geojson" target="_blank" rel="external">官网</a></li>
<li>geopy：Python 地址编码工具箱。<a href="https://github.com/geopy/geopy" target="_blank" rel="external">官网</a></li>
<li>pygeoip：纯 Python GeoIP API。<a href="https://github.com/appliedsec/pygeoip" target="_blank" rel="external">官网</a></li>
<li>django-countries：一个 Django 应用程序，提供用于表格的国家选择功能，国旗图标静态文件以及模型中的国家字段。<a href="https://github.com/SmileyChris/django-countries" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>使用HTTP的库。</p>
<ul>
<li>requests：人性化的HTTP请求库。<a href="http://docs.python-requests.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>grequests：requests 库 + gevent ，用于异步 HTTP 请求.<a href="https://github.com/kennethreitz/grequests" target="_blank" rel="external">官网</a></li>
<li>httplib2：全面的 HTTP 客户端库。<a href="https://github.com/jcgregorio/httplib2" target="_blank" rel="external">官网</a></li>
<li>treq：类似 requests 的Python API 构建于 Twisted HTTP 客户端之上。<a href="https://github.com/twisted/treq" target="_blank" rel="external">官网</a></li>
<li>urllib3：一个具有线程安全连接池，支持文件 post，清晰友好的 HTTP 库。<a href="https://github.com/shazow/urllib3" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Python实现的数据库。</p>
<ul>
<li>pickleDB：一个简单，轻量级键值储存数据库。<a href="https://pythonhosted.org/pickleDB/" target="_blank" rel="external">官网</a></li>
<li>PipelineDB：流式 SQL 数据库。<a href="https://www.pipelinedb.com/" target="_blank" rel="external">官网</a></li>
<li>TinyDB：一个微型的，面向文档型数据库。<a href="https://github.com/msiemens/tinydb" target="_blank" rel="external">官网</a></li>
<li>ZODB：一个 Python 原生对象数据库。一个键值和对象图数据库。<a href="http://www.zodb.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="数据库驱动"><a href="#数据库驱动" class="headerlink" title="数据库驱动"></a>数据库驱动</h3><p>用来连接和操作数据库的库。</p>
<ul>
<li>MySQL：<a href="http://shlomi-noach.github.io/awesome-mysql/" target="_blank" rel="external">awesome-mysql</a>系列<ul>
<li>mysql-python：Python 的 MySQL 数据库连接器。<a href="https://sourceforge.net/projects/mysql-python/" target="_blank" rel="external">官网</a></li>
<li>ysqlclient：<a href="https://github.com/PyMySQL/mysqlclient-python" target="_blank" rel="external">mysql-python</a> 分支，支持 Python 3。</li>
<li>oursql：一个更好的 MySQL 连接器，支持原生预编译指令和 BLOBs.<a href="https://pythonhosted.org/oursql/" target="_blank" rel="external">官网</a></li>
<li>PyMySQL：纯 Python MySQL 驱动，兼容 mysql-python。<a href="https://github.com/PyMySQL/PyMySQL" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>PostgreSQL<ul>
<li>psycopg2：Python 中最流行的 PostgreSQL 适配器。<a href="http://initd.org/psycopg/" target="_blank" rel="external">官网</a></li>
<li>queries：psycopg2 库的封装，用来和 PostgreSQL 进行交互。<a href="https://github.com/gmr/queries" target="_blank" rel="external">官网</a></li>
<li>txpostgres：基于 Twisted 的异步 PostgreSQL 驱动。<a href="http://txpostgres.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>其他关系型数据库<ul>
<li>apsw：另一个 Python SQLite封装。<a href="http://rogerbinns.github.io/apsw/" target="_blank" rel="external">官网</a></li>
<li>dataset：在数据库中存储Python字典</li>
<li>pymssql：一个简单的Microsoft SQL Server数据库接口。<a href="http://www.pymssql.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>NoSQL 数据库<ul>
<li>cassandra-python-driver：Cassandra 的 Python 驱动。<a href="https://github.com/datastax/python-driver" target="_blank" rel="external">官网</a></li>
<li>HappyBase：一个为 Apache HBase 设计的，对开发者友好的库。<a href="http://happybase.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>Plyvel：一个快速且功能丰富的 LevelDB 的 Python 接口。<a href="https://plyvel.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>py2neo：Neo4j restful 接口的Python 封装客户端。<a href="http://py2neo.org/2.0/" target="_blank" rel="external">官网</a></li>
<li>pycassa：Cassandra 的 Python Thrift 驱动。<a href="https://github.com/pycassa/pycassa" target="_blank" rel="external">官网</a></li>
<li>PyMongo：MongoDB 的官方 Python 客户端。<a href="https://docs.mongodb.org/ecosystem/drivers/python/" target="_blank" rel="external">官网</a></li>
<li>redis-py：Redis 的 Python 客户端。<a href="https://github.com/andymccurdy/redis-py" target="_blank" rel="external">官网</a></li>
<li>telephus：基于 Twisted 的 Cassandra 客户端。<a href="https://github.com/driftx/Telephus" target="_blank" rel="external">官网</a></li>
<li>txRedis：基于 Twisted 的 Redis 客户端。<a href="https://github.com/deldotdr/txRedis" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>实现对象关系映射或数据映射技术的库。</p>
<ul>
<li>关系型数据库<ul>
<li>Django Models：Django 的一部分。<a href="https://docs.djangoproject.com/en/dev/topics/db/models/" target="_blank" rel="external">官网</a></li>
<li>SQLAlchemy：Python SQL 工具以及对象关系映射工具。<a href="http://www.sqlalchemy.org/" target="_blank" rel="external">官网</a><ul>
<li><a href="https://github.com/dahlia/awesome-sqlalchemy" target="_blank" rel="external">awesome-sqlalchemy</a>系列</li>
</ul>
</li>
<li><a href="http://hao.jobbole.com/peewee/" target="_blank" rel="external">Peewee</a>：一个小巧，富有表达力的 ORM。<a href="https://github.com/coleifer/peewee" target="_blank" rel="external">官网</a></li>
<li>PonyORM：提供面向生成器的 SQL 接口的 ORM。<a href="https://ponyorm.com/" target="_blank" rel="external">官网</a></li>
<li>python-sql：编写 Python 风格的 SQL 查询。<a href="https://pypi.python.org/pypi/python-sql" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>NoSQL 数据库<ul>
<li>django-mongodb-engine：Django MongoDB 后端。<a href="https://github.com/django-nonrel/mongodb-engine" target="_blank" rel="external">官网</a></li>
<li>PynamoDB：<a href="https://aws.amazon.com/dynamodb/" target="_blank" rel="external">Amazon DynamoDB</a> 的一个 Python 风格接口。<a href="https://github.com/jlafon/PynamoDB" target="_blank" rel="external">官网</a></li>
<li>flywheel：Amazon DynamoDB 的对象映射工具。<a href="https://github.com/mathcamp/flywheel" target="_blank" rel="external">官网</a></li>
<li>MongoEngine：一个Python 对象文档映射工具，用于 MongoDB。<a href="http://mongoengine.org/" target="_blank" rel="external">官网</a></li>
<li>hot-redis：为 Redis 提供 Python 丰富的数据类型。<a href="https://github.com/stephenmcd/hot-redis" target="_blank" rel="external">官网</a></li>
<li>redisco：一个 Python 库，提供可以持续存在在 Redis 中的简单模型和容器。<a href="https://github.com/kiddouk/redisco" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>其他<ul>
<li>butterdb：Google Drive 电子表格的 Python ORM。<a href="https://github.com/Widdershin/butterdb" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a>Web 框架</h3><p>全栈 Web 框架。</p>
<ul>
<li><a href="http://hao.jobbole.com/django/" target="_blank" rel="external">Django</a>：Python 界最流行的 web 框架。<a href="https://www.djangoproject.com/" target="_blank" rel="external">官网</a><ul>
<li><a href="https://github.com/rosarior/awesome-django" target="_blank" rel="external">awesome-django</a>系列</li>
</ul>
</li>
<li><a href="http://hao.jobbole.com/flask/" target="_blank" rel="external">Flask</a>：一个 Python 微型框架。<a href="http://flask.pocoo.org/" target="_blank" rel="external">官网</a><ul>
<li><a href="https://github.com/humiaozuzu/awesome-flask" target="_blank" rel="external">awesome-flask</a>系列</li>
</ul>
</li>
<li>pyramid：一个小巧，快速，接地气的开源Python web 框架。<ul>
<li><a href="https://github.com/uralbash/awesome-pyramid" target="_blank" rel="external">awesome-pyramid</a>系列</li>
</ul>
</li>
<li><a href="http://hao.jobbole.com/bottle/" target="_blank" rel="external">Bottle</a>：一个快速小巧，轻量级的 WSGI 微型 web 框架。<a href="http://bottlepy.org/docs/dev/index.html" target="_blank" rel="external">官网</a></li>
<li>CherryPy：一个极简的 Python web 框架，服从 HTTP/1.1 协议且具有WSGI 线程池。<a href="http://www.cherrypy.org/" target="_blank" rel="external">官网</a></li>
<li>TurboGears：一个可以扩展为全栈解决方案的微型框架。<a href="http://www.turbogears.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/python-webpy/" target="_blank" rel="external">web.py</a>：一个 Python 的 web 框架，既简单，又强大。<a href="http://webpy.org/" target="_blank" rel="external">官网</a></li>
<li>web2py：一个全栈 web 框架和平台，专注于简单易用。<a href="http://www.web2py.com/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/tornado/" target="_blank" rel="external">Tornado</a>：一个web 框架和异步网络库。<a href="http://www.tornadoweb.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>允许或拒绝用户访问数据或功能的库。</p>
<ul>
<li>Carteblanche：Module to align code with thoughts of users and designers. Also magically handles navigation and permissions.<a href="https://github.com/neuman/python-carteblanche/" target="_blank" rel="external">官网</a></li>
<li>django-guardian：Django 1.2+ 实现了单个对象权限。<a href="https://github.com/django-guardian/django-guardian" target="_blank" rel="external">官网</a></li>
<li>django-rules：一个小巧但是强大的应用，提供对象级别的权限管理，且不需要使用数据库。<a href="https://github.com/dfunckt/django-rules" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>内容管理系统</p>
<ul>
<li>odoo-cms: 一个开源的，企业级 CMS，基于odoo。<a href="http://www.odoo.com" target="_blank" rel="external">官网</a></li>
<li>django-cms：一个开源的，企业级 CMS，基于 Django。<a href="http://www.django-cms.org/en/" target="_blank" rel="external">官网</a></li>
<li>djedi-cms：一个轻量级但却非常强大的 Django CMS ，考虑到了插件，内联编辑以及性能。<a href="http://djedi-cms.org/" target="_blank" rel="external">官网</a></li>
<li>FeinCMS：基于 Django 构建的最先进的内容管理系统之一。<a href="http://www.feincms.org/" target="_blank" rel="external">官网</a></li>
<li>Kotti：一个高级的，Python 范的 web 应用框架，基于 Pyramid 构建。<a href="http://kotti.pylonsproject.org/" target="_blank" rel="external">官网</a></li>
<li>Mezzanine：一个强大的，持续的，灵活的内容管理平台。<a href="http://mezzanine.jupo.org/" target="_blank" rel="external">官网</a></li>
<li>Opps：一个为杂志，报纸网站以及大流量门户网站设计的 CMS 平台，基于 Django。<a href="http://opps.github.io/opps/" target="_blank" rel="external">官网</a></li>
<li>Plone：一个构建于开源应用服务器 Zope 之上的 CMS。<a href="https://plone.org/" target="_blank" rel="external">官网</a></li>
<li>Quokka：灵活，可扩展的小型 CMS，基于 Flask 和 MongoDB。<a href="http://quokkaproject.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/wagtail/" target="_blank" rel="external">Wagtail</a>：一个 Django 内容管理系统。<a href="https://wagtail.io/" target="_blank" rel="external">官网</a></li>
<li>Widgy：最新的 CMS 框架，基于 Django。<a href="https://wid.gy/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="电子商务"><a href="#电子商务" class="headerlink" title="电子商务"></a>电子商务</h3><p>用于电子商务以及支付的框架和库。</p>
<ul>
<li>django-oscar：一个用于 Django 的开源的电子商务框架。<a href="http://oscarcommerce.com/" target="_blank" rel="external">官网</a></li>
<li>django-shop：一个基于 Django 的店铺系统。<a href="https://github.com/awesto/django-shop" target="_blank" rel="external">官网</a></li>
<li>Cartridge：一个基于 Mezzanine 构建的购物车应用。<a href="https://github.com/stephenmcd/cartridge" target="_blank" rel="external">官网</a></li>
<li>shoop：一个基于 Django 的开源电子商务平台。<a href="https://www.shoop.io/en/" target="_blank" rel="external">官网</a></li>
<li>alipay：非官方的 Python 支付宝 API。<a href="https://github.com/lxneng/alipay" target="_blank" rel="external">官网</a></li>
<li>merchant：一个可以接收来自多种支付平台支付的 Django 应用。<a href="https://github.com/agiliq/merchant" target="_blank" rel="external">官网</a></li>
<li>money：货币类库with optional CLDR-backed locale-aware formatting and an extensible currency exchange solution.<a href="https://github.com/carlospalol/money" target="_blank" rel="external">官网</a></li>
<li>python-currencies：显示货币格式以及它的数值。<a href="https://github.com/Alir3z4/python-currencies" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>用来开发RESTful APIs的库</p>
<ul>
<li>Django<ul>
<li><a href="http://hao.jobbole.com/django-rest-framework/" target="_blank" rel="external">django-rest-framework</a>：一个强大灵活的工具，用来构建 web API。<a href="http://www.django-rest-framework.org/" target="_blank" rel="external">官网</a></li>
<li>django-tastypie：为Django 应用开发API。<a href="http://tastypieapi.org/" target="_blank" rel="external">官网</a></li>
<li>django-formapi：为 Django 的表单验证，创建 JSON APIs 。<a href="https://github.com/5monkeys/django-formapi" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Flask<ul>
<li>flask-api：为 flask 开发的，可浏览 Web APIs 。<a href="http://www.flaskapi.org/" target="_blank" rel="external">官网</a></li>
<li>flask-restful：为 flask 快速创建REST APIs 。<a href="http://flask-restful.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>flask-restless：为 SQLAlchemy 定义的数据库模型创建 RESTful APIs 。<a href="https://flask-restless.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>flask-api-utils：为 Flask 处理 API 表示和验证。<a href="https://github.com/marselester/flask-api-utils" target="_blank" rel="external">官网</a></li>
<li>eve：REST API 框架，由 Flask, MongoDB 等驱动。<a href="https://github.com/nicolaiarocci/eve" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Pyramid<ul>
<li>cornice：一个Pyramid 的 REST 框架 。<a href="https://cornice.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>与框架无关的<ul>
<li>falcon：一个用来建立云 API 和 web app 后端的高性能框架。<a href="http://falconframework.org/" target="_blank" rel="external">官网</a></li>
<li>sandman：为现存的数据库驱动系统自动创建 REST APIs 。<a href="https://github.com/jeffknupp/sandman" target="_blank" rel="external">官网</a></li>
<li>restless：框架无关的 REST 框架 ，基于从 Tastypie 学到的知识。<a href="http://restless.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>ripozo：快速创建 REST/HATEOAS/Hypermedia APIs。<a href="https://github.com/vertical-knowledge/ripozo" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>实现验证方案的库。</p>
<ul>
<li>OAuth<ul>
<li>Authomatic：简单但是强大的框架，身份验证/授权客户端。<a href="http://peterhudec.github.io/authomatic/" target="_blank" rel="external">官网</a></li>
<li>django-allauth：Django 的验证应用。<a href="https://github.com/pennersr/django-allauth" target="_blank" rel="external">官网</a></li>
<li>django-oauth-toolkit：为 Django 用户准备的 OAuth2。<a href="https://github.com/evonove/django-oauth-toolkit" target="_blank" rel="external">官网</a></li>
<li>django-oauth2-provider：为 Django 应用提供 OAuth2 接入。<a href="https://github.com/caffeinehit/django-oauth2-provider" target="_blank" rel="external">官网</a></li>
<li>Flask-OAuthlib：OAuth 1.0/a, 2.0 客户端实现，供 Flask 使用。<a href="https://github.com/lepture/flask-oauthlib" target="_blank" rel="external">官网</a></li>
<li>OAuthLib：一个 OAuth 请求-签名逻辑通用、 完整的实现。<a href="https://github.com/idan/oauthlib" target="_blank" rel="external">官网</a></li>
<li>python-oauth2：一个完全测试的抽象接口。用来创建 OAuth 客户端和服务端。<a href="https://github.com/joestump/python-oauth2" target="_blank" rel="external">官网</a></li>
<li>python-social-auth：一个设置简单的社会化验证方式。<a href="https://github.com/omab/python-social-auth" target="_blank" rel="external">官网</a></li>
<li>rauth：OAuth 1.0/a, 2.0, 和 Ofly 的 Python 库。<a href="https://github.com/litl/rauth" target="_blank" rel="external">官网</a></li>
<li>sanction：一个超级简单的OAuth2 客户端实现。<a href="https://github.com/demianbrecht/sanction" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>其他<ul>
<li>jose：JavaScript 对象签名和加密草案的实现。<a href="https://github.com/demonware/jose" target="_blank" rel="external">官网</a></li>
<li>PyJWT：JSON Web 令牌草案 01。<a href="https://github.com/jpadilla/pyjwt" target="_blank" rel="external">官网</a></li>
<li>python-jws：JSON Web 签名草案 02 的实现。<a href="https://github.com/brianloveswords/python-jws" target="_blank" rel="external">官网</a></li>
<li>python-jwt：一个用来生成和验证 JSON Web 令牌的模块。<a href="https://github.com/davedoesdev/python-jwt" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>模板生成和词法解析的库和工具。</p>
<ul>
<li><a href="http://hao.jobbole.com/jinja2/" target="_blank" rel="external">Jinja2</a>：一个现代的，对设计师友好的模板引擎。<a href="https://github.com/pallets/jinja" target="_blank" rel="external">官网</a></li>
<li>Chameleon：一个 HTML/XML 模板引擎。 模仿了 ZPT（Zope Page Templates）, 进行了速度上的优化。<a href="https://chameleon.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>Genshi：Python 模板工具，用以生成 web 感知的结果。<a href="https://genshi.edgewall.org/" target="_blank" rel="external">官网</a></li>
<li>Mako：Python 平台的超高速轻量级模板。<a href="http://www.makotemplates.org/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>处理事件以及任务队列的库。</p>
<ul>
<li>celery：一个异步任务队列/作业队列，基于分布式消息传递。<a href="http://www.celeryproject.org/" target="_blank" rel="external">官网</a></li>
<li>huey：小型多线程任务队列。<a href="https://github.com/coleifer/huey" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/mrq/" target="_blank" rel="external">mrq</a>：Mr. Queue -一个 Python 的分布式 worker 任务队列， 使用 Redis 和 gevent。<a href="https://github.com/pricingassistant/mrq" target="_blank" rel="external">官网</a></li>
<li>rq：简单的 Python 作业队列。<a href="http://python-rq.org/" target="_blank" rel="external">官网</a></li>
<li>simpleq：一个简单的，可无限扩张的，基于亚马逊 SQS 的队列。<a href="https://github.com/rdegges/simpleq" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>对数据进行索引和执行搜索查询的库和软件。</p>
<ul>
<li>django-haystack：Django 模块化搜索。<a href="https://github.com/django-haystack/django-haystack" target="_blank" rel="external">官网</a></li>
<li>elasticsearch-py：Elasticsearch 的官方底层 Python 客户端。<a href="https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/index.html" target="_blank" rel="external">官网</a></li>
<li>elasticsearch-dsl-py：Elasticsearch 的官方高级 Python 客户端。<a href="https://github.com/elastic/elasticsearch-dsl-py" target="_blank" rel="external">官网</a> </li>
<li>solrpy：<a href="http://lucene.apache.org/solr/" target="_blank" rel="external">solr</a>的 Python 客户端。<a href="https://github.com/edsu/solrpy" target="_blank" rel="external">官网</a></li>
<li>Whoosh：一个快速的纯 Python 搜索引擎库。<a href="http://whoosh.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="动态消息"><a href="#动态消息" class="headerlink" title="动态消息"></a>动态消息</h3><p>用来创建用户活动的库。</p>
<ul>
<li>django-activity-stream：从你的站点行为中生成通用活动信息流。<a href="https://github.com/justquick/django-activity-stream" target="_blank" rel="external">官网</a></li>
<li>Stream-Framework：使用 Cassandra 和 Redis 创建动态消息和通知系统。<a href="https://github.com/tschellenbach/Stream-Framework" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><p>管理、压缩、缩小网站资源的工具。</p>
<ul>
<li>django-compressor：将链接和内联的 JavaScript 或 CSS 压缩到一个单独的缓存文件中。<a href="https://github.com/django-compressor/django-compressor" target="_blank" rel="external">官网</a></li>
<li>django-storages：一个针对 Django 的自定义存储后端的工具集合。<a href="http://django-storages.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>fanstatic：打包、优化，并且把静态文件依赖作为 Python 的包来提供。<a href="http://www.fanstatic.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>File Conveyor：一个后台驻留的程序，用来发现和同步文件到 CDNs, S3 和 FTP。<a href="http://fileconveyor.org/" target="_blank" rel="external">官网</a></li>
<li>Flask-Assets：帮你将 web 资源整合到你的 Flask app 中。<a href="http://flask-assets.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>jinja-assets-compressor：一个 Jinja 扩展，用来编译和压缩你的资源。<a href="https://github.com/jaysonsantos/jinja-assets-compressor" target="_blank" rel="external">官网</a></li>
<li>webassets：为你的静态资源打包、优化和管理生成独一无二的缓存 URL。<a href="http://webassets.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存数据的库。</p>
<ul>
<li>Beaker：一个缓存和会话库，可以用在 web 应用和独立 Python脚本和应用上。<a href="http://beaker.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>django-cache-machine：Django 模型的自动缓存和失效。<a href="https://github.com/django-cache-machine/django-cache-machine" target="_blank" rel="external">官网</a></li>
<li>django-cacheops：具有自动颗粒化事件驱动失效功能的 ORM。<a href="https://github.com/Suor/django-cacheops" target="_blank" rel="external">官网</a></li>
<li>django-viewlet：渲染模板，同时具有额外的缓存控制功能。<a href="https://github.com/5monkeys/django-viewlet" target="_blank" rel="external">官网</a></li>
<li>dogpile.cache：dogpile.cache 是 Beaker 的下一代替代品，由同一作者开发。<a href="http://dogpilecache.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>HermesCache：Python 缓存库，具有基于标签的失效和 dogpile effect 保护功能。<a href="https://pypi.python.org/pypi/HermesCache" target="_blank" rel="external">官网</a></li>
<li>johnny-cache：django应用缓存框架。<a href="https://github.com/jmoiron/johnny-cache" target="_blank" rel="external">官网</a></li>
<li>pylibmc：<a href="http://libmemcached.org/libMemcached.html" target="_blank" rel="external">libmemcached</a> 接口的 Python 封装。<a href="https://github.com/lericson/pylibmc" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><p>用来发送和解析电子邮件的库。</p>
<ul>
<li>django-celery-ses：带有 AWS SES 和 Celery 的 Django email 后端。<a href="https://github.com/StreetVoice/django-celery-ses" target="_blank" rel="external">官网</a></li>
<li>envelopes：供人类使用的电子邮件库。<a href="http://tomekwojcik.github.io/envelopes/" target="_blank" rel="external">官网</a></li>
<li>flanker：一个 email 地址和 Mime 解析库。<a href="https://github.com/mailgun/flanker" target="_blank" rel="external">官网</a></li>
<li>imbox：Python IMAP 库<a href="https://github.com/martinrusev/imbox" target="_blank" rel="external">官网</a></li>
<li>inbox.py：Python SMTP 服务器。<a href="https://github.com/kennethreitz/inbox.py" target="_blank" rel="external">官网</a></li>
<li>inbox：一个开源电子邮件工具箱。<a href="https://github.com/nylas/sync-engine" target="_blank" rel="external">官网</a></li>
<li>lamson：Python 风格的 SMTP 应用服务器。<a href="https://github.com/zedshaw/lamson" target="_blank" rel="external">官网</a></li>
<li>mailjet：Mailjet API 实现，用来提供批量发送邮件，统计等功能。<a href="https://github.com/WoLpH/mailjet" target="_blank" rel="external">官网</a></li>
<li>marrow.mailer：高性能可扩展邮件分发框架。<a href="https://github.com/marrow/mailer" target="_blank" rel="external">官网</a></li>
<li>modoboa：一个邮件托管和管理平台，具有现代的、简约的 Web UI。<a href="https://github.com/tonioo/modoboa" target="_blank" rel="external">官网</a></li>
<li>pyzmail：创建，发送和解析电子邮件。<a href="http://www.magiksys.net/pyzmail/" target="_blank" rel="external">官网</a></li>
<li>Talon：Mailgun 库，用来抽取信息和签名。<a href="https://github.com/mailgun/talon" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p>用来进行国际化的库。</p>
<ul>
<li>Babel：一个Python 的国际化库。<a href="http://babel.pocoo.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>Korean：一个韩语词态库。<a href="https://korean.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="URL处理"><a href="#URL处理" class="headerlink" title="URL处理"></a>URL处理</h3><p>解析URLs的库</p>
<ul>
<li>furl：一个让处理 URL 更简单小型 Python 库。<a href="https://github.com/gruns/furl" target="_blank" rel="external">官网</a></li>
<li>purl：一个简单的，不可变的URL类，具有简洁的 API 来进行询问和处理。<a href="https://github.com/codeinthehole/purl" target="_blank" rel="external">官网</a></li>
<li>pyshorteners：一个纯 Python URL 缩短库。<a href="https://github.com/ellisonleao/pyshorteners" target="_blank" rel="external">官网</a></li>
<li>shorturl：生成短小 URL 和类似 bit.ly 短链的Python 实现。<a href="https://github.com/Alir3z4/python-shorturl" target="_blank" rel="external">官网</a></li>
<li>webargs：一个解析 HTTP 请求参数的库，内置对流行 web 框架的支持，包括 Flask, Django, Bottle, Tornado和 Pyramid。<a href="https://github.com/sloria/webargs" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="HTML处理"><a href="#HTML处理" class="headerlink" title="HTML处理"></a>HTML处理</h3><p>处理 HTML和XML的库。</p>
<ul>
<li>BeautifulSoup：以 Python 风格的方式来对 HTML 或 XML 进行迭代，搜索和修改。<a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/" target="_blank" rel="external">官网</a></li>
<li>bleach：一个基于白名单的 HTML 清理和文本链接库。<a href="http://bleach.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>cssutils：一个 Python 的 CSS 库。<a href="https://pypi.python.org/pypi/cssutils/" target="_blank" rel="external">官网</a></li>
<li>html5lib：一个兼容标准的 HTML 文档和片段解析及序列化库。<a href="https://github.com/html5lib/html5lib-python" target="_blank" rel="external">官网</a></li>
<li>lxml：一个非常快速，简单易用，功能齐全的库，用来处理 HTML 和 XML。<a href="http://lxml.de/" target="_blank" rel="external">官网</a></li>
<li>MarkupSafe：为Python 实现 XML/HTML/XHTML 标记安全字符串。<a href="https://github.com/pallets/markupsafe" target="_blank" rel="external">官网</a></li>
<li>pyquery：一个解析 HTML 的库，类似 jQuery。<a href="https://github.com/gawel/pyquery" target="_blank" rel="external">官网</a></li>
<li>untangle：将XML文档转换为Python对象，使其可以方便的访问。<a href="https://github.com/stchris/untangle" target="_blank" rel="external">官网</a></li>
<li>xhtml2pdf：HTML/CSS 转 PDF 工具。<a href="https://github.com/xhtml2pdf/xhtml2pdf" target="_blank" rel="external">官网</a></li>
<li>xmltodict：像处理 JSON 一样处理 XML。<a href="https://github.com/martinblech/xmltodict" target="_blank" rel="external">官网</a></li>
</ul>
<p>爬取网络站点的库</p>
<ul>
<li>Scrapy：一个快速高级的屏幕爬取及网页采集框架。<a href="http://scrapy.org/" target="_blank" rel="external">官网</a></li>
<li>cola：一个分布式爬虫框架。<a href="https://github.com/chineking/cola" target="_blank" rel="external">官网</a></li>
<li>Demiurge：基于PyQuery 的爬虫微型框架。<a href="https://github.com/matiasb/demiurge" target="_blank" rel="external">官网</a></li>
<li>feedparser：通用 feed 解析器。<a href="http://pythonhosted.org/feedparser/" target="_blank" rel="external">官网</a></li>
<li>Grab：站点爬取框架。<a href="http://grablib.org/" target="_blank" rel="external">官网</a></li>
<li>MechanicalSoup：用于自动和网络站点交互的 Python 库。<a href="https://github.com/hickford/MechanicalSoup" target="_blank" rel="external">官网</a></li>
<li>portia：Scrapy 可视化爬取。<a href="https://github.com/scrapinghub/portia" target="_blank" rel="external">官网</a></li>
<li>pyspider：一个强大的爬虫系统。<a href="https://github.com/binux/pyspider" target="_blank" rel="external">官网</a></li>
<li>RoboBrowser：一个简单的，Python 风格的库，用来浏览网站，而不需要一个独立安装的浏览器。<a href="https://github.com/jmcarp/robobrowser" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="网页内容提取"><a href="#网页内容提取" class="headerlink" title="网页内容提取"></a>网页内容提取</h3><p>用于进行网页内容提取的库。</p>
<ul>
<li>Haul：一个可以扩展的图像爬取工具。<a href="https://github.com/vinta/Haul" target="_blank" rel="external">官网</a></li>
<li>html2text：将 HTML 转换为 Markdown 格式文本<a href="https://github.com/Alir3z4/html2text" target="_blank" rel="external">官网</a></li>
<li>lassie：人性化的网页内容检索库。<a href="https://github.com/michaelhelmick/lassie" target="_blank" rel="external">官网</a></li>
<li>micawber：一个小型网页内容提取库，用来从 URLs 提取富内容。<a href="https://github.com/coleifer/micawber" target="_blank" rel="external">官网</a> </li>
<li><a href="http://hao.jobbole.com/python-newspaper/" target="_blank" rel="external">newspaper</a>：使用 Python 进行新闻提取，文章提取以及内容策展。<a href="https://github.com/codelucas/newspaper" target="_blank" rel="external">官网</a></li>
<li>opengraph：一个用来解析开放内容协议(Open Graph Protocol)的 Python模块。<a href="https://github.com/erikriver/opengraph" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/python-goose/" target="_blank" rel="external">python-goose</a>：HTML内容/文章提取器。<a href="https://github.com/grangier/python-goose" target="_blank" rel="external">官网</a></li>
<li>python-readability：arc90 公司 readability 工具的 Python 高速端口。<a href="https://github.com/buriy/python-readability" target="_blank" rel="external">官网</a></li>
<li>sanitize：为杂乱的数据世界带来调理性。<a href="https://github.com/Alir3z4/python-sanitize" target="_blank" rel="external">官网</a></li>
<li>sumy：一个为文本文件和 HTML 页面进行自动摘要的模块。<a href="https://github.com/miso-belica/sumy" target="_blank" rel="external">官网</a></li>
<li>textract：从任何格式的文档中提取文本，Word，PowerPoint，PDFs 等等。<a href="https://github.com/deanmalmgren/textract" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>进行表单操作的库。</p>
<ul>
<li>Deform：Python HTML 表单生成库，受到了 formish 表单生成库的启发。<a href="http://deform.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>django-bootstrap3：集成了 Bootstrap 3 的 Django。<a href="https://github.com/dyve/django-bootstrap3" target="_blank" rel="external">官网</a></li>
<li>django-crispy-forms：一个 Django 应用，他可以让你以一种非常优雅且 DRY（Don’t repeat yourself） 的方式来创建美观的表单。<a href="http://django-crispy-forms.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>django-remote-forms：一个平台独立的 Django 表单序列化工具。<a href="https://github.com/WiserTogether/django-remote-forms" target="_blank" rel="external">官网</a></li>
<li>WTForms：一个灵活的表单验证和呈现库。<a href="http://wtforms.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>WTForms-JSON：一个 WTForms 扩展，用来处理 JSON 数据。<a href="http://wtforms-json.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h3><p>数据验证库。多用于表单验证。</p>
<ul>
<li>Cerberus：A mappings-validator with a variety of rules, normalization-features and simple customization that uses a pythonic schema-definition.<a href="http://docs.python-cerberus.org/en/stable/" target="_blank" rel="external">官网</a></li>
<li>colander：一个用于对从 XML, JSON，HTML 表单获取的数据或其他同样简单的序列化数据进行验证和反序列化的系统。<a href="http://docs.pylonsproject.org/projects/colander/en/latest/" target="_blank" rel="external">官网</a></li>
<li>kmatch：一种用于匹配/验证/筛选 Python 字典的语言。<a href="https://github.com/ambitioninc/kmatch" target="_blank" rel="external">官网</a></li>
<li>schema：一个用于对 Python 数据结构进行验证的库。<a href="https://github.com/keleshev/schema" target="_blank" rel="external">官网</a> </li>
<li>Schematics：数据结构验证。<a href="https://github.com/schematics/schematics" target="_blank" rel="external">官网</a></li>
<li>valideer：轻量级可扩展的数据验证和适配库。<a href="https://github.com/podio/valideer" target="_blank" rel="external">官网</a></li>
<li>voluptuous：一个 Python 数据验证库。主要是为了验证传入 Python的 JSON，YAML 等数据。<a href="https://github.com/alecthomas/voluptuous" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="反垃圾技术"><a href="#反垃圾技术" class="headerlink" title="反垃圾技术"></a>反垃圾技术</h3><p>帮助你和电子垃圾进行战斗的库。</p>
<ul>
<li>django-simple-captcha：一个简单、高度可定制的Django 应用，可以为任何Django表单添加验证码。<a href="https://github.com/mbi/django-simple-captcha" target="_blank" rel="external">官网</a></li>
<li>django-simple-spam-blocker：一个用于Django的简单的电子垃圾屏蔽工具。<a href="https://github.com/moqada/django-simple-spam-blocker" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p>用来进行标记的库。</p>
<ul>
<li>django-taggit：简单的 Django 标记工具。<a href="https://github.com/alex/django-taggit" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="管理面板"><a href="#管理面板" class="headerlink" title="管理面板"></a>管理面板</h3><p>管理界面库。</p>
<ul>
<li>Ajenti：一个你的服务器值得拥有的管理面板。<a href="https://github.com/Eugeny/ajenti" target="_blank" rel="external">官网</a></li>
<li>django-suit：Django 管理界面的一个替代品 (仅对于非商业用途是免费的)。<a href="http://djangosuit.com/" target="_blank" rel="external">官网</a></li>
<li>django-xadmin：Django admin 的一个替代品，具有很多不错的功能。<a href="https://github.com/sshwsfc/django-xadmin" target="_blank" rel="external">官网</a></li>
<li>flask-admin：一个用于 Flask 的简单可扩展的管理界面框架。<a href="https://github.com/flask-admin/flask-admin" target="_blank" rel="external">官网</a></li>
<li>flower：一个对 Celery 集群进行实时监控和提供 web 管理界面的工具。<a href="https://github.com/mher/flower" target="_blank" rel="external">官网</a></li>
<li>Grappelli：Django 管理界面的一个漂亮的皮肤。<a href="http://grappelliproject.com/" target="_blank" rel="external">官网</a> </li>
<li>Wooey：一个 Django 应用，可以为 Python 脚本创建 web 用户界面。<a href="https://github.com/wooey/wooey" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="静态站点生成器"><a href="#静态站点生成器" class="headerlink" title="静态站点生成器"></a>静态站点生成器</h3><p>静态站点生成器是一个软件，它把文本和模板作为输入，然后输出HTML文件。</p>
<ul>
<li>Pelican：使用 Markdown 或 ReST 来处理内容， Jinja 2 来制作主题。支持 DVCS, Disqus.。AGPL 许可。<a href="http://blog.getpelican.com/" target="_blank" rel="external">官网</a></li>
<li>Cactus：为设计师设计的静态站点生成器。<a href="https://github.com/koenbok/Cactus/" target="_blank" rel="external">官网</a> </li>
<li>Hyde：基于 Jinja2 的静态站点生成器。<a href="http://hyde.github.io/" target="_blank" rel="external">官网</a></li>
<li>Nikola：一个静态网站和博客生成器。<a href="https://www.getnikola.com/" target="_blank" rel="external">官网</a></li>
<li>Tinkerer：Tinkerer 是一个博客引擎/静态站点生成器，由Sphinx驱动。<a href="http://tinkerer.me/" target="_blank" rel="external">官网</a></li>
<li>Lektor：一个简单易用的静态 CMS 和博客引擎。<a href="https://www.getlektor.com/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>操作系统进程启动及通信库。</p>
<ul>
<li>envoy：比 Python <a href="https://docs.python.org/2/library/subprocess.html" target="_blank" rel="external">subprocess</a> 模块更人性化。<a href="https://github.com/kennethreitz/envoy" target="_blank" rel="external">官网</a></li>
<li>sarge：另一 种 subprocess 模块的封装。<a href="http://sarge.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>sh：一个完备的 subprocess 替代库。<a href="https://github.com/amoffat/sh" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>用以进行并发和并行操作的库。</p>
<ul>
<li>multiprocessing：(Python 标准库) 基于进程的“线程”接口。<a href="https://docs.python.org/2/library/multiprocessing.html" target="_blank" rel="external">官网</a></li>
<li>threading：(Python 标准库)更高层的线程接口。<a href="https://docs.python.org/2/library/threading.html" target="_blank" rel="external">官网</a></li>
<li>eventlet：支持 WSGI 的异步框架。<a href="http://eventlet.net/" target="_blank" rel="external">官网</a></li>
<li>gevent：一个基于协程的 Python 网络库，使用<a href="https://github.com/python-greenlet/greenlet" target="_blank" rel="external">greenlet</a>。<a href="http://www.gevent.org/" target="_blank" rel="external">官网</a></li>
<li>Tomorrow：用于产生异步代码的神奇的装饰器语法实现。<a href="https://github.com/madisonmay/Tomorrow" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>用于网络编程的库。</p>
<ul>
<li>asyncio：(Python 标准库) 异步 I/O, 事件循环, 协程以及任务。<a href="https://docs.python.org/3/library/asyncio.html" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/twisted/" target="_blank" rel="external">Twisted</a>：一个事件驱动的网络引擎。<a href="https://twistedmatrix.com/trac/" target="_blank" rel="external">官网</a></li>
<li>pulsar：事件驱动的并发框架。<a href="https://github.com/quantmind/pulsar" target="_blank" rel="external">官网</a></li>
<li>diesel：基于Greenlet 的事件 I/O 框架。<a href="https://github.com/dieseldev/diesel" target="_blank" rel="external">官网</a></li>
<li>pyzmq：一个 ZeroMQ 消息库的 Python 封装。<a href="http://zeromq.github.io/pyzmq/" target="_blank" rel="external">官网</a></li>
<li>txZMQ：基于 Twisted 的 ZeroMQ 消息库的 Python 封装。<a href="https://github.com/smira/txZMQ" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>帮助使用WebSocket的库。</p>
<ul>
<li>AutobahnPython：给 Python 、使用的 WebSocket &amp; WAMP 基于 Twisted 和 <a href="https://docs.python.org/3/library/asyncio.html" target="_blank" rel="external">asyncio</a>。<a href="https://github.com/crossbario/autobahn-python" target="_blank" rel="external">官网</a></li>
<li>Crossbar：开源统一应用路由(Websocket &amp; WAMP for Python on Autobahn).<a href="https://github.com/crossbario/crossbar/" target="_blank" rel="external">官网</a></li>
<li>django-socketio：给 Django 用的 WebSockets。<a href="https://github.com/stephenmcd/django-socketio" target="_blank" rel="external">官网</a></li>
<li>WebSocket-for-Python：为Python2/3 以及 PyPy 编写的 WebSocket 客户端和服务器库。<a href="https://github.com/Lawouach/WebSocket-for-Python" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="WSGI-服务器"><a href="#WSGI-服务器" class="headerlink" title="WSGI 服务器"></a>WSGI 服务器</h3><p>兼容 WSGI 的 web 服务器</p>
<ul>
<li>gunicorn：Pre-forked, 部分是由 C 语言编写的。<a href="https://pypi.python.org/pypi/gunicorn" target="_blank" rel="external">官网</a></li>
<li>uwsgi：uwsgi 项目的目的是开发一组全栈工具，用来建立托管服务， 由 C 语言编写。<a href="https://uwsgi-docs.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/bjoern/" target="_blank" rel="external">bjoern</a>：异步，非常快速，由 C 语言编写。<a href="https://pypi.python.org/pypi/bjoern" target="_blank" rel="external">官网</a></li>
<li>fapws3：异步 (仅对于网络端)，由 C 语言编写。<a href="http://www.fapws.org/" target="_blank" rel="external">官网</a></li>
<li>meinheld：异步，部分是由 C 语言编写的。<a href="https://pypi.python.org/pypi/meinheld" target="_blank" rel="external">官网</a></li>
<li>netius：异步，非常快速。<a href="https://github.com/hivesolutions/netius" target="_blank" rel="external">官网</a></li>
<li>paste：多线程，稳定，久经考验。<a href="http://pythonpaste.org/" target="_blank" rel="external">官网</a></li>
<li>rocket：多线程。<a href="https://pypi.python.org/pypi/rocket" target="_blank" rel="external">官网</a></li>
<li>waitress：多线程, 是它驱动着 Pyramid 框架。<a href="https://waitress.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>Werkzeug：一个 WSGI 工具库，驱动着 Flask ，而且可以很方便大嵌入到你的项目中去。<a href="http://werkzeug.pocoo.org/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="RPC-服务器"><a href="#RPC-服务器" class="headerlink" title="RPC 服务器"></a>RPC 服务器</h3><p>兼容 RPC 的服务器。</p>
<ul>
<li>SimpleJSONRPCServer：这个库是 JSON-RPC 规范的一个实现。<a href="https://github.com/joshmarshall/jsonrpclib/" target="_blank" rel="external">官网</a></li>
<li>SimpleXMLRPCServer：(Python 标准库) 简单的 XML-RPC 服务器实现，单线程。<a href="https://docs.python.org/2/library/simplexmlrpcserver.html" target="_blank" rel="external">官网</a></li>
<li>zeroRPC：zerorpc 是一个灵活的 RPC 实现，基于 ZeroMQ 和 MessagePack。<a href="https://github.com/0rpc/zerorpc-python" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h3><ul>
<li>cryptography：这个软件包意在提供密码学基本内容和方法提供给 Python 开发者。<a href="https://cryptography.io/en/latest/" target="_blank" rel="external">官网</a></li>
<li>hashids：在 Python 中实现 <a href="http://hashids.org/" target="_blank" rel="external">hashids</a> 。<a href="https://github.com/davidaurelio/hashids-python" target="_blank" rel="external">官网</a></li>
<li>Paramiko：SSHv2 协议的 Python (2.6+, 3.3+) ，提供客户端和服务端的功能。<a href="http://www.paramiko.org/" target="_blank" rel="external">官网</a></li>
<li>Passlib：安全密码存储／哈希库，<a href="https://pythonhosted.org/passlib/" target="_blank" rel="external">官网</a></li>
<li>PyCrypto：Python 密码学工具箱。<a href="https://www.dlitz.net/software/pycrypto/" target="_blank" rel="external">官网</a></li>
<li>PyNacl：网络和密码学(NaCl) 库的 Python 绑定。<a href="https://github.com/pyca/pynacl" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a>图形用户界面</h3><p>用来创建图形用户界面程序的库。</p>
<ul>
<li>curses：内建的 <a href="http://www.gnu.org/software/ncurses/" target="_blank" rel="external">ncurses</a> 封装，用来创建终端图形用户界面。<a href="https://docs.python.org/2/library/curses.html#module-curses" target="_blank" rel="external">官网</a></li>
<li>enaml：使用类似 QML 的Declaratic语法来创建美观的用户界面。<a href="https://github.com/nucleic/enaml" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/kivy/" target="_blank" rel="external">kivy</a>：一个用来创建自然用户交互（NUI）应用程序的库，可以运行在 Windows, Linux, Mac OS X, Android 以及 iOS平台上。<a href="https://kivy.org/" target="_blank" rel="external">官网</a></li>
<li>pyglet：一个Python 的跨平台窗口及多媒体库。<a href="https://bitbucket.org/pyglet/pyglet/wiki/Home" target="_blank" rel="external">官网</a></li>
<li>PyQt：跨平台用户界面框架 <a href="http://www.qt.io/" target="_blank" rel="external">Qt</a> 的 Python 绑定 ，支持Qt v4 和 Qt v5。<a href="https://riverbankcomputing.com/software/pyqt/intro" target="_blank" rel="external">官网</a></li>
<li>PySide：P跨平台用户界面框架 <a href="http://www.qt.io/" target="_blank" rel="external">Qt</a> 的 Python 绑定 ，支持Qt v4。<a href="https://wiki.qt.io/PySide" target="_blank" rel="external">官网</a></li>
<li>Tkinter：Tkinter 是 Python GUI 的一个事实标准库。<a href="https://wiki.python.org/moin/TkInter" target="_blank" rel="external">官网</a></li>
<li>Toga：一个 Python 原生的, 操作系统原生的 GUI 工具包。<a href="https://github.com/pybee/toga" target="_blank" rel="external">官网</a></li>
<li>urwid：一个用来创建终端 GUI 应用的库，支持组件，事件和丰富的色彩等。<a href="http://urwid.org/" target="_blank" rel="external">官网</a></li>
<li>wxPython：wxPython 是 wxWidgets C++ 类库和 Python 语言混合的产物。<a href="http://wxpython.org/" target="_blank" rel="external">官网</a></li>
<li>PyGObject：GLib/GObject/GIO/GTK+ (GTK+3) 的 Python 绑定<a href="https://wiki.gnome.org/Projects/PyGObject" target="_blank" rel="external">官网</a></li>
<li>Flexx：Flexx 是一个纯 Python 语言编写的用来创建 GUI 程序的工具集，它使用 web 技术进行界面的展示。<a href="https://github.com/zoofIO/flexx" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="游戏开发"><a href="#游戏开发" class="headerlink" title="游戏开发"></a>游戏开发</h3><p>超赞的游戏开发库。</p>
<ul>
<li>Cocos2d：cocos2d 是一个用来开发 2D 游戏， 示例和其他图形/交互应用的框架。基于 pyglet。<a href="http://cocos2d.org/" target="_blank" rel="external">官网</a></li>
<li>Panda3D：由迪士尼开发的 3D 游戏引擎，并由卡内基梅陇娱乐技术中心负责维护。使用C++编写, 针对 Python 进行了完全的封装。<a href="https://www.panda3d.org/" target="_blank" rel="external">官网</a></li>
<li>Pygame：Pygame 是一组 Python 模块，用来编写游戏。<a href="http://www.pygame.org/news.html" target="_blank" rel="external">官网</a></li>
<li>PyOgre：Ogre 3D 渲染引擎的 Python 绑定，可以用来开发游戏和仿真程序等任何 3D 应用。<a href="http://www.ogre3d.org/tikiwiki/PyOgre" target="_blank" rel="external">官网</a></li>
<li>PyOpenGL：OpenGL 的 Python 绑定及其相关 APIs。<a href="http://pyopengl.sourceforge.net/" target="_blank" rel="external">官网</a></li>
<li>PySDL2：SDL2 库的封装，基于 ctypes。<a href="http://pysdl2.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>RenPy：一个视觉小说（visual novel）引擎。<a href="https://www.renpy.org/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>用来生成和操作日志的库。</p>
<ul>
<li>logging：(Python 标准库) 为 Python 提供日志功能。<a href="https://docs.python.org/2/library/logging.html" target="_blank" rel="external">官网</a></li>
<li>logbook：Logging 库的替代品。<a href="http://pythonhosted.org/Logbook/" target="_blank" rel="external">官网</a></li>
<li>Eliot：为复杂的和分布式系统创建日志。<a href="https://eliot.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>Raven：Sentry的 Python 客户端。<a href="http://raven.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>Sentry：实时记录和收集日志的服务器。<a href="https://pypi.python.org/pypi/sentry" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h3><p>进行代码库测试和生成测试数据的库。</p>
<ul>
<li>测试框架<ul>
<li>unittest：(Python 标准库) 单元测试框架。<a href="https://docs.python.org/2/library/unittest.html" target="_blank" rel="external">官网</a></li>
<li>nose：nose 扩展了 unittest 的功能。<a href="https://nose.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>contexts：一个 Python 3.3+ 的 BDD 框架。受到C# – Machine.Specifications的启发。<a href="https://github.com/benjamin-hodgson/Contexts" target="_blank" rel="external">官网</a></li>
<li>hypothesis：Hypothesis 是一个基于先进的 Quickcheck 风格特性的测试库。<a href="https://github.com/DRMacIver/hypothesis" target="_blank" rel="external">官网</a></li>
<li>mamba：Python 的终极测试工具， 拥护BDD。<a href="http://nestorsalceda.github.io/mamba/" target="_blank" rel="external">官网</a></li>
<li>PyAutoGUI：PyAutoGUI 是一个人性化的跨平台 GUI 自动测试模块。<a href="https://github.com/asweigart/pyautogui" target="_blank" rel="external">官网</a></li>
<li>pyshould：Should 风格的断言，基于 <a href="https://github.com/hamcrest/PyHamcrest" target="_blank" rel="external">PyHamcrest</a>。<a href="https://github.com/drslump/pyshould" target="_blank" rel="external">官网</a></li>
<li>pytest：一个成熟的全功能 Python 测试工具。<a href="http://pytest.org/latest/" target="_blank" rel="external">官网</a></li>
<li>green：干净，多彩的测试工具。<a href="https://github.com/CleanCut/green" target="_blank" rel="external">官网</a></li>
<li>pyvows：BDD 风格的测试工具，受Vows.js的启发。<a href="http://heynemann.github.io/pyvows/" target="_blank" rel="external">官网</a>-</li>
<li>Robot Framework：一个通用的自动化测试框架。<a href="https://github.com/robotframework/robotframework" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Web 测试<ul>
<li>Selenium：<a href="http://www.seleniumhq.org/" target="_blank" rel="external">Selenium</a> WebDriver 的 Python 绑定。<a href="https://pypi.python.org/pypi/selenium" target="_blank" rel="external">官网</a></li>
<li>locust：使用 Python 编写的，可扩展的用户加载测试工具。<a href="https://github.com/locustio/locust" target="_blank" rel="external">官网</a></li>
<li>sixpack：一个和语言无关的 A/B 测试框架。<a href="https://github.com/seatgeek/sixpack" target="_blank" rel="external">官网</a></li>
<li>splinter：开源的 web 应用测试工具。<a href="https://splinter.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Mock测试<ul>
<li>mock：(Python 标准库) 一个用于伪造测试的库。<a href="https://docs.python.org/3/library/unittest.mock.html" target="_blank" rel="external">官网</a></li>
<li>doublex：Python 的一个功能强大的 doubles  测试框架。<a href="https://pypi.python.org/pypi/doublex" target="_blank" rel="external">官网</a></li>
<li>freezegun：通过伪造日期模块来生成不同的时间。<a href="https://github.com/spulec/freezegun" target="_blank" rel="external">官网</a></li>
<li>httmock：针对 Python 2.6+ 和 3.2+ 生成 伪造请求的库。<a href="https://github.com/patrys/httmock" target="_blank" rel="external">官网</a></li>
<li>httpretty：Python 的 HTTP 请求 mock 工具。<a href="http://falcao.it/HTTPretty/" target="_blank" rel="external">官网</a></li>
<li>responses：伪造 Python 中的 requests 库的一个通用库。<a href="https://github.com/getsentry/responses" target="_blank" rel="external">官网</a></li>
<li>VCR.py：在你的测试中记录和重放 HTTP 交互。<a href="https://github.com/kevin1024/vcrpy" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>对象工厂<ul>
<li>factoryboy：一个 Python 用的测试固件 (test fixtures) 替代库。<a href="https://github.com/rbarrois/factoryboy" target="_blank" rel="external">官网</a></li>
<li>mixer：另外一个测试固件 (test fixtures) 替代库，支持 Django, Flask, SQLAlchemy, Peewee 等。<a href="https://github.com/klen/mixer" target="_blank" rel="external">官网</a></li>
<li>modelmommy：为 Django 测试创建随机固件<a href="https://github.com/vandersonmota/modelmommy" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>代码覆盖率<ul>
<li>coverage：代码覆盖率测量。<a href="https://pypi.python.org/pypi/coverage" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>伪数据<ul>
<li>faker：一个 Python 库，用来生成伪数据。<a href="http://www.joke2k.net/faker/" target="_blank" rel="external">官网</a></li>
<li>fake2db：伪数据库生成器。<a href="https://github.com/emirozer/fake2db" target="_blank" rel="external">官网</a></li>
<li>radar：生成随机的日期/时间。<a href="https://pypi.python.org/pypi/radar" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>错误处理<ul>
<li>FuckIt.py：FuckIt.py 使用最先进的技术来保证你的 Python 代码无论对错都能继续运行。<a href="https://github.com/ajalt/fuckitpy" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="代码分析和Lint工具"><a href="#代码分析和Lint工具" class="headerlink" title="代码分析和Lint工具"></a>代码分析和Lint工具</h3><p>进行代码分析，解析和操作代码库的库和工具。</p>
<ul>
<li>代码分析<ul>
<li>code2flow：把你的 Python 和 JavaScript 代码转换为流程图。<a href="https://github.com/scottrogowski/code2flow" target="_blank" rel="external">官网</a></li>
<li>pycallgraph：这个库可以把你的Python 应用的流程(调用图)进行可视化。<a href="https://github.com/gak/pycallgraph" target="_blank" rel="external">官网</a></li>
<li>pysonar2：Python 类型推断和检索工具。<a href="https://github.com/yinwang0/pysonar2" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Lint工具<ul>
<li>Flake8：模块化源码检查工具: pep8, pyflakes 以及 co。<a href="https://pypi.python.org/pypi/flake8" target="_blank" rel="external">官网</a></li>
<li>Pylint：一个完全可定制的源码分析器。<a href="https://www.pylint.org/" target="_blank" rel="external">官网</a></li>
<li>pylama：Python 和 JavaScript 的代码审查工具。<a href="https://pylama.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>代码格式化<ul>
<li>autopep8：自动格式化 Python 代码，以使其符合 PEP8 规范。<a href="https://github.com/hhatto/autopep8" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="Debugging-Tools"><a href="#Debugging-Tools" class="headerlink" title="Debugging Tools"></a>Debugging Tools</h3><p>用来进行代码调试的库。</p>
<ul>
<li>调试器<ul>
<li>ipdb：IPython 启用的 <a href="https://docs.python.org/2/library/pdb.html" target="_blank" rel="external">pdb</a>。<a href="https://pypi.python.org/pypi/ipdb" target="_blank" rel="external">官网</a></li>
<li>pudb：全屏，基于控制台的 Python 调试器。<a href="https://pypi.python.org/pypi/pudb" target="_blank" rel="external">官网</a></li>
<li>pyringe：可以在 Python 进程中附加和注入代码的调试器。<a href="https://github.com/google/pyringe" target="_blank" rel="external">官网</a></li>
<li>wdb：一个奇异的 web 调试器，通过 WebSockets 工作。<a href="https://github.com/Kozea/wdb" target="_blank" rel="external">官网</a></li>
<li>winpdb：一个具有图形用户界面的 Python 调试器，可以进行远程调试，基于 rpdb2。<a href="http://winpdb.org/" target="_blank" rel="external">官网</a></li>
<li>django-debug-toolbar：为 Django 显示各种调试信息。<a href="https://github.com/django-debug-toolbar/django-debug-toolbar" target="_blank" rel="external">官网</a></li>
<li>django-devserver：一个 Django 运行服务器的替代品。<a href="https://github.com/dcramer/django-devserver" target="_blank" rel="external">官网</a></li>
<li>flask-debugtoolbar：django-debug-toolbar 的 flask 版。<a href="https://github.com/mgood/flask-debugtoolbar" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>性能分析器<ul>
<li>lineprofiler：逐行性能分析。<a href="https://github.com/rkern/lineprofiler" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/memory_profiler/" target="_blank" rel="external">Memory Profiler</a>：监控 Python 代码的内存使用。<a href="http://pypi.python.org/pypi/memory_profiler" target="_blank" rel="external">官网</a>、<a href="https://github.com/fabianp/memoryprofiler" target="_blank" rel="external">内存</a></li>
<li>profiling：一个交互式 Python 性能分析工具。<a href="https://github.com/what-studio/profiling" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>其他<ul>
<li>pyelftools：解析和分析 ELF 文件以及 DWARF 调试信息。<a href="https://github.com/eliben/pyelftools" target="_blank" rel="external">官网</a></li>
<li>python-statsd：<a href="https://github.com/etsy/statsd/" target="_blank" rel="external">statsd</a> 服务器的 Python 客户端。<a href="https://github.com/WoLpH/python-statsd" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="Science-and-Data-Analysis"><a href="#Science-and-Data-Analysis" class="headerlink" title="Science and Data Analysis"></a>Science and Data Analysis</h3><p>用来进行科学计算和数据分析的库。</p>
<ul>
<li>astropy：一个天文学 Python 库。<a href="http://www.astropy.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/bcbio-nextgen/" target="_blank" rel="external">bcbio-nextgen</a>：这个工具箱为全自动高通量测序分析提供符合最佳实践的处理流程。<a href="https://github.com/chapmanb/bcbio-nextgen" target="_blank" rel="external">官网</a></li>
<li>bccb：生物分析相关代码集合<a href="https://github.com/chapmanb/bcbb" target="_blank" rel="external">官网</a></li>
<li>Biopython：Biopython 是一组可以免费使用的用来进行生物计算的工具。<a href="http://biopython.org/wiki/MainPage" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/blaze/" target="_blank" rel="external">blaze</a>：NumPy 和 Pandas 的大数据接口。<a href="http://blaze.readthedocs.org/en/latest/index.html" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/cclib/" target="_blank" rel="external">cclib</a>：一个用来解析和解释计算化学软件包输出结果的库。<a href="http://cclib.github.io/" target="_blank" rel="external">官网</a></li>
<li>NetworkX：一个为复杂网络设计的高性能软件。<a href="https://networkx.github.io/" target="_blank" rel="external">官网</a></li>
<li>Neupy：执行和测试各种不同的人工神经网络算法。<a href="http://neupy.com/pages/home.html" target="_blank" rel="external">官网</a></li>
<li>Numba：Python JIT (just in time) 编译器，针对科学用的 Python ，由Cython 和 NumPy 的开发者开发。<a href="http://numba.pydata.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/numpy/" target="_blank" rel="external">NumPy</a>：使用 Python 进行科学计算的基础包。<a href="http://www.numpy.org/" target="_blank" rel="external">官网</a></li>
<li>Open Babel：一个化学工具箱，用来描述多种化学数据。<a href="http://openbabel.org/wiki/MainPage" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/open-mining/" target="_blank" rel="external">Open Mining</a>：使用 Python 挖掘商业情报 (BI) (Pandas web 接口)。<a href="https://github.com/mining/mining" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/orange/" target="_blank" rel="external">orange</a>：通过可视化编程或 Python 脚本进行数据挖掘，数据可视化，分析和机器学习。<a href="http://orange.biolab.si/" target="_blank" rel="external">官网</a></li>
<li>Pandas：提供高性能，易用的数据结构和数据分析工具。<a href="http://pandas.pydata.org/" target="_blank" rel="external">官网</a></li>
<li>PyDy：PyDy 是 Python Dynamics 的缩写，用来为动力学运动建模工作流程提供帮助， 基于 NumPy, SciPy, IPython 和 matplotlib。<a href="http://www.pydy.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/pymc/" target="_blank" rel="external">PyMC</a>：马尔科夫链蒙特卡洛采样工具。<a href="https://github.com/pymc-devs/pymc3" target="_blank" rel="external">官网</a></li>
<li>RDKit：化学信息学和机器学习软件。<a href="http://www.rdkit.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/scipy/" target="_blank" rel="external">SciPy</a>：由一些基于 Python ，用于数学，科学和工程的开源软件构成的生态系统。<a href="http://www.scipy.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/statsmodels/" target="_blank" rel="external">statsmodels</a>：统计建模和计量经济学。<a href="https://github.com/statsmodels/statsmodels" target="_blank" rel="external">官网</a></li>
<li>SymPy：一个用于符号数学的 Python 库。<a href="https://github.com/sympy/sympy" target="_blank" rel="external">官网</a></li>
<li>zipline：一个 Python 算法交易库。<a href="https://github.com/quantopian/zipline" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/bayesian-belief-networks/" target="_blank" rel="external">Bayesian-belief-networks</a>：优雅的贝叶斯信念网络框架。<a href="https://github.com/eBay/bayesian-belief-networks" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><p>进行数据可视化的库。 参见: <a href="https://github.com/sorrycc/awesome-javascript#data-visualization" target="_blank" rel="external">awesome-javascript</a>。</p>
<ul>
<li>matplotlib：一个 Python 2D 绘图库。<a href="http://matplotlib.org/" target="_blank" rel="external">官网</a></li>
<li>bokeh：用 Python 进行交互式 web 绘图。<a href="https://github.com/bokeh/bokeh" target="_blank" rel="external">官网</a></li>
<li>ggplot：ggplot2 给 R 提供的 API 的 Python 版本。<a href="https://github.com/yhat/ggplot" target="_blank" rel="external">官网</a></li>
<li>plotly：协同 Python 和 matplotlib 工作的 web 绘图库。<a href="https://plot.ly/python/" target="_blank" rel="external">官网</a></li>
<li>pygal：一个 Python SVG 图表创建工具。<a href="http://www.pygal.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>pygraphviz：Graphviz 的 Python 接口。<a href="https://pypi.python.org/pypi/pygraphviz" target="_blank" rel="external">官网</a></li>
<li>PyQtGraph：交互式实时2D/3D/图像绘制及科学/工程学组件。<a href="http://www.pyqtgraph.org/" target="_blank" rel="external">官网</a></li>
<li>SnakeViz：一个基于浏览器的 Python’s cProfile 模块输出结果查看工具。<a href="http://jiffyclub.github.io/snakeviz/" target="_blank" rel="external">官网</a></li>
<li>vincent：把 Python 转换为 Vega 语法的转换工具。<a href="https://github.com/wrobstory/vincent" target="_blank" rel="external">官网</a></li>
<li>VisPy：基于 OpenGL 的高性能科学可视化工具。<a href="http://vispy.org/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h3><p>计算机视觉库。</p>
<ul>
<li>OpenCV：开源计算机视觉库。<a href="http://opencv.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/simplecv/" target="_blank" rel="external">SimpleCV</a>：一个用来创建计算机视觉应用的开源框架。<a href="http://simplecv.org/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>机器学习库。 参见: <a href="https://github.com/josephmisiti/awesome-machine-learning#python" target="_blank" rel="external">awesome-machine-learning</a>.</p>
<ul>
<li>Crab：灵活、快速的推荐引擎。<a href="https://github.com/muricoca/crab" target="_blank" rel="external">官网</a></li>
<li>gensim：人性化的话题建模库。<a href="https://github.com/piskvorky/gensim" target="_blank" rel="external">官网</a></li>
<li>hebel：GPU 加速的深度学习库。<a href="https://github.com/hannes-brt/hebel" target="_blank" rel="external">官网</a></li>
<li>NuPIC：智能计算 Numenta 平台。<a href="https://github.com/numenta/nupic" target="_blank" rel="external">官网</a></li>
<li>pattern：Python 网络挖掘模块。<a href="https://github.com/clips/pattern" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/pybrain/" target="_blank" rel="external">PyBrain</a>：另一个 Python 机器学习库。<a href="https://github.com/pybrain/pybrain" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/pylearn2/" target="_blank" rel="external">Pylearn2</a>：一个基于 <a href="https://github.com/Theano/Theano" target="_blank" rel="external">Theano</a> 的机器学习库。<a href="https://github.com/lisa-lab/pylearn2" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/python-recsys/" target="_blank" rel="external">python-recsys</a>：一个用来实现推荐系统的 Python 库。<a href="https://github.com/ocelma/python-recsys" target="_blank" rel="external">官网</a></li>
<li>scikit-learn：基于 SciPy 构建的机器学习 Python 模块。<a href="http://scikit-learn.org/" target="_blank" rel="external">官网</a></li>
<li>pydeep：Python 深度学习库。<a href="https://github.com/andersbll/deeppy" target="_blank" rel="external">官网</a></li>
<li>vowpalporpoise：轻量级 <a href="https://github.com/JohnLangford/vowpalwabbit/" target="_blank" rel="external">Vowpal Wabbit</a> 的 Python 封装。<a href="https://github.com/josephreisinger/vowpalporpoise" target="_blank" rel="external">官网</a></li>
<li>skflow：一个 <a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">TensorFlow</a> 的简化接口(模仿 scikit-learn)。<a href="https://github.com/tensorflow/skflow" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>MapReduce 框架和库。</p>
<ul>
<li><a href="http://hao.jobbole.com/dpark/" target="_blank" rel="external">dpark</a>：Spark 的 Python 克隆版，一个类似 MapReduce 的框架。<a href="https://github.com/douban/dpark" target="_blank" rel="external">官网</a></li>
<li>dumbo：这个 Python 模块可以让人轻松的编写和运行 Hadoop 程序。<a href="https://github.com/klbostee/dumbo" target="_blank" rel="external">官网</a></li>
<li>luigi：这个模块帮你构建批处理作业的复杂流水线。<a href="https://github.com/spotify/luigi" target="_blank" rel="external">官网</a></li>
<li>mrjob：在 Hadoop 或 Amazon Web Services 上运行 MapReduce 任务。<a href="https://github.com/Yelp/mrjob" target="_blank" rel="external">官网</a></li>
<li>PySpark：Spark 的 Python API 。<a href="http://spark.apache.org/docs/latest/programming-guide.html" target="_blank" rel="external">官网</a></li>
<li>streamparse：运行针对事实数据流的 Python 代码。集成了<a href="http://storm.apache.org/" target="_blank" rel="external">Apache Storm</a>。<a href="https://github.com/Parsely/streamparse" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>使用 Python 进行函数式编程。</p>
<ul>
<li>CyToolz：Toolz 的 Cython 实现 : 高性能函数式工具。<a href="https://github.com/pytoolz/cytoolz/" target="_blank" rel="external">官网</a></li>
<li>fn.py：在 Python 中进行函数式编程 : 实现了一些享受函数式编程缺失的功能。<a href="https://github.com/kachayev/fn.py" target="_blank" rel="external">官网</a></li>
<li>funcy：炫酷又实用的函数式工具。<a href="https://github.com/Suor/funcy" target="_blank" rel="external">官网</a></li>
<li>Toolz：一组用于迭代器，函数和字典的函数式编程工具。<a href="https://github.com/pytoolz/toolz" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="第三方-API"><a href="#第三方-API" class="headerlink" title="第三方 API"></a>第三方 API</h3><p>用来访问第三方 API的库。 参见： <a href="https://github.com/realpython/list-of-python-api-wrappers" target="_blank" rel="external">List of Python API Wrappers and Libraries</a>。</p>
<ul>
<li>apache-libcloud：一个为各种云设计的 Python 库。<a href="https://libcloud.apache.org/" target="_blank" rel="external">官网</a></li>
<li>boto：Amazon Web Services 的 Python 接口。<a href="https://github.com/boto/boto" target="_blank" rel="external">官网</a></li>
<li>django-wordpress：WordPress models and views for Django.<a href="https://github.com/sunlightlabs/django-wordpress/" target="_blank" rel="external">官网</a></li>
<li>facebook-sdk：Facebook 平台的 Python SDK.<a href="https://github.com/mobolic/facebook-sdk" target="_blank" rel="external">官网</a></li>
<li>facepy：Facepy 让和 Facebook’s Graph API 的交互变得更容易。<a href="https://github.com/jgorset/facepy" target="_blank" rel="external">官网</a></li>
<li>gmail：Gmail 的 Python 接口。<a href="https://github.com/charlierguo/gmail" target="_blank" rel="external">官网</a></li>
<li>google-api-python-client：Python 用的 Google APIs 客户端库。<a href="https://github.com/google/google-api-python-client" target="_blank" rel="external">官网</a></li>
<li>gspread：Google 电子表格的 Python API.<a href="https://github.com/burnash/gspread" target="_blank" rel="external">官网</a></li>
<li>twython：Twitter API 的封装。<a href="https://github.com/ryanmcgrath/twython" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="DevOps-工具"><a href="#DevOps-工具" class="headerlink" title="DevOps 工具"></a>DevOps 工具</h3><p>用于 DevOps 的软件和库。</p>
<ul>
<li>Ansible：一个非常简单的 IT 自动化平台。<a href="https://github.com/ansible/ansible" target="_blank" rel="external">官网</a></li>
<li>SaltStack：基础设施自动化和管理系统。<a href="https://github.com/saltstack/salt" target="_blank" rel="external">官网</a></li>
<li>OpenStack：用于构建私有和公有云的开源软件。<a href="http://www.openstack.org/" target="_blank" rel="external">官网</a></li>
<li>Docker Compose：快速，分离的开发环境，使用 Docker。<a href="https://docs.docker.com/compose/" target="_blank" rel="external">官网</a></li>
<li>Fabric：一个简单的，Python 风格的工具，用来进行远程执行和部署。<a href="http://www.fabfile.org/" target="_blank" rel="external">官网</a></li>
<li>cuisine：为 Fabric 提供一系列高级函数。<a href="https://github.com/sebastien/cuisine" target="_blank" rel="external">官网</a></li>
<li>Fabtools：一个用来编写超赞的 Fabric 文件的工具。<a href="https://github.com/ronnix/fabtools" target="_blank" rel="external">官网</a></li>
<li>gitapi：Git 的纯 Python API。<a href="https://bitbucket.org/haard/gitapi" target="_blank" rel="external">官网</a></li>
<li>hgapi：Mercurial 的纯 Python API。<a href="https://bitbucket.org/haard/hgapi" target="_blank" rel="external">官网</a></li>
<li>honcho：<a href="https://github.com/ddollar/foreman" target="_blank" rel="external">Foreman</a>的 Python 克隆版，用来管理基于<a href="https://devcenter.heroku.com/articles/procfile" target="_blank" rel="external">Procfile</a>的应用。<a href="https://github.com/nickstenning/honcho" target="_blank" rel="external">官网</a></li>
<li>pexpect：Controlling interactive programs in a pseudo-terminal like 在一个伪终端中控制交互程序，就像 GNU expect 一样。<a href="https://github.com/pexpect/pexpect" target="_blank" rel="external">官网</a></li>
<li>psutil：一个跨平台进程和系统工具模块。<a href="https://github.com/giampaolo/psutil" target="_blank" rel="external">官网</a></li>
<li>supervisor：UNIX 的进程控制系统。<a href="https://github.com/Supervisor/supervisor" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>任务调度库。</p>
<ul>
<li>APScheduler：轻巧但强大的进程内任务调度，使你可以调度函数。<a href="http://apscheduler.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>django-schedule：一个 Django 排程应用。<a href="https://github.com/thauber/django-schedule" target="_blank" rel="external">官网</a></li>
<li>doit：一个任务执行和构建工具。<a href="http://pydoit.org/" target="_blank" rel="external">官网</a></li>
<li>gunnery：分布式系统使用的多用途任务执行工具 ，具有 web 交互界面。<a href="https://github.com/gunnery/gunnery" target="_blank" rel="external">官网</a></li>
<li>Joblib：一组为 Python 提供轻量级作业流水线的工具。<a href="http://pythonhosted.org/joblib/index.html" target="_blank" rel="external">官网</a></li>
<li>Plan：如有神助地编写 crontab 文件。<a href="https://github.com/fengsp/plan" target="_blank" rel="external">官网</a></li>
<li>schedule：人性化的 Python 任务调度库。<a href="https://github.com/dbader/schedule" target="_blank" rel="external">官网</a></li>
<li>Spiff：使用纯 Python 实现的强大的工作流引擎。<a href="https://github.com/knipknap/SpiffWorkflow" target="_blank" rel="external">官网</a></li>
<li>TaskFlow：一个可以让你方便执行任务的 Python 库，一致并且可靠。<a href="http://docs.openstack.org/developer/taskflow/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="外来函数接口"><a href="#外来函数接口" class="headerlink" title="外来函数接口"></a>外来函数接口</h3><p>使用外来函数接口的库。</p>
<ul>
<li>cffi：用来调用 C 代码的外来函数接口。<a href="https://pypi.python.org/pypi/cffi" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/ctypes/" target="_blank" rel="external">ctypes</a>：(Python 标准库) 用来调用 C 代码的外来函数接口。<a href="https://docs.python.org/2/library/ctypes.html" target="_blank" rel="external">官网</a></li>
<li>PyCUDA：Nvidia CUDA API 的封装。<a href="https://mathema.tician.de/software/pycuda/" target="_blank" rel="external">官网</a></li>
<li>SWIG：简化的封装和接口生成器。<a href="http://www.swig.org/Doc1.3/Python.html" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>让 Python 更快的库。</p>
<ul>
<li>Cython：优化的 Python 静态编译器。使用类型混合使 Python 编译成 C 或 C++ 模块来获得性能的极大提升。<a href="http://cython.org/" target="_blank" rel="external">官网</a></li>
<li>PeachPy：嵌入 Python 的 x86-64 汇编器。可以被用作 Python 内联的汇编器或者是独立的汇编器，用于 Windows, Linux, OS X, Native Client 或者 Go 。<a href="https://github.com/Maratyszcza/PeachPy" target="_blank" rel="external">官网</a></li>
<li>PyPy：使用 Python 实现的 Python。解释器使用黑魔法加快 Python 运行速度且不需要加入额外的类型信息。<a href="http://pypy.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/pyston-llvm-jit/" target="_blank" rel="external">Pyston</a>：使用 LLVM 和现代 JIT 技术构建的 Python 实现，目标是为了获得很好的性能。<a href="https://github.com/dropbox/pyston" target="_blank" rel="external">官网</a></li>
<li>Stackless Python：一个强化版的 Python。<a href="https://bitbucket.org/stackless-dev/stackless/overview" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="微软的-Windows平台"><a href="#微软的-Windows平台" class="headerlink" title="微软的 Windows平台"></a>微软的 Windows平台</h3><p>在 Windows 平台上进行 Python 编程。</p>
<ul>
<li>Python(x,y)：面向科学应用的 Python 发行版，基于 Qt 和 Spyder。<a href="http://python-xy.github.io/" target="_blank" rel="external">官网</a></li>
<li>pythonlibs：非官方的 Windows 平台 Python 扩展二进制包。<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="external">官网</a></li>
<li>PythonNet：Python 与 .NET 公共语言运行库 (CLR)的集成。<a href="https://github.com/pythonnet/pythonnet" target="_blank" rel="external">官网</a></li>
<li>PyWin32：针对 Windows 的Python 扩展。<a href="https://sourceforge.net/projects/pywin32/" target="_blank" rel="external">官网</a></li>
<li>WinPython：Windows 7/8 系统下便携式开发环境。<a href="https://winpython.github.io/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="网络可视化和SDN"><a href="#网络可视化和SDN" class="headerlink" title="网络可视化和SDN"></a>网络可视化和SDN</h3><p>用来进行网络可视化和SDN(软件定义网络)的工具和库。</p>
<ul>
<li>Mininet：一款流行的网络模拟器以及用 Python 编写的 API。<a href="http://mininet.org/" target="_blank" rel="external">官网</a></li>
<li>POX：一个针对基于 Python 的软件定义网络应用（例如 OpenFlow SDN 控制器）的开源开发平台。<a href="https://github.com/noxrepo/pox" target="_blank" rel="external">官网</a></li>
<li>Pyretic：火热的 SDN 编程语言中的一员，为网络交换机和模拟器提供强大的抽象能力。<a href="http://frenetic-lang.org/pyretic/" target="_blank" rel="external">官网</a></li>
<li>SDX Platform：基于 SDN 的 IXP 实现，影响了 Mininet, POX 和 Pyretic。<a href="https://github.com/sdn-ixp/internet2award" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>用来对硬件进行编程的库。</p>
<ul>
<li>ino：操作<a href="https://www.arduino.cc/" target="_blank" rel="external">Arduino</a>的命令行工具。<a href="http://inotool.org/" target="_blank" rel="external">官网</a> </li>
<li>Pyro：Python 机器人编程库。<a href="http://pyrorobotics.com/" target="_blank" rel="external">官网</a></li>
<li>PyUserInput：跨平台的，控制鼠标和键盘的模块。<a href="https://github.com/SavinaRoja/PyUserInput" target="_blank" rel="external">官网</a></li>
<li>scapy：一个非常棒的操作数据包的库。<a href="https://github.com/secdev/scapy" target="_blank" rel="external">官网</a></li>
<li>wifi：一个 Python 库和命令行工具用来在 Linux 平台上操作WiFi。<a href="https://wifi.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>Pingo：Pingo 为类似Raspberry Pi，pcDuino， Intel Galileo等设备提供统一的API用以编程。<a href="http://www.pingo.io/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>帮助从 Python 2 向 Python 3迁移的库。</p>
<ul>
<li>Python-Future：这就是 Python 2 和 Python 3 之间丢失的那个兼容性层。<a href="http://python-future.org/index.html" target="_blank" rel="external">官网</a></li>
<li>Python-Modernize：使 Python 代码更加现代化以便最终迁移到 Python 3。<a href="https://github.com/mitsuhiko/python-modernize" target="_blank" rel="external">官网</a></li>
<li>Six：Python 2 和 3 的兼容性工具。<a href="https://pypi.python.org/pypi/six" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>不属于上面任何一个类别，但是非常有用的库。</p>
<ul>
<li>blinker：一个快速的 Python 进程内信号/事件分发系统。<a href="https://github.com/jek/blinker" target="_blank" rel="external">官网</a></li>
<li>itsdangerous：一系列辅助工具用来将可信的数据传入不可信的环境。<a href="https://github.com/pallets/itsdangerous" target="_blank" rel="external">官网</a></li>
<li>pluginbase：一个简单但是非常灵活的 Python 插件系统。<a href="https://github.com/mitsuhiko/pluginbase" target="_blank" rel="external">官网</a></li>
<li>Pychievements：一个用来创建和追踪成就的 Python 框架。<a href="https://github.com/PacketPerception/pychievements" target="_blank" rel="external">官网</a></li>
<li>Tryton：一个通用商务框架。<a href="http://www.tryton.org/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="算法和设计模式"><a href="#算法和设计模式" class="headerlink" title="算法和设计模式"></a>算法和设计模式</h3><p>Python 实现的算法和设计模式。</p>
<ul>
<li><a href="http://hao.jobbole.com/algorithms/" target="_blank" rel="external">algorithms</a>：一个 Python 算法模块。<a href="https://github.com/nryoung/algorithms" target="_blank" rel="external">官网</a> </li>
<li>python-patterns：Python 设计模式的集合。<a href="https://github.com/faif/python-patterns" target="_blank" rel="external">官网</a></li>
<li>sortedcontainers：快速，纯 Python 实现的SortedList，SortedDict 和 SortedSet 类型。<a href="http://www.grantjenks.com/docs/sortedcontainers/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="编辑器插件"><a href="#编辑器插件" class="headerlink" title="编辑器插件"></a>编辑器插件</h3><p>编辑器和 IDE 的插件</p>
<ul>
<li>Emacs<ul>
<li>Elpy：Emacs Python 开发环境。<a href="https://github.com/jorgenschaefer/elpy" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Sublime Text<ul>
<li>SublimeJEDI：一个 Sublime Text 插件，用来使用超赞的自动补全库 Jedi。<a href="https://github.com/srusskih/SublimeJEDI" target="_blank" rel="external">官网</a></li>
<li>Anaconda：Anaconda 把你的 Sublime Text 3 变成一个功能齐全的 Python IDE。<a href="https://github.com/DamnWidget/anaconda" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Vim<ul>
<li><a href="http://hao.jobbole.com/youcompleteme/" target="_blank" rel="external">YouCompleteMe</a>：引入基于 <a href="https://github.com/davidhalter/jedi" target="_blank" rel="external">Jedi</a> 的 Python 自动补全引擎。<a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="external">官网</a></li>
<li>Jedi-vim：绑定 Vim 和 Jedi 自动补全库对 Python 进行自动补全。<a href="https://github.com/davidhalter/jedi-vim" target="_blank" rel="external">官网</a></li>
<li>Python-mode：将 Vim 变成 Python IDE 的一款多合一插件。<a href="https://github.com/klen/python-mode" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Visual Studio<ul>
<li>PTVS：Visual Studio 的 Python 工具<a href="https://github.com/Microsoft/PTVS" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="集成开发环境"><a href="#集成开发环境" class="headerlink" title="集成开发环境"></a>集成开发环境</h3><p>流行的 Python 集成开发环境。</p>
<ul>
<li>PyCharm：商业化的 Python IDE ，由 JetBrains 开发。也有免费的社区版提供。<a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="external">官网</a></li>
<li>LiClipse：基于 Eclipse 的免费多语言 IDE 。使用 PyDev 来支持 Python 。<a href="http://www.liclipse.com/" target="_blank" rel="external">官网</a></li>
<li>Spyder：开源 Python IDE。<a href="https://github.com/spyder-ide/spyder" target="_blank" rel="external">官网</a></li>
</ul>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>在线工具和简化开发的 API 。</p>
<h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><p>参见: <a href="https://github.com/ciandcd/awesome-ciandcd#online-build-system" target="_blank" rel="external">awesome-CIandCD</a>.</p>
<ul>
<li>Travis CI：一个流行的工具，为你的开源和<a href="https://travis-ci.com/" target="_blank" rel="external">私人</a>项目提供持续集成服务。(仅支持 GitHub)<a href="https://travis-ci.org/" target="_blank" rel="external">官网</a></li>
<li>CircleCI：一个持续集成工具，可以非常快速的进行并行测试。 (仅支持 GitHub)<a href="https://circleci.com/" target="_blank" rel="external">官网</a></li>
<li>Vexor CI：一个为私人 app 提供持续集成的工具，支持按分钟付费。<a href="https://vexor.io/" target="_blank" rel="external">官网</a></li>
<li>Wercker：基于 Docker 平台，用来构建和部署微服务。<a href="http://wercker.com/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="代码质量"><a href="#代码质量" class="headerlink" title="代码质量"></a>代码质量</h3><ul>
<li>Codacy：自动化代码审查，更加快速的发布高质量代码。对于开源项目是免费的。<a href="https://www.codacy.com/" target="_blank" rel="external">官网</a></li>
<li>QuantifiedCode：一个数据驱动、自动、持续的代码审查工具。<a href="https://www.quantifiedcode.com/" target="_blank" rel="external">官网</a></li>
</ul>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>在这里可以找到新的 Python 库。</p>
<h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul>
<li><a href="https://www.reddit.com/r/python" target="_blank" rel="external">r/Python</a></li>
<li><a href="https://www.coolgithubprojects.com/" target="_blank" rel="external">CoolGithubProjects</a></li>
<li><a href="https://www.djangopackages.com/" target="_blank" rel="external">Django Packages</a></li>
<li><a href="http://www.fullstackpython.com/" target="_blank" rel="external">Full Stack Python</a></li>
<li><a href="http://python3wos.appspot.com/" target="_blank" rel="external">Python 3 Wall of Superpowers</a></li>
<li><a href="http://pythonhackers.com/open-source/" target="_blank" rel="external">Python Hackers</a></li>
<li><a href="https://python.zeef.com/alan.richmond" target="_blank" rel="external">Python ZEEF</a></li>
<li><a href="https://github.com/trending?l=python" target="_blank" rel="external">Trending Python repositories on GitHub today</a></li>
<li><a href="http://pypi-ranking.info/alltime" target="_blank" rel="external">PyPI Ranking</a></li>
</ul>
<h3 id="周刊"><a href="#周刊" class="headerlink" title="周刊"></a>周刊</h3><ul>
<li><a href="http://importpython.com/newsletter/" target="_blank" rel="external">Import Python Newsletter</a></li>
<li><a href="http://pycoders.com/" target="_blank" rel="external">Pycoder’s Weekly</a></li>
<li><a href="http://www.pythonweekly.com/" target="_blank" rel="external">Python Weekly</a></li>
</ul>
<h3 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a>Twitter</h3><ul>
<li><a href="https://twitter.com/codetengu" target="_blank" rel="external">@codetengu</a></li>
<li><a href="https://twitter.com/getpy" target="_blank" rel="external">@getpy</a></li>
<li><a href="https://twitter.com/planetpython" target="_blank" rel="external">@planetpython</a></li>
<li><a href="https://twitter.com/pycoders" target="_blank" rel="external">@pycoders</a></li>
<li><a href="https://twitter.com/pypi" target="_blank" rel="external">@pypi</a></li>
<li><a href="https://twitter.com/pythontrending" target="_blank" rel="external">@pythontrending</a></li>
<li><a href="https://twitter.com/PythonWeekly" target="_blank" rel="external">@PythonWeekly</a></li>
</ul>
<h3 id="学习指南"><a href="#学习指南" class="headerlink" title="学习指南"></a>学习指南</h3><ul>
<li><a href="http://hao.jobbole.com/scipy-lecture-notes/" target="_blank" rel="external">Scipy-lecture-notes</a>：如何用Python来做学术？<a href="https://github.com/scipy-lectures/scipy-lecture-notes" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/scientific-python-lectures/" target="_blank" rel="external">SScientific-python-lectures</a>：Python科学计算的资料。<a href="https://github.com/jrjohansson/scientific-python-lectures" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/mario-level-1/" target="_blank" rel="external">Mario-Level-1</a>：用Python和Pygame写的超级马里奥第一关。<a href="https://github.com/justinmeister/Mario-Level-1" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/python-koans/" target="_blank" rel="external">Python Koans</a>：Python的交互式学习工具。<a href="https://github.com/gregmalcolm/python_koans" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/minecraft-python/" target="_blank" rel="external">Minecraft</a>：用python写的Minecraft游戏。<a href="https://github.com/fogleman/Minecraft" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/python-pycrumbs/" target="_blank" rel="external">pycrumbs</a>：Python资源大全。<a href="https://github.com/kirang89/pycrumbs/blob/master/pycrumbs.md" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/python-patterns/" target="_blank" rel="external">python-patterns</a>：使用python实现设计模式。<a href="https://github.com/faif/python-patterns" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/python-projects/" target="_blank" rel="external">Projects</a>：Python项目大集合。<a href="https://github.com/karan/Projects" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/the-hitchhikers-guide-to-python/" target="_blank" rel="external">The Hitchhiker’s Guide to Python</a>：旅行者的Python学习指南。<a href="http://docs.python-guide.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li><a href="http://top.jobbole.com/18767/" target="_blank" rel="external">Code Like a Pythonista: Idiomatic Python</a>：如何像Python高手(Pythonista)一样编程。<a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html" target="_blank" rel="external">官网</a></li>
</ul>
<p></p><h3 id="websites">知名网站</h3><br><em>值得关注的 Python 技术站点。</em><p></p>
<h4>中文站点</h4>

<ul>
<li>伯乐在线 Python 频道：分享 Python 开发技术、相关的行业动态。<a href="http://python.jobbole.com/" target="_blank" rel="external">官网</a></li>
</ul>
<h4>英文站点</h4>

<ul>
<li>《<a href="http://python.jobbole.com/81730/" target="_blank" rel="external">值得关注的 10 个 Python 英文博客</a>》</li>
</ul>
<p></p><h3 id="weibo-weixin">微博、微信公众号</h3><p></p>
<ul>
<li>Python开发者 微博：<a href="http://weibo.com/u/5305630013" target="_blank" rel="external">@Python开发者</a></li>
<li>Python开发者：人生苦短，我用 Python。Python 越来越受广大程序员的喜爱。「Python开发者」是最受欢迎的、专注分享Python技术的微信公众号，主要分享 Python 相关的技术文章、工具资源和资讯等。<br><br><img src="http://ww3.sinaimg.cn/small/63918611gw1epb2cbm6cmj2046046wek.jpg" width="150" height="150"></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[xx-net 使用方法]]></title>
      <url>http://yusank.github.io/xxnet.html/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>注意：    </p>
<ol>
<li>由于封锁严重，软件自带IP已经被封杀殆尽。因此需要<strong>数分钟到数小时的初始化IP扫描</strong>，方能正常运行。    </li>
<li>虽然系统内置了公共appid, 还是建议[[部署自己的appid|how to create my appids]]，公共appid限制看视频。需要注意的是，只有当你能访问Google之后，才能部署自己的APPID。    </li>
</ol>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>总体来说，使用XX-Net科学上网，大致需要如下步骤：    </p>
<ol>
<li><strong>[[获取XX-Net|<a href="https://github.com/XX-net/XX-Net/blob/master/code/default/download.md" target="_blank" rel="external">https://github.com/XX-net/XX-Net/blob/master/code/default/download.md</a>]]</strong>    </li>
<li><strong>设置和初始化</strong>：安装、设置完成后，如果无法翻墙，则需要等待后台程序扫描IP（10分钟到数小时）。    </li>
<li>[可选]<strong>[[创建和使用自己的appid|how to create my appids]]</strong>    </li>
<li><strong>[[设置代理]]</strong>    </li>
<li>[强烈建议]<strong>获取和配置可靠的浏览器</strong>（[[Firefox火狐浏览器|使用Firefox浏览器]]，或[[Chrome谷歌浏览器|使用Chrome浏览器]]），并使用[[代理切换插件|安装和使用-SwitchyOmega]]。</li>
</ol>
<p>下面分别介绍各个操作系统平台下的使用方法：</p>
<h1 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h1><ol>
<li>双击 start.vbs或者start.bat启动。<ul>
<li>Win7/8/10：将提示请求管理员权限（出于[[安装CA证书|GoAgent Import CA]]的需要）。请点击同意。</li>
</ul>
</li>
<li>启动完毕后，将弹出浏览器，访问 <a href="http://localhost:8085/" target="_blank" rel="external">http://localhost:8085/</a> （[[配置页面简介]]）</li>
<li>右下角将出现托盘图标：点击可弹出上述的XX-Net配置页面, 右键可显示[[常用功能菜单|托盘右键菜单]]。</li>
<li>第一次启动, 会提示在桌面建立快捷方式,可根据自己需要选择。</li>
</ol>
<ul>
<li>推荐[[使用Chrome浏览器]], [[安装SwichySharp|安装和使用SwichySharp]], 可在XX-Net目录中的SwitchySharp文件夹下找到插件和配置文件。</li>
<li>也可以选择[[使用Firefox（火狐）浏览器|使用Firefox浏览器]]。需[[手动导入证书|GoAgent Import CA#Firefox浏览器手动导入的方式]]</li>
<li><p>启动失败，请关闭后双击start.bat再次启动程序，把日志发到bug反馈区  </p>
</li>
<li><p>WinXP，需要破解tcp连接数，推荐使用<a href="https://github.com/XX-net/tcp-z/archive/master.zip" target="_blank" rel="external">tcp-z</a>  </p>
</li>
<li>Win8，win10 的APP，需要使用：<a href="https://loopback.codeplex.com/" target="_blank" rel="external">https://loopback.codeplex.com/</a>   </li>
<li>Windows Server 2008，需要安装  Visual C++ 2008 Redistributable - x86  </li>
</ul>
<p>针对两种常用浏览器，分别有详细的新手图文教程：[[使用Firefox浏览器]]、[[使用Chrome浏览器]]</p>
<h1 id="Mac系统"><a href="#Mac系统" class="headerlink" title="Mac系统"></a>Mac系统</h1><ol>
<li>双击 start 启动</li>
<li>证书将被自动导入，如果还有提示非安全连接，请手动导入data/gae_proxy/CA.crt证书</li>
</ol>
<p>注：</p>
<ul>
<li>命令行启动方式：./start</li>
<li>推荐[[使用Chrome|使用Chrome浏览器]]和[[SwitchyOmega扩展|安装和使用SwichySharp]]</li>
<li>部分版本可能需要手动升级python。命令为：brew upgrade</li>
</ul>
<h1 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h1><ul>
<li><p>执行 ./start 启动</p>
</li>
<li><p>自动导入证书，需安装 libnss3-tools 包<br><code>sudo apt-get install libnss3-tools</code></p>
</li>
<li>没有安装PyGtk的，需要先安装gtk：<br><code>sudo apt-get install python-gtk2</code></li>
<li>配置http代理 localhost 8087, 勾选全部协议使用这个代理。<br>如Firefox，如果管理页面弹不出，请在地址栏输入127.0.0.1:8085，注意和代理端口的区别：<br><img src="https://github.com/sonichy/CMDU/blob/master/Firefox%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE.png" alt=""><br>推荐Chrome + SwitchyOmega</li>
<li>ubuntu 下，可能需要安装<br> <code>sudo apt-get install python-openssl</code><br> <code>sudo apt-get install libffi-dev</code><br> <code>sudo apt-get install -y python-gtk2</code><br> <code>sudo apt-get install python-appindicator</code><br> <code>sudo apt-get install libnss3-tools</code>  </li>
<li>后台运行：在终端中运行：<br> <code>code/default/xx_net.sh start/stop/restart</code></li>
<li>开机自启：在/etc/rc.local中添加一行：<br> <code>sudo /home/username/xxnet/code/default/xx_net.sh start</code></li>
</ul>
<h2 id="关于-ArchLinux"><a href="#关于-ArchLinux" class="headerlink" title="关于 ArchLinux"></a>关于 ArchLinux</h2><ul>
<li>可能需要的包: <code>python-pyopenssl python2-pyopenssl libffi pygtk python2-notify nss</code>  </li>
</ul>
<h2 id="关于-Fedora"><a href="#关于-Fedora" class="headerlink" title="关于 Fedora"></a>关于 Fedora</h2><ul>
<li>添加 <a href="https://github.com/FZUG/repo/wiki/%E6%B7%BB%E5%8A%A0-FZUG-%E6%BA%90" target="_blank" rel="external">FZUG 源</a>，安装 xx-net</li>
<li>执行 <code>xx-net</code> 或 <code>systemctl --user start xx-net</code> (后台)启动</li>
<li>配置浏览器代理插件</li>
</ul>
<h1 id="其他平台"><a href="#其他平台" class="headerlink" title="其他平台"></a>其他平台</h1><h2 id="OpenWrt"><a href="#OpenWrt" class="headerlink" title="OpenWrt"></a>OpenWrt</h2><ul>
<li>[[在OpenWrt里运行XX-Net]]<br></li>
<li>[[在装有梅林固件的Netgear R6300V2上安装XX Net]]<br></li>
</ul>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>  计划开发中<br>  [[Android技术设计]]</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="关于服务端"><a href="#关于服务端" class="headerlink" title="关于服务端"></a>关于服务端</h2><ul>
<li>服务端兼容 GoAgent 3.1.x/3.2.x的客户端</li>
<li>虽然系统内置了公共appid, 还是建议[[部署自己的appid|how to create my appids]]。</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>如果出现异常，请翻阅[[故障速查手册]]，查看常见问题和解决方法。    </p>
<p>无法解决的，参考[[异常处理|How-to-get-start-error-log]]，将问题反馈到：<br><code>https://github.com/XX-net/XX-Net/issues</code><br><code>https://groups.google.com/forum/#!forum/xx-net</code>  </p>
<p>提交issue时请贴出状态页、GAE_proxy日志、部署日志，以便开发者和其他用户更好地帮助你。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://yusank.github.io/hello-world.html/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
